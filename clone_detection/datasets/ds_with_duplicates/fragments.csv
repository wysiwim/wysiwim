,id,func,code
1766,22486941,7,"    public void modifyBubble(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i % 2 != 0) {
                for (int j = array.length - i / 2 - 2; j >= i / 2; j--) {
                    if (array[j] >= array[j + 1]) {
                        int temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            } else {
                for (int j = i / 2; j < array.length - 1 - i / 2; j++) {
                    if (array[j] >= array[j + 1]) {
                        int temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            }
        }
    }
"
9814,22307690,7,"    public static void main(String args[]) {
        int summ = 0;
        int temp = 0;
        int[] a1 = { 0, 6, -7, -7, 61, 8, 20, 0, 8, 3, 6, 2, 7, 99, 0, 23, 12, 7, 9, 5, 33, 1, 3, 99, 99, 61, 99, 99, 99, 61, 61, 61, -3, -3, -3, -3 };
        for (int j = 0; j < (a1.length * a1.length); j++) {
            for (int i = 0; i < a1.length - 1; i++) {
                if (a1[i] > a1[i + 1]) {
                    temp = a1[i];
                    a1[i] = a1[i + 1];
                    a1[i + 1] = temp;
                }
            }
        }
        for (int i = 0; i < a1.length; i++) {
            System.out.print("" "" + a1[i]);
        }
        int min = 0;
        int max = 0;
        summ = (a1[1]) + (a1[a1.length - 1]);
        for (int i = 0; i < a1.length; i++) {
            if (a1[i] > a1[0] && a1[i] != a1[0]) {
                min = a1[i];
                break;
            }
        }
        for (int i = a1.length - 1; i > 0; i--) {
            if (a1[i] < a1[a1.length - 1] & a1[i] != a1[a1.length - 1]) {
                max = a1[i];
                break;
            }
        }
        System.out.println();
        System.out.print(""summa 2 min N 2 max = "" + summ);
        System.out.println(min);
        System.out.println(max);
        System.out.println(""summa 2 min N 2 max = "" + (min + max));
    }
"
9173,345995,7,"    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
"
4960,170006,7,"    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
"
6903,11335657,7,"    public void sorter() {
        String inputLine1, inputLine2;
        String epiNames[] = new String[1000];
        String epiEpisodes[] = new String[1000];
        int lineCounter = 0;
        try {
            String pluginDir = pluginInterface.getPluginDirectoryName();
            String eplist_file = pluginDir + System.getProperty(""file.separator"") + ""EpisodeList.txt"";
            File episodeList = new File(eplist_file);
            if (!episodeList.isFile()) {
                episodeList.createNewFile();
            }
            final BufferedReader in = new BufferedReader(new FileReader(episodeList));
            while ((inputLine1 = in.readLine()) != null) {
                if ((inputLine2 = in.readLine()) != null) {
                    epiNames[lineCounter] = inputLine1;
                    epiEpisodes[lineCounter] = inputLine2;
                    lineCounter++;
                }
            }
            in.close();
            int epiLength = epiNames.length;
            for (int i = 0; i < (lineCounter); i++) {
                for (int j = 0; j < (lineCounter - 1); j++) {
                    if (epiNames[j].compareToIgnoreCase(epiNames[j + 1]) > 0) {
                        String temp = epiNames[j];
                        epiNames[j] = epiNames[j + 1];
                        epiNames[j + 1] = temp;
                        String temp2 = epiEpisodes[j];
                        epiEpisodes[j] = epiEpisodes[j + 1];
                        epiEpisodes[j + 1] = temp2;
                    }
                }
            }
            File episodeList2 = new File(eplist_file);
            BufferedWriter bufWriter = new BufferedWriter(new FileWriter(episodeList2));
            for (int i = 0; i <= lineCounter; i++) {
                if (epiNames[i] == null) {
                    break;
                }
                bufWriter.write(epiNames[i] + ""\n"");
                bufWriter.write(epiEpisodes[i] + ""\n"");
            }
            bufWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
"
2754,359113,7,"    public static void bubbleSort(String[] a) {
        Collator myCollator = Collator.getInstance();
        boolean switched = true;
        for (int pass = 0; pass < a.length - 1 && switched; pass++) {
            switched = false;
            for (int i = 0; i < a.length - pass - 1; i++) {
                if (myCollator.compare(a[i], a[i + 1]) > 0) {
                    switched = true;
                    String temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
        }
    }
"
2858,9385633,7,"    protected void setRankOrder() {
        this.rankOrder = new int[values.length];
        for (int i = 0; i < rankOrder.length; i++) {
            rankOrder[i] = i;
            assert (!Double.isNaN(values[i]));
        }
        for (int i = rankOrder.length - 1; i >= 0; i--) {
            boolean swapped = false;
            for (int j = 0; j < i; j++) if (values[rankOrder[j]] < values[rankOrder[j + 1]]) {
                int r = rankOrder[j];
                rankOrder[j] = rankOrder[j + 1];
                rankOrder[j + 1] = r;
            }
        }
    }
"
10602,22137813,7,"    public static ObjectID[] sortDecending(ObjectID[] oids) {
        for (int i = 1; i < oids.length; i++) {
            ObjectID iId = oids[i];
            for (int j = 0; j < oids.length - i; j++) {
                if (oids[j].getTypePrefix() > oids[j + 1].getTypePrefix()) {
                    ObjectID temp = oids[j];
                    oids[j] = oids[j + 1];
                    oids[j + 1] = temp;
                }
            }
        }
        return oids;
    }
"
11114,15757836,7,"    private int[] sort(int n) {
        int[] mas = new int[n];
        Random rand = new Random();
        for (int i = 0; i < n; i++) {
            mas[i] = rand.nextInt(10) + 1;
        }
        boolean t = true;
        int tmp = 0;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    tmp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = tmp;
                    t = true;
                }
            }
        }
        return mas;
    }
"
5775,20680657,7,"    protected void sort(int a) {
        int[] masiv = new int[a + 1];
        Random fff = new Random();
        for (int i = 0; i <= a; i++) {
            masiv[i] = fff.nextInt(9);
        }
        int d;
        for (int j = 0; j < a; j++) {
            for (int i = 0; i < a; i++) {
                if (masiv[i] < masiv[i + 1]) {
                } else {
                    d = masiv[i];
                    masiv[i] = masiv[i + 1];
                    masiv[i + 1] = d;
                }
            }
        }
        while (a != 0) {
            System.out.println(""sort: "" + masiv[a]);
            a--;
        }
    }
"
6148,2067794,7,"    public SingularValueDecomposition(Matrix Arg) {
        double[][] A = Arg.getArrayCopy();
        m = Arg.getRowDimension();
        n = Arg.getColumnDimension();
        int nu = Math.min(m, n);
        s = new double[Math.min(m + 1, n)];
        U = new double[m][nu];
        V = new double[n][n];
        double[] e = new double[n];
        double[] work = new double[m];
        boolean wantu = true;
        boolean wantv = true;
        int nct = Math.min(m - 1, n);
        int nrt = Math.max(0, Math.min(n - 2, m));
        for (int k = 0; k < Math.max(nct, nrt); k++) {
            if (k < nct) {
                s[k] = 0;
                for (int i = k; i < m; i++) {
                    s[k] = Maths.hypot(s[k], A[i][k]);
                }
                if (s[k] != 0.0) {
                    if (A[k][k] < 0.0) {
                        s[k] = -s[k];
                    }
                    for (int i = k; i < m; i++) {
                        A[i][k] /= s[k];
                    }
                    A[k][k] += 1.0;
                }
                s[k] = -s[k];
            }
            for (int j = k + 1; j < n; j++) {
                if ((k < nct) & (s[k] != 0.0)) {
                    double t = 0;
                    for (int i = k; i < m; i++) {
                        t += A[i][k] * A[i][j];
                    }
                    t = -t / A[k][k];
                    for (int i = k; i < m; i++) {
                        A[i][j] += t * A[i][k];
                    }
                }
                e[j] = A[k][j];
            }
            if (wantu & (k < nct)) {
                for (int i = k; i < m; i++) {
                    U[i][k] = A[i][k];
                }
            }
            if (k < nrt) {
                e[k] = 0;
                for (int i = k + 1; i < n; i++) {
                    e[k] = Maths.hypot(e[k], e[i]);
                }
                if (e[k] != 0.0) {
                    if (e[k + 1] < 0.0) {
                        e[k] = -e[k];
                    }
                    for (int i = k + 1; i < n; i++) {
                        e[i] /= e[k];
                    }
                    e[k + 1] += 1.0;
                }
                e[k] = -e[k];
                if ((k + 1 < m) & (e[k] != 0.0)) {
                    for (int i = k + 1; i < m; i++) {
                        work[i] = 0.0;
                    }
                    for (int j = k + 1; j < n; j++) {
                        for (int i = k + 1; i < m; i++) {
                            work[i] += e[j] * A[i][j];
                        }
                    }
                    for (int j = k + 1; j < n; j++) {
                        double t = -e[j] / e[k + 1];
                        for (int i = k + 1; i < m; i++) {
                            A[i][j] += t * work[i];
                        }
                    }
                }
                if (wantv) {
                    for (int i = k + 1; i < n; i++) {
                        V[i][k] = e[i];
                    }
                }
            }
        }
        int p = Math.min(n, m + 1);
        if (nct < n) {
            s[nct] = A[nct][nct];
        }
        if (m < p) {
            s[p - 1] = 0.0;
        }
        if (nrt + 1 < p) {
            e[nrt] = A[nrt][p - 1];
        }
        e[p - 1] = 0.0;
        if (wantu) {
            for (int j = nct; j < nu; j++) {
                for (int i = 0; i < m; i++) {
                    U[i][j] = 0.0;
                }
                U[j][j] = 1.0;
            }
            for (int k = nct - 1; k >= 0; k--) {
                if (s[k] != 0.0) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k; i < m; i++) {
                            t += U[i][k] * U[i][j];
                        }
                        t = -t / U[k][k];
                        for (int i = k; i < m; i++) {
                            U[i][j] += t * U[i][k];
                        }
                    }
                    for (int i = k; i < m; i++) {
                        U[i][k] = -U[i][k];
                    }
                    U[k][k] = 1.0 + U[k][k];
                    for (int i = 0; i < k - 1; i++) {
                        U[i][k] = 0.0;
                    }
                } else {
                    for (int i = 0; i < m; i++) {
                        U[i][k] = 0.0;
                    }
                    U[k][k] = 1.0;
                }
            }
        }
        if (wantv) {
            for (int k = n - 1; k >= 0; k--) {
                if ((k < nrt) & (e[k] != 0.0)) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k + 1; i < n; i++) {
                            t += V[i][k] * V[i][j];
                        }
                        t = -t / V[k + 1][k];
                        for (int i = k + 1; i < n; i++) {
                            V[i][j] += t * V[i][k];
                        }
                    }
                }
                for (int i = 0; i < n; i++) {
                    V[i][k] = 0.0;
                }
                V[k][k] = 1.0;
            }
        }
        int pp = p - 1;
        int iter = 0;
        double eps = Math.pow(2.0, -52.0);
        double tiny = Math.pow(2.0, -966.0);
        while (p > 0) {
            int k, kase;
            for (k = p - 2; k >= -1; k--) {
                if (k == -1) {
                    break;
                }
                if (Math.abs(e[k]) <= tiny + eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
                    e[k] = 0.0;
                    break;
                }
            }
            if (k == p - 2) {
                kase = 4;
            } else {
                int ks;
                for (ks = p - 1; ks >= k; ks--) {
                    if (ks == k) {
                        break;
                    }
                    double t = (ks != p ? Math.abs(e[ks]) : 0.) + (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.);
                    if (Math.abs(s[ks]) <= tiny + eps * t) {
                        s[ks] = 0.0;
                        break;
                    }
                }
                if (ks == k) {
                    kase = 3;
                } else if (ks == p - 1) {
                    kase = 1;
                } else {
                    kase = 2;
                    k = ks;
                }
            }
            k++;
            switch(kase) {
                case 1:
                    {
                        double f = e[p - 2];
                        e[p - 2] = 0.0;
                        for (int j = p - 2; j >= k; j--) {
                            double t = Maths.hypot(s[j], f);
                            double cs = s[j] / t;
                            double sn = f / t;
                            s[j] = t;
                            if (j != k) {
                                f = -sn * e[j - 1];
                                e[j - 1] = cs * e[j - 1];
                            }
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    t = cs * V[i][j] + sn * V[i][p - 1];
                                    V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                                    V[i][j] = t;
                                }
                            }
                        }
                    }
                    break;
                case 2:
                    {
                        double f = e[k - 1];
                        e[k - 1] = 0.0;
                        for (int j = k; j < p; j++) {
                            double t = Maths.hypot(s[j], f);
                            double cs = s[j] / t;
                            double sn = f / t;
                            s[j] = t;
                            f = -sn * e[j];
                            e[j] = cs * e[j];
                            if (wantu) {
                                for (int i = 0; i < m; i++) {
                                    t = cs * U[i][j] + sn * U[i][k - 1];
                                    U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                                    U[i][j] = t;
                                }
                            }
                        }
                    }
                    break;
                case 3:
                    {
                        double scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));
                        double sp = s[p - 1] / scale;
                        double spm1 = s[p - 2] / scale;
                        double epm1 = e[p - 2] / scale;
                        double sk = s[k] / scale;
                        double ek = e[k] / scale;
                        double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                        double c = (sp * epm1) * (sp * epm1);
                        double shift = 0.0;
                        if ((b != 0.0) | (c != 0.0)) {
                            shift = Math.sqrt(b * b + c);
                            if (b < 0.0) {
                                shift = -shift;
                            }
                            shift = c / (b + shift);
                        }
                        double f = (sk + sp) * (sk - sp) + shift;
                        double g = sk * ek;
                        for (int j = k; j < p - 1; j++) {
                            double t = Maths.hypot(f, g);
                            double cs = f / t;
                            double sn = g / t;
                            if (j != k) {
                                e[j - 1] = t;
                            }
                            f = cs * s[j] + sn * e[j];
                            e[j] = cs * e[j] - sn * s[j];
                            g = sn * s[j + 1];
                            s[j + 1] = cs * s[j + 1];
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    t = cs * V[i][j] + sn * V[i][j + 1];
                                    V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                                    V[i][j] = t;
                                }
                            }
                            t = Maths.hypot(f, g);
                            cs = f / t;
                            sn = g / t;
                            s[j] = t;
                            f = cs * e[j] + sn * s[j + 1];
                            s[j + 1] = -sn * e[j] + cs * s[j + 1];
                            g = sn * e[j + 1];
                            e[j + 1] = cs * e[j + 1];
                            if (wantu && (j < m - 1)) {
                                for (int i = 0; i < m; i++) {
                                    t = cs * U[i][j] + sn * U[i][j + 1];
                                    U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                                    U[i][j] = t;
                                }
                            }
                        }
                        e[p - 2] = f;
                        iter = iter + 1;
                    }
                    break;
                case 4:
                    {
                        if (s[k] <= 0.0) {
                            s[k] = (s[k] < 0.0 ? -s[k] : 0.0);
                            if (wantv) {
                                for (int i = 0; i <= pp; i++) {
                                    V[i][k] = -V[i][k];
                                }
                            }
                        }
                        while (k < pp) {
                            if (s[k] >= s[k + 1]) {
                                break;
                            }
                            double t = s[k];
                            s[k] = s[k + 1];
                            s[k + 1] = t;
                            if (wantv && (k < n - 1)) {
                                for (int i = 0; i < n; i++) {
                                    t = V[i][k + 1];
                                    V[i][k + 1] = V[i][k];
                                    V[i][k] = t;
                                }
                            }
                            if (wantu && (k < m - 1)) {
                                for (int i = 0; i < m; i++) {
                                    t = U[i][k + 1];
                                    U[i][k + 1] = U[i][k];
                                    U[i][k] = t;
                                }
                            }
                            k++;
                        }
                        iter = 0;
                        p--;
                    }
                    break;
            }
        }
    }
"
10471,8359774,7,"    public static void bubbleSort(int[] a) {
        if (a == null) {
            throw new IllegalArgumentException(""Null-pointed array"");
        }
        int right = a.length - 1;
        int k = 0;
        while (right > 0) {
            k = 0;
            for (int i = 0; i <= right - 1; i++) {
                if (a[i] > a[i + 1]) {
                    k = i;
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
            right = k;
        }
    }
"
4684,4272289,7,"    public static int[] sortstring(int[] a1) {
        int temp;
        for (int j = 0; j < (a1.length * a1.length); j++) {
            for (int i = 0; i < a1.length - 1; i++) {
                if (a1[i] > a1[i + 1]) {
                    temp = a1[i];
                    a1[i] = a1[i + 1];
                    a1[i + 1] = temp;
                }
            }
        }
        return a1;
    }
"
247,15287811,7,"    public static int[] sort(int[] v) {
        int i;
        int l = v.length;
        int[] index = new int[l];
        for (i = 0; i < l; i++) index[i] = i;
        int tmp;
        boolean change = true;
        while (change) {
            change = false;
            for (i = 0; i < l - 1; i++) {
                if (v[index[i]] > v[index[i + 1]]) {
                    tmp = index[i];
                    index[i] = index[i + 1];
                    index[i + 1] = tmp;
                    change = true;
                }
            }
        }
        return index;
    }
"
7960,709510,7,"    static void sort(int[] a) {
        int i = 0;
        while (i < a.length - 1) {
            int j = 0;
            while (j < (a.length - i) - 1) {
                if (a[j] > a[j + 1]) {
                    int aux = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = aux;
                }
                j = j + 1;
            }
            i = i + 1;
        }
    }
"
3994,13295656,7,"    public static int[] BubbleSortDEC(int[] values) {
        boolean change = true;
        int aux;
        int[] indexes = new int[values.length];
        for (int i = 0; i < values.length; i++) {
            indexes[i] = i;
        }
        while (change) {
            change = false;
            for (int i = 0; i < values.length - 1; i++) {
                if (values[i] < values[i + 1]) {
                    aux = values[i];
                    values[i] = values[i + 1];
                    values[i + 1] = aux;
                    aux = indexes[i];
                    indexes[i] = indexes[i + 1];
                    indexes[i + 1] = aux;
                    change = true;
                }
            }
        }
        return (indexes);
    }
"
839,11939522,7,"    public static String[] bubbleSort(String[] unsortedString, boolean ascending) {
        if (unsortedString.length < 2) return unsortedString;
        String[] sortedString = new String[unsortedString.length];
        for (int i = 0; i < unsortedString.length; i++) {
            sortedString[i] = unsortedString[i];
        }
        if (ascending) {
            for (int i = 0; i < sortedString.length - 1; i++) {
                for (int j = 1; j < sortedString.length - 1 - i; j++) if (sortedString[j + 1].compareToIgnoreCase(sortedString[j]) < 0) {
                    String swap = sortedString[j];
                    sortedString[j] = sortedString[j + 1];
                    sortedString[j + 1] = swap;
                }
            }
        } else {
            for (int i = sortedString.length - 2; i >= 0; i--) {
                for (int j = sortedString.length - 2 - i; j >= 0; j--) if (sortedString[j + 1].compareToIgnoreCase(sortedString[j]) > 0) {
                    String swap = sortedString[j];
                    sortedString[j] = sortedString[j + 1];
                    sortedString[j + 1] = swap;
                }
            }
        }
        return sortedString;
    }
"
10502,6302678,7,"    public ISpieler[] sortiereSpielerRamsch(ISpieler[] spieler) {
        for (int i = 0; i < spieler.length; i++) {
            for (int j = 0; j < spieler.length - 1; j++) {
                if (werteAugen(spieler[j].getStiche()) > werteAugen(spieler[j + 1].getStiche())) {
                    ISpieler a = spieler[j];
                    spieler[j] = spieler[j + 1];
                    spieler[j + 1] = a;
                }
            }
        }
        return spieler;
    }
"
10548,285947,7,"    public void process(String dir) {
        String[] list = new File(dir).list();
        if (list == null) return;
        int n = list.length;
        long[] bubblesort = new long[list.length + 1];
        if (!statustext) {
            IJ.log(""Current Directory is: "" + dir);
            IJ.log("" "");
            IJ.log(""DICOM File Name / "" + prefix1 + "" / "" + prefix2 + "" / "" + prefix3 + "" / "" + pick);
            IJ.log("" "");
        }
        for (int i = 0; i < n; i++) {
            IJ.showStatus(i + ""/"" + n);
            File f = new File(dir + list[i]);
            if (!f.isDirectory()) {
                ImagePlus img = new Opener().openImage(dir, list[i]);
                if (img != null && img.getStackSize() == 1) {
                    if (!scoutengine(img)) return;
                    if (!statustext) {
                        IJ.log(list[i] + ""/"" + whichprefix1 + ""/"" + whichprefix2 + ""/"" + whichprefix3 + ""/"" + whichcase);
                    }
                    int lastDigit = whichcase.length() - 1;
                    while (lastDigit > 0) {
                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;
                    }
                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);
                    bubblesort[i] = Long.parseLong(whichcase);
                }
            }
        }
        if (statussorta || statussortd || statustext) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (statussorta) {
                        if (bubblesort[i] > bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    } else {
                        if (bubblesort[i] < bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    }
                }
            }
            IJ.log("" "");
            for (int i = 0; i < n; i++) {
                if (!statustext) {
                    IJ.log(list[i] + "" / "" + bubblesort[i]);
                } else {
                    IJ.log(dir + list[i]);
                }
            }
        }
        if (open_as_stack || only_images) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (bubblesort[i] > bubblesort[i + 1]) {
                        long temp = bubblesort[i];
                        tempp = list[i];
                        bubblesort[i] = bubblesort[i + 1];
                        list[i] = list[i + 1];
                        bubblesort[i + 1] = temp;
                        list[i + 1] = tempp;
                        sorted = false;
                    }
                }
            }
            if (only_images) {
                Opener o = new Opener();
                int counter = 0;
                IJ.log("" "");
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break; else {
                        ImagePlus imp = o.openImage(path);
                        counter++;
                        if (imp != null) {
                            IJ.log(counter + "" + "" + path);
                            imp.show();
                        } else IJ.log(counter + "" - "" + path);
                    }
                }
                return;
            }
            int width = 0, height = 0, type = 0;
            ImageStack stack = null;
            double min = Double.MAX_VALUE;
            double max = -Double.MAX_VALUE;
            int k = 0;
            try {
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break;
                    if (list[i].endsWith("".txt"")) continue;
                    ImagePlus imp = new Opener().openImage(path);
                    if (imp != null && stack == null) {
                        width = imp.getWidth();
                        height = imp.getHeight();
                        type = imp.getType();
                        ColorModel cm = imp.getProcessor().getColorModel();
                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);
                    }
                    if (stack != null) k = stack.getSize() + 1;
                    IJ.showStatus(k + ""/"" + n);
                    IJ.showProgress((double) k / n);
                    if (imp == null) IJ.log(list[i] + "": unable to open""); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + "": wrong dimensions""); else if (imp.getType() != type) IJ.log(list[i] + "": wrong type""); else {
                        ImageProcessor ip = imp.getProcessor();
                        if (grayscale) ip = ip.convertToByte(true);
                        if (halfSize) ip = ip.resize(width / 2, height / 2);
                        if (ip.getMin() < min) min = ip.getMin();
                        if (ip.getMax() > max) max = ip.getMax();
                        String label = imp.getTitle();
                        String info = (String) imp.getProperty(""Info"");
                        if (info != null) label += ""\n"" + info;
                        stack.addSlice(label, ip);
                    }
                    System.gc();
                }
            } catch (OutOfMemoryError e) {
                IJ.outOfMemory(""FolderOpener"");
                stack.trim();
            }
            if (stack != null && stack.getSize() > 0) {
                ImagePlus imp2 = new ImagePlus(""Stack"", stack);
                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);
                imp2.show();
            }
            IJ.showProgress(1.0);
        }
    }
"
5822,940862,7,"    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
"
10028,763710,7,"    public void bubbleSort(int[] arr) {
        boolean swapped = true;
        int j = 0;
        int tmp;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < arr.length - j; i++) {
                if (arr[i] > arr[i + 1]) {
                    tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                    swapped = true;
                }
            }
        }
    }
"
9718,9066291,7,"    void sortIds(int a[]) {
        ExecutionTimer t = new ExecutionTimer();
        t.start();
        for (int i = a.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                }
            }
        }
        t.end();
        TimerRecordFile timerFile = new TimerRecordFile(""sort"", ""BufferSorting"", ""sortIds"", t.duration());
    }
"
2459,281097,7,"    public static void sort(float norm_abst[]) {
        float temp;
        for (int i = 0; i < 7; i++) {
            for (int j = 0; j < 7; j++) {
                if (norm_abst[j] > norm_abst[j + 1]) {
                    temp = norm_abst[j];
                    norm_abst[j] = norm_abst[j + 1];
                    norm_abst[j + 1] = temp;
                }
            }
        }
        printFixed(norm_abst[0]);
        print("" "");
        printFixed(norm_abst[1]);
        print("" "");
        printFixed(norm_abst[2]);
        print("" "");
        printFixed(norm_abst[3]);
        print("" "");
        printFixed(norm_abst[4]);
        print("" "");
        printFixed(norm_abst[5]);
        print("" "");
        printFixed(norm_abst[6]);
        print("" "");
        printFixed(norm_abst[7]);
        print(""\n"");
    }
"
8483,115129,7,"    public static void bubbleSort(String[] a) {
        Collator myCollator = Collator.getInstance();
        boolean switched = true;
        for (int pass = 0; pass < a.length - 1 && switched; pass++) {
            switched = false;
            for (int i = 0; i < a.length - pass - 1; i++) {
                if (myCollator.compare(a[i], a[i + 1]) > 0) {
                    switched = true;
                    String temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
        }
    }
"
10217,1363,7,"    public static int[] bubbleSortOtimizado(int... a) {
        boolean swapped;
        int n = a.length - 2;
        do {
            swapped = false;
            for (int i = 0; i <= n; i++) {
                if (a[i] > a[i + 1]) {
                    int tmp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = tmp;
                    swapped = true;
                }
            }
            n = n - 1;
        } while (swapped);
        return a;
    }
"
5896,15609432,7,"    public static int[] bubbleSort(int[] source) {
        if (source != null && source.length > 0) {
            boolean flag = true;
            while (flag) {
                flag = false;
                for (int i = 0; i < source.length - 1; i++) {
                    if (source[i] > source[i + 1]) {
                        int temp = source[i];
                        source[i] = source[i + 1];
                        source[i + 1] = temp;
                        flag = true;
                    }
                }
            }
        }
        return source;
    }
"
1114,465616,7,"    public void bubbleSort(int[] arr) {
        BasicProcessor.getInstance().getStartBlock();
        BasicProcessor.getInstance().getVarDeclaration();
        boolean swapped = true;
        BasicProcessor.getInstance().getVarDeclaration();
        int j = 0;
        BasicProcessor.getInstance().getVarDeclaration();
        int tmp;
        {
            BasicProcessor.getInstance().getWhileStatement();
            while (swapped) {
                BasicProcessor.getInstance().getStartBlock();
                swapped = false;
                j++;
                {
                    BasicProcessor.getInstance().getForStatement();
                    for (int i = 0; i < arr.length - j; i++) {
                        BasicProcessor.getInstance().getStartBlock();
                        {
                            BasicProcessor.getInstance().getIfStatement();
                            if (arr[i] > arr[i + 1]) {
                                BasicProcessor.getInstance().getStartBlock();
                                tmp = arr[i];
                                arr[i] = arr[i + 1];
                                arr[i + 1] = tmp;
                                swapped = true;
                                BasicProcessor.getInstance().getEndBlock();
                            }
                        }
                        BasicProcessor.getInstance().getEndBlock();
                    }
                }
                BasicProcessor.getInstance().getEndBlock();
            }
        }
        BasicProcessor.getInstance().getEndBlock();
    }
"
2087,1362,7,"    public static int[] bubbleSort(int... a) {
        boolean swapped;
        do {
            swapped = false;
            for (int i = 0; i < a.length - 1; i++) {
                if (a[i] > a[i + 1]) {
                    int tmp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = tmp;
                    swapped = true;
                }
            }
        } while (swapped);
        return a;
    }
"
1399,726690,7,"    public void process(String dir) {
        String[] list = new File(dir).list();
        if (list == null) return;
        int n = list.length;
        long[] bubblesort = new long[list.length + 1];
        if (!statustext) {
            IJ.log(""Current Directory is: "" + dir);
            IJ.log("" "");
            IJ.log(""DICOM File Name / "" + prefix1 + "" / "" + prefix2 + "" / "" + prefix3 + "" / "" + pick);
            IJ.log("" "");
        }
        for (int i = 0; i < n; i++) {
            IJ.showStatus(i + ""/"" + n);
            File f = new File(dir + list[i]);
            if (!f.isDirectory()) {
                ImagePlus img = new Opener().openImage(dir, list[i]);
                if (img != null && img.getStackSize() == 1) {
                    if (!scoutengine(img)) return;
                    if (!statustext) {
                        IJ.log(list[i] + ""/"" + whichprefix1 + ""/"" + whichprefix2 + ""/"" + whichprefix3 + ""/"" + whichcase);
                    }
                    int lastDigit = whichcase.length() - 1;
                    while (lastDigit > 0) {
                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;
                    }
                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);
                    bubblesort[i] = Long.parseLong(whichcase);
                }
            }
        }
        if (statussorta || statussortd || statustext) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (statussorta) {
                        if (bubblesort[i] > bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    } else {
                        if (bubblesort[i] < bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    }
                }
            }
            IJ.log("" "");
            for (int i = 0; i < n; i++) {
                if (!statustext) {
                    IJ.log(list[i] + "" / "" + bubblesort[i]);
                } else {
                    IJ.log(dir + list[i]);
                }
            }
        }
        if (open_as_stack || only_images) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (bubblesort[i] > bubblesort[i + 1]) {
                        long temp = bubblesort[i];
                        tempp = list[i];
                        bubblesort[i] = bubblesort[i + 1];
                        list[i] = list[i + 1];
                        bubblesort[i + 1] = temp;
                        list[i + 1] = tempp;
                        sorted = false;
                    }
                }
            }
            if (only_images) {
                Opener o = new Opener();
                int counter = 0;
                IJ.log("" "");
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break; else {
                        ImagePlus imp = o.openImage(path);
                        counter++;
                        if (imp != null) {
                            IJ.log(counter + "" + "" + path);
                            imp.show();
                        } else IJ.log(counter + "" - "" + path);
                    }
                }
                return;
            }
            int width = 0, height = 0, type = 0;
            ImageStack stack = null;
            double min = Double.MAX_VALUE;
            double max = -Double.MAX_VALUE;
            int k = 0;
            try {
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break;
                    if (list[i].endsWith("".txt"")) continue;
                    ImagePlus imp = new Opener().openImage(path);
                    if (imp != null && stack == null) {
                        width = imp.getWidth();
                        height = imp.getHeight();
                        type = imp.getType();
                        ColorModel cm = imp.getProcessor().getColorModel();
                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);
                    }
                    if (stack != null) k = stack.getSize() + 1;
                    IJ.showStatus(k + ""/"" + n);
                    IJ.showProgress((double) k / n);
                    if (imp == null) IJ.log(list[i] + "": unable to open""); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + "": wrong dimensions""); else if (imp.getType() != type) IJ.log(list[i] + "": wrong type""); else {
                        ImageProcessor ip = imp.getProcessor();
                        if (grayscale) ip = ip.convertToByte(true);
                        if (halfSize) ip = ip.resize(width / 2, height / 2);
                        if (ip.getMin() < min) min = ip.getMin();
                        if (ip.getMax() > max) max = ip.getMax();
                        String label = imp.getTitle();
                        String info = (String) imp.getProperty(""Info"");
                        if (info != null) label += ""\n"" + info;
                        stack.addSlice(label, ip);
                    }
                    System.gc();
                }
            } catch (OutOfMemoryError e) {
                IJ.outOfMemory(""FolderOpener"");
                stack.trim();
            }
            if (stack != null && stack.getSize() > 0) {
                ImagePlus imp2 = new ImagePlus(""Stack"", stack);
                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);
                imp2.show();
            }
            IJ.showProgress(1.0);
        }
    }
"
12120,8227164,7,"    static int[] bubble(int[] s) {
        boolean f = true;
        while (f) {
            f = false;
            for (int i = 0; i < s.length - 1; i++) {
                if (s[i] > s[i + 1]) {
                    int t = s[i];
                    s[i] = s[i + 1];
                    s[i + 1] = t;
                    f = true;
                }
            }
        }
        return s;
    }
"
8744,6972162,7,"    public void removeDownload() {
        synchronized (mDownloadMgr) {
            int rowCount = mDownloadTable.getSelectedRowCount();
            if (rowCount <= 0) return;
            int[] rows = mDownloadTable.getSelectedRows();
            int[] orderedRows = new int[rows.length];
            Vector downloadFilesToRemove = new Vector();
            for (int i = 0; i < rowCount; i++) {
                int row = rows[i];
                if (row >= mDownloadMgr.getDownloadCount()) return;
                orderedRows[i] = mDownloadSorter.indexes[row];
            }
            mDownloadTable.removeRowSelectionInterval(0, mDownloadTable.getRowCount() - 1);
            for (int i = orderedRows.length - 1; i > 0; i--) {
                for (int j = 0; j < i; j++) {
                    if (orderedRows[j] > orderedRows[j + 1]) {
                        int tmp = orderedRows[j];
                        orderedRows[j] = orderedRows[j + 1];
                        orderedRows[j + 1] = tmp;
                    }
                }
            }
            for (int i = orderedRows.length - 1; i >= 0; i--) {
                mDownloadMgr.removeDownload(orderedRows[i]);
            }
            mainFrame.refreshAllActions();
        }
    }
"
3784,6920765,7,"    public static final void sequence(int[] list, int above) {
        int temp, max, min;
        boolean tag = true;
        for (int i = list.length - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                if (above < 0) {
                    if (list[j] < list[j + 1]) {
                        temp = list[j];
                        list[j] = list[j + 1];
                        list[j + 1] = temp;
                        tag = true;
                    }
                } else {
                    if (list[j] > list[j + 1]) {
                        temp = list[j];
                        list[j] = list[j + 1];
                        list[j + 1] = temp;
                        tag = true;
                    }
                }
            }
            if (tag == false) break;
        }
    }
"
2742,12747342,7,"    public void bubbleSort(final int[] s) {
        source = s;
        if (source.length < 2) return;
        boolean go = true;
        while (go) {
            go = false;
            for (int i = 0; i < source.length - 1; i++) {
                int temp = source[i];
                if (temp > source[i + 1]) {
                    source[i] = source[i + 1];
                    source[i + 1] = temp;
                    go = true;
                }
            }
        }
    }
"
1617,21779336,7,"    private void weightAndPlaceClasses() {
        int rows = getRows();
        for (int curRow = _maxPackageRank; curRow < rows; curRow++) {
            xPos = getHGap() / 2;
            ClassdiagramNode[] rowObject = getObjectsInRow(curRow);
            for (int i = 0; i < rowObject.length; i++) {
                if (curRow == _maxPackageRank) {
                    int nDownlinks = rowObject[i].getDownlinks().size();
                    rowObject[i].setWeight((nDownlinks > 0) ? (1 / nDownlinks) : 2);
                } else {
                    Vector uplinks = rowObject[i].getUplinks();
                    int nUplinks = uplinks.size();
                    if (nUplinks > 0) {
                        float average_col = 0;
                        for (int j = 0; j < uplinks.size(); j++) {
                            average_col += ((ClassdiagramNode) (uplinks.elementAt(j))).getColumn();
                        }
                        average_col /= nUplinks;
                        rowObject[i].setWeight(average_col);
                    } else {
                        rowObject[i].setWeight(1000);
                    }
                }
            }
            int[] pos = new int[rowObject.length];
            for (int i = 0; i < pos.length; i++) {
                pos[i] = i;
            }
            boolean swapped = true;
            while (swapped) {
                swapped = false;
                for (int i = 0; i < pos.length - 1; i++) {
                    if (rowObject[pos[i]].getWeight() > rowObject[pos[i + 1]].getWeight()) {
                        int temp = pos[i];
                        pos[i] = pos[i + 1];
                        pos[i + 1] = temp;
                        swapped = true;
                    }
                }
            }
            for (int i = 0; i < pos.length; i++) {
                rowObject[pos[i]].setColumn(i);
                if ((i > _vMax) && (rowObject[pos[i]].getUplinks().size() == 0) && (rowObject[pos[i]].getDownlinks().size() == 0)) {
                    if (getColumns(rows - 1) > _vMax) {
                        rows++;
                    }
                    rowObject[pos[i]].setRank(rows - 1);
                } else {
                    rowObject[pos[i]].setLocation(new Point(xPos, yPos));
                    xPos += rowObject[pos[i]].getSize().getWidth() + getHGap();
                }
            }
            yPos += getRowHeight(curRow) + getVGap();
        }
    }
"
8552,338852,7,"    public static void sort(float norm_abst[]) {
        float temp;
        for (int i = 0; i < 7; i++) {
            for (int j = 0; j < 7; j++) {
                if (norm_abst[j] > norm_abst[j + 1]) {
                    temp = norm_abst[j];
                    norm_abst[j] = norm_abst[j + 1];
                    norm_abst[j + 1] = temp;
                }
            }
        }
        printFixed(norm_abst[0]);
        print("" "");
        printFixed(norm_abst[1]);
        print("" "");
        printFixed(norm_abst[2]);
        print("" "");
        printFixed(norm_abst[3]);
        print("" "");
        printFixed(norm_abst[4]);
        print("" "");
        printFixed(norm_abst[5]);
        print("" "");
        printFixed(norm_abst[6]);
        print("" "");
        printFixed(norm_abst[7]);
        print(""\n"");
    }
"
12491,8054454,7,"    public void sortIndexes() {
        int i, j, count;
        int t;
        count = m_ItemIndexes.length;
        for (i = 1; i < count; i++) {
            for (j = 0; j < count - i; j++) {
                if (m_ItemIndexes[j] > m_ItemIndexes[j + 1]) {
                    t = m_ItemIndexes[j];
                    m_ItemIndexes[j] = m_ItemIndexes[j + 1];
                    m_ItemIndexes[j + 1] = t;
                }
            }
        }
    }
"
10063,245162,7,"    static void sort(int[] a) {
        int i = 0;
        while (i < a.length - 1) {
            int j = 0;
            while (j < (a.length - i) - 1) {
                if (a[j] > a[j + 1]) {
                    int aux = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = aux;
                }
                j = j + 1;
            }
            i = i + 1;
        }
    }
"
5858,15609433,7,"    public static int[] bubbleSort2(int[] source) {
        if (null != source && source.length > 0) {
            boolean flag = false;
            while (!flag) {
                for (int i = 0; i < source.length - 1; i++) {
                    if (source[i] > source[i + 1]) {
                        int temp = source[i];
                        source[i] = source[i + 1];
                        source[i + 1] = temp;
                        break;
                    } else if (i == source.length - 2) {
                        flag = true;
                    }
                }
            }
        }
        return source;
    }
"
6746,891550,7,"    public void bubblesort(String filenames[]) {
        for (int i = filenames.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                String temp;
                if (filenames[j].compareTo(filenames[j + 1]) > 0) {
                    temp = filenames[j];
                    filenames[j] = filenames[j + 1];
                    filenames[j + 1] = temp;
                }
            }
        }
    }
"
11193,21273059,7,"    public RobotList<Location> sort_incr_Location(RobotList<Location> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        Location cur_loc = this.getLocation();
        for (int i = 0; i < length; i++) {
            enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i)));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value > enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Location> new_location_list = new RobotList<Location>(Location.class);
        for (int i = 0; i < length; i++) {
            new_location_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_location_list;
    }
"
5071,416857,7,"    public void process(String dir) {
        String[] list = new File(dir).list();
        if (list == null) return;
        int n = list.length;
        long[] bubblesort = new long[list.length + 1];
        if (!statustext) {
            IJ.log(""Current Directory is: "" + dir);
            IJ.log("" "");
            IJ.log(""DICOM File Name / "" + prefix1 + "" / "" + prefix2 + "" / "" + prefix3 + "" / "" + pick);
            IJ.log("" "");
        }
        for (int i = 0; i < n; i++) {
            IJ.showStatus(i + ""/"" + n);
            File f = new File(dir + list[i]);
            if (!f.isDirectory()) {
                ImagePlus img = new Opener().openImage(dir, list[i]);
                if (img != null && img.getStackSize() == 1) {
                    if (!scoutengine(img)) return;
                    if (!statustext) {
                        IJ.log(list[i] + ""/"" + whichprefix1 + ""/"" + whichprefix2 + ""/"" + whichprefix3 + ""/"" + whichcase);
                    }
                    int lastDigit = whichcase.length() - 1;
                    while (lastDigit > 0) {
                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;
                    }
                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);
                    bubblesort[i] = Long.parseLong(whichcase);
                }
            }
        }
        if (statussorta || statussortd || statustext) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (statussorta) {
                        if (bubblesort[i] > bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    } else {
                        if (bubblesort[i] < bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    }
                }
            }
            IJ.log("" "");
            for (int i = 0; i < n; i++) {
                if (!statustext) {
                    IJ.log(list[i] + "" / "" + bubblesort[i]);
                } else {
                    IJ.log(dir + list[i]);
                }
            }
        }
        if (open_as_stack || only_images) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (bubblesort[i] > bubblesort[i + 1]) {
                        long temp = bubblesort[i];
                        tempp = list[i];
                        bubblesort[i] = bubblesort[i + 1];
                        list[i] = list[i + 1];
                        bubblesort[i + 1] = temp;
                        list[i + 1] = tempp;
                        sorted = false;
                    }
                }
            }
            if (only_images) {
                Opener o = new Opener();
                int counter = 0;
                IJ.log("" "");
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break; else {
                        ImagePlus imp = o.openImage(path);
                        counter++;
                        if (imp != null) {
                            IJ.log(counter + "" + "" + path);
                            imp.show();
                        } else IJ.log(counter + "" - "" + path);
                    }
                }
                return;
            }
            int width = 0, height = 0, type = 0;
            ImageStack stack = null;
            double min = Double.MAX_VALUE;
            double max = -Double.MAX_VALUE;
            int k = 0;
            try {
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break;
                    if (list[i].endsWith("".txt"")) continue;
                    ImagePlus imp = new Opener().openImage(path);
                    if (imp != null && stack == null) {
                        width = imp.getWidth();
                        height = imp.getHeight();
                        type = imp.getType();
                        ColorModel cm = imp.getProcessor().getColorModel();
                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);
                    }
                    if (stack != null) k = stack.getSize() + 1;
                    IJ.showStatus(k + ""/"" + n);
                    IJ.showProgress((double) k / n);
                    if (imp == null) IJ.log(list[i] + "": unable to open""); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + "": wrong dimensions""); else if (imp.getType() != type) IJ.log(list[i] + "": wrong type""); else {
                        ImageProcessor ip = imp.getProcessor();
                        if (grayscale) ip = ip.convertToByte(true);
                        if (halfSize) ip = ip.resize(width / 2, height / 2);
                        if (ip.getMin() < min) min = ip.getMin();
                        if (ip.getMax() > max) max = ip.getMax();
                        String label = imp.getTitle();
                        String info = (String) imp.getProperty(""Info"");
                        if (info != null) label += ""\n"" + info;
                        stack.addSlice(label, ip);
                    }
                    System.gc();
                }
            } catch (OutOfMemoryError e) {
                IJ.outOfMemory(""FolderOpener"");
                stack.trim();
            }
            if (stack != null && stack.getSize() > 0) {
                ImagePlus imp2 = new ImagePlus(""Stack"", stack);
                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);
                imp2.show();
            }
            IJ.showProgress(1.0);
        }
    }
"
9619,81754,7,"    public void Sort(int a[]) {
        for (int i = a.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
"
5183,477320,7,"    private final void reOrderFriendsListByOnlineStatus() {
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int i = 0; i < friendsCount - 1; i++) if (friendsListOnlineStatus[i] < friendsListOnlineStatus[i + 1]) {
                int j = friendsListOnlineStatus[i];
                friendsListOnlineStatus[i] = friendsListOnlineStatus[i + 1];
                friendsListOnlineStatus[i + 1] = j;
                long l = friendsListLongs[i];
                friendsListLongs[i] = friendsListLongs[i + 1];
                friendsListLongs[i + 1] = l;
                flag = true;
            }
        }
    }
"
7205,6480424,7,"    public void method31() {
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int i = 0; i < anInt772 - 1; i++) if (anIntArray774[i] < anIntArray774[i + 1]) {
                int j = anIntArray774[i];
                anIntArray774[i] = anIntArray774[i + 1];
                anIntArray774[i + 1] = j;
                long l = aLongArray773[i];
                aLongArray773[i] = aLongArray773[i + 1];
                aLongArray773[i + 1] = l;
                flag = true;
            }
        }
    }
"
8279,793386,7,"    public void bubbleSort(int[] arr) {
        BasicProcessor.getInstance().getStartBlock();
        BasicProcessor.getInstance().getVarDeclaration();
        boolean swapped = true;
        BasicProcessor.getInstance().getVarDeclaration();
        int j = 0;
        BasicProcessor.getInstance().getVarDeclaration();
        int tmp;
        {
            BasicProcessor.getInstance().getWhileStatement();
            while (swapped) {
                BasicProcessor.getInstance().getStartBlock();
                swapped = false;
                j++;
                {
                    BasicProcessor.getInstance().getForStatement();
                    for (int i = 0; i < arr.length - j; i++) {
                        BasicProcessor.getInstance().getStartBlock();
                        {
                            BasicProcessor.getInstance().getIfStatement();
                            if (arr[i] > arr[i + 1]) {
                                BasicProcessor.getInstance().getStartBlock();
                                tmp = arr[i];
                                arr[i] = arr[i + 1];
                                arr[i + 1] = tmp;
                                swapped = true;
                                BasicProcessor.getInstance().getEndBlock();
                            }
                        }
                        BasicProcessor.getInstance().getEndBlock();
                    }
                }
                BasicProcessor.getInstance().getEndBlock();
            }
        }
        BasicProcessor.getInstance().getEndBlock();
    }
"
538,521113,7,"    int[] slowSort() {
        int[] values = getValues();
        int n = values.length;
        for (int pass = 1; pass < n; pass++) {
            for (int i = 0; i < n - pass; i++) {
                if (values[i] > values[i + 1]) {
                    int temp = values[i];
                    values[i] = values[i + 1];
                    values[i + 1] = temp;
                }
            }
        }
        return values;
    }
"
2144,7635628,7,"    private void bubbleSort(int values[]) {
        int len = values.length - 1;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len - i; j++) {
                if (values[j] > values[j + 1]) {
                    int tmp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = tmp;
                }
            }
        }
    }
"
12072,751537,7,"    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
"
1421,151792,7,"    public void bubblesort(String filenames[]) {
        for (int i = filenames.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                String temp;
                if (filenames[j].compareTo(filenames[j + 1]) > 0) {
                    temp = filenames[j];
                    filenames[j] = filenames[j + 1];
                    filenames[j + 1] = temp;
                }
            }
        }
    }
"
5844,12646326,7,"    private void weightAndPlaceClasses() {
        int rows = getRows();
        for (int curRow = _maxPackageRank; curRow < rows; curRow++) {
            xPos = getHGap() / 2;
            BOTLRuleDiagramNode[] rowObject = getObjectsInRow(curRow);
            for (int i = 0; i < rowObject.length; i++) {
                if (curRow == _maxPackageRank) {
                    int nDownlinks = rowObject[i].getDownlinks().size();
                    rowObject[i].setWeight((nDownlinks > 0) ? (1 / nDownlinks) : 2);
                } else {
                    Vector uplinks = rowObject[i].getUplinks();
                    int nUplinks = uplinks.size();
                    if (nUplinks > 0) {
                        float average_col = 0;
                        for (int j = 0; j < uplinks.size(); j++) {
                            average_col += ((BOTLRuleDiagramNode) (uplinks.elementAt(j))).getColumn();
                        }
                        average_col /= nUplinks;
                        rowObject[i].setWeight(average_col);
                    } else {
                        rowObject[i].setWeight(1000);
                    }
                }
            }
            int[] pos = new int[rowObject.length];
            for (int i = 0; i < pos.length; i++) {
                pos[i] = i;
            }
            boolean swapped = true;
            while (swapped) {
                swapped = false;
                for (int i = 0; i < pos.length - 1; i++) {
                    if (rowObject[pos[i]].getWeight() > rowObject[pos[i + 1]].getWeight()) {
                        int temp = pos[i];
                        pos[i] = pos[i + 1];
                        pos[i + 1] = temp;
                        swapped = true;
                    }
                }
            }
            for (int i = 0; i < pos.length; i++) {
                rowObject[pos[i]].setColumn(i);
                if ((i > _vMax) && (rowObject[pos[i]].getUplinks().size() == 0) && (rowObject[pos[i]].getDownlinks().size() == 0)) {
                    if (getColumns(rows - 1) > _vMax) {
                        rows++;
                    }
                    rowObject[pos[i]].setRank(rows - 1);
                } else {
                    rowObject[pos[i]].setLocation(new Point(xPos, yPos));
                    xPos += rowObject[pos[i]].getSize().getWidth() + getHGap();
                }
            }
            yPos += getRowHeight(curRow) + getVGap();
        }
    }
"
2608,120983,7,"    void sort(int a[]) throws Exception {
        for (int i = a.length; --i >= 0; ) {
            boolean flipped = false;
            for (int j = 0; j < i; j++) {
                if (stopRequested) {
                    return;
                }
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                    flipped = true;
                }
                pause(i, j);
            }
            if (!flipped) {
                return;
            }
        }
    }
"
11014,16123665,7,"    public static void bubbleSort(Drawable[] list) {
        boolean swapped;
        do {
            swapped = false;
            for (int i = 0; i < list.length - 1; ++i) {
                if (list[i].getSortValue() > list[i + 1].getSortValue()) {
                    Drawable temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                    swapped = true;
                }
            }
        } while (swapped);
    }
"
10316,878123,7,"    void sort(int a[]) throws Exception {
        int j;
        int limit = a.length;
        int st = -1;
        while (st < limit) {
            boolean flipped = false;
            st++;
            limit--;
            for (j = st; j < limit; j++) {
                if (stopRequested) {
                    return;
                }
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                    flipped = true;
                    pause(st, limit);
                }
            }
            if (!flipped) {
                return;
            }
            for (j = limit; --j >= st; ) {
                if (stopRequested) {
                    return;
                }
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                    flipped = true;
                    pause(st, limit);
                }
            }
            if (!flipped) {
                return;
            }
        }
        pause(st, limit);
    }
"
1328,14632238,7,"    public static void bubble(double[] a) {
        for (int i = a.length - 1; i > 0; i--) for (int j = 0; j < i; j++) if (a[j] > a[j + 1]) {
            double temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
        }
    }
"
1208,481375,7,"    public void bubbleSort(int[] arr) {
        boolean swapped = true;
        int j = 0;
        int tmp;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < arr.length - j; i++) {
                if (arr[i] > arr[i + 1]) {
                    tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                    swapped = true;
                }
            }
        }
    }
"
3613,10606028,7,"    public void bubble() {
        boolean test = false;
        int kars = 0, tas = 0;
        while (true) {
            for (int j = 0; j < dizi.length - 1; j++) {
                kars++;
                if (dizi[j] > dizi[j + 1]) {
                    int temp = dizi[j];
                    dizi[j] = dizi[j + 1];
                    dizi[j + 1] = temp;
                    test = true;
                    tas++;
                }
            }
            if (!test) {
                break;
            } else {
                test = false;
            }
        }
        System.out.print(kars + "" "" + tas);
    }
"
1022,22888751,7,"    public static float medianElement(float[] array, int size) {
        float[] tmpArray = new float[size];
        System.arraycopy(array, 0, tmpArray, 0, size);
        boolean changed = true;
        while (changed) {
            changed = false;
            for (int i = 0; i < size - 1; i++) {
                if (tmpArray[i] > tmpArray[i + 1]) {
                    changed = true;
                    float tmp = tmpArray[i];
                    tmpArray[i] = tmpArray[i + 1];
                    tmpArray[i + 1] = tmp;
                }
            }
        }
        return tmpArray[size / 2];
    }
"
8821,11374801,7,"    public void init(VerwaltungClient verClient) {
        this.setLayout(new BorderLayout());
        pnl1 = new JPanel();
        pnl1.setLayout(new FlowLayout());
        pnl1.add(new JLabel(Localization.getInstance().getString(""GameOver"")));
        pnl1.setBounds(10, 10, 200, 10);
        pnl2 = new JPanel();
        int a_punkte[];
        int punkte = 0;
        String name;
        String[] a_namen;
        a_punkte = verClient.getA_spielEndpunkte();
        a_namen = verClient.getA_Spielernamen();
        zeilen = new Object[a_punkte.length][2];
        for (int i = 0; i < a_punkte.length; i++) {
            for (int j = 0; j < a_punkte.length - 1 - i; j++) {
                if (a_punkte[j] < a_punkte[j + 1]) {
                    punkte = a_punkte[j];
                    a_punkte[j] = a_punkte[j + 1];
                    a_punkte[j + 1] = punkte;
                    name = a_namen[j];
                    a_namen[j] = a_namen[j + 1];
                    a_namen[j + 1] = name;
                }
            }
        }
        for (int i = 0; i < a_punkte.length; i++) {
            zeilen[i][0] = a_namen[i];
            zeilen[i][1] = new String("""" + a_punkte[i]);
        }
        tabelle = new JTable(zeilen, spalten);
        tabelle.setEnabled(false);
        pane = new JScrollPane(tabelle);
        pnl2.add(pane);
        pnl3 = new JPanel();
        JButton btn = new JButton(Localization.getInstance().getString(""OK""));
        btn.addActionListener(this);
        pnl3.add(btn);
        this.add(BorderLayout.CENTER, pnl2);
        this.add(BorderLayout.NORTH, pnl1);
        this.add(BorderLayout.SOUTH, pnl3);
        this.pack();
        this.setResizable(false);
        this.setVisible(true);
    }
"
2919,15069644,7,"    public String elementsSearch() {
        int index = 0;
        for (int i1 = 0; i1 < 6; i1++) {
            for (int i2 = 0; i2 < 5; i2++) {
                if (index < 5) {
                    if (initialMatrix[i1][i2] > 0) {
                        finalMatrix[index] = initialMatrix[i1][i2];
                        index++;
                    }
                } else break;
            }
        }
        int temp;
        for (int i = 0; i < finalMatrix.length; i++) {
            for (int j = 0; j < finalMatrix.length - 1; j++) {
                if (finalMatrix[j] < finalMatrix[j + 1]) {
                    temp = finalMatrix[j];
                    finalMatrix[j] = finalMatrix[j + 1];
                    finalMatrix[j + 1] = temp;
                }
            }
        }
        String result = """";
        for (int k : finalMatrix) result += k + "" "";
        return result;
    }
"
1692,8359775,7,"    public static void shakeSort(int[] a) {
        if (a == null) {
            throw new IllegalArgumentException(""Null-pointed array"");
        }
        int k = 0;
        int left = 0;
        int right = a.length - 1;
        while (right - left > 0) {
            k = 0;
            for (int i = 0; i <= right - 1; i++) {
                if (a[i] > a[i + 1]) {
                    k = i;
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
            right = k;
            k = a.length - 1;
            for (int i = left; i <= right - 1; i++) {
                if (a[i] > a[i + 1]) {
                    k = i;
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
            left = k;
        }
    }
"
9878,691789,7,"    public void bubbleSort(int[] arr) {
        BasicProcessor.getInstance().getStartBlock();
        BasicProcessor.getInstance().getVarDeclaration();
        boolean swapped = true;
        BasicProcessor.getInstance().getVarDeclaration();
        int j = 0;
        BasicProcessor.getInstance().getVarDeclaration();
        int tmp;
        {
            BasicProcessor.getInstance().getWhileStatement();
            while (swapped) {
                BasicProcessor.getInstance().getStartBlock();
                swapped = false;
                j++;
                {
                    BasicProcessor.getInstance().getForStatement();
                    for (int i = 0; i < arr.length - j; i++) {
                        BasicProcessor.getInstance().getStartBlock();
                        {
                            BasicProcessor.getInstance().getIfStatement();
                            if (arr[i] > arr[i + 1]) {
                                BasicProcessor.getInstance().getStartBlock();
                                tmp = arr[i];
                                arr[i] = arr[i + 1];
                                arr[i + 1] = tmp;
                                swapped = true;
                                BasicProcessor.getInstance().getEndBlock();
                            }
                        }
                        BasicProcessor.getInstance().getEndBlock();
                    }
                }
                BasicProcessor.getInstance().getEndBlock();
            }
        }
        BasicProcessor.getInstance().getEndBlock();
    }
"
5532,5127007,7,"    public static void bubbleSort(int[] a) {
        for (int i = a.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    int tmp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = tmp;
                }
            }
        }
    }
"
1261,21273056,7,"    public RobotList<Resource> sort_decr_Resource(RobotList<Resource> list, String field) {
        int length = list.size();
        Index_value[] resource_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals(""energy"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).energy);
            }
        } else if (field.equals(""ammostash"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).ammostash);
            }
        } else if (field.equals(""speed"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).speed);
            }
        } else if (field.equals(""health"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (resource_dist[i].value < resource_dist[i + 1].value) {
                    Index_value a = resource_dist[i];
                    resource_dist[i] = resource_dist[i + 1];
                    resource_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Resource> new_resource_list = new RobotList<Resource>(Resource.class);
        for (int i = 0; i < length; i++) {
            new_resource_list.addLast(list.get(resource_dist[i].index));
        }
        return new_resource_list;
    }
"
12202,17630908,7,"    public static int[] sortDescending(float input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] < input[j + 1]) {
                    float mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
"
11154,20181656,7,"    private int[] sortRows(int[] rows) {
        for (int i = 0; i < rows.length; i++) {
            for (int j = 0; j < rows.length - 1; j++) {
                if (rows[j] > rows[j + 1]) {
                    int temp = rows[j];
                    rows[j] = rows[j + 1];
                    rows[j + 1] = temp;
                }
            }
        }
        return rows;
    }
"
6058,845085,7,"    static void sort(int[] a) {
        int i = 0;
        while (i < a.length - 1) {
            int j = 0;
            while (j < (a.length - i) - 1) {
                if (a[j] > a[j + 1]) {
                    int aux = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = aux;
                }
                j = j + 1;
            }
            i = i + 1;
        }
    }
"
11955,11318551,7,"    public static int best(int r, int n, int s) {
        if ((n <= 0) || (r < 0) || (r > n) || (s < 0)) return 0;
        int[] rolls = new int[n];
        for (int i = 0; i < n; i++) rolls[i] = d(s);
        boolean found;
        do {
            found = false;
            for (int x = 0; x < n - 1; x++) {
                if (rolls[x] < rolls[x + 1]) {
                    int t = rolls[x];
                    rolls[x] = rolls[x + 1];
                    rolls[x + 1] = t;
                    found = true;
                }
            }
        } while (found);
        int sum = 0;
        for (int i = 0; i < r; i++) sum += rolls[i];
        return sum;
    }
"
9103,3198237,7," *
 * @version		1.0
 * @author		Alan Willamson (alan@n-ary.com)
 * @since		JDK1.1.4
 */
public class sort extends java.lang.Object {

    private static String Cal[] = { ""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December"" };

    /**
     * <P>
     * Sorts an array of Strings into asending order
     * <P>
     * @param _data         The array that is to be sorted.
     *
     */
"
9272,880670,7,"    public static void main(String args[]) {
        int i, j, l;
        short NUMNUMBERS = 256;
        short numbers[] = new short[NUMNUMBERS];
        Darjeeling.print(""START"");
        for (l = 0; l < 100; l++) {
            for (i = 0; i < NUMNUMBERS; i++) numbers[i] = (short) (NUMNUMBERS - 1 - i);
            for (i = 0; i < NUMNUMBERS; i++) {
                for (j = 0; j < NUMNUMBERS - i - 1; j++) if (numbers[j] > numbers[j + 1]) {
                    short temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
        }
        Darjeeling.print(""END"");
    }
"
2316,15822137,7,"    public TableDirectory(RandomAccessFile raf) throws IOException {
        version = raf.readInt();
        numTables = raf.readShort();
        searchRange = raf.readShort();
        entrySelector = raf.readShort();
        rangeShift = raf.readShort();
        entries = new DirectoryEntry[numTables];
        for (int i = 0; i < numTables; i++) {
            entries[i] = new DirectoryEntry(raf);
        }
        boolean modified = true;
        while (modified) {
            modified = false;
            for (int i = 0; i < numTables - 1; i++) {
                if (entries[i].getOffset() > entries[i + 1].getOffset()) {
                    DirectoryEntry temp = entries[i];
                    entries[i] = entries[i + 1];
                    entries[i + 1] = temp;
                    modified = true;
                }
            }
        }
    }
"
9480,14132423,7,"    public static void bubble_sort(int[] objects, int len) {
        for (int i = len; --i >= 0; ) {
            boolean flipped = false;
            for (int j = 0; j < i; j++) {
                if (objects[j + 1] < objects[j]) {
                    int tmp = objects[j];
                    objects[j] = objects[j + 1];
                    objects[j + 1] = tmp;
                    flipped = true;
                }
            }
            if (!flipped) return;
        }
    }
"
12324,18640710,7,"    private void sortWhats(String[] labels, int[] whats, String simplifyString) {
        int n = whats.length;
        boolean swapped;
        do {
            swapped = false;
            for (int i = 0; i < n - 1; i++) {
                int i0_pos = simplifyString.indexOf(labels[whats[i]]);
                int i1_pos = simplifyString.indexOf(labels[whats[i + 1]]);
                if (i0_pos > i1_pos) {
                    int temp = whats[i];
                    whats[i] = whats[i + 1];
                    whats[i + 1] = temp;
                    swapped = true;
                }
            }
        } while (swapped);
    }
"
3422,17583193,7,"    public boolean populateRecord(int[] attrIDs) throws IOException {
        if (device == null) {
            throw new RuntimeException(""This is local device service record"");
        }
        if (attrIDs == null) {
            throw new NullPointerException(""attrIDs is null"");
        }
        if (attrIDs.length == 0) {
            throw new IllegalArgumentException();
        }
        for (int i = 0; i < attrIDs.length; i++) {
            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {
                throw new IllegalArgumentException();
            }
        }
        int[] sortIDs = new int[attrIDs.length];
        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);
        for (int i = 0; i < sortIDs.length; i++) {
            for (int j = 0; j < sortIDs.length - i - 1; j++) {
                if (sortIDs[j] > sortIDs[j + 1]) {
                    int temp = sortIDs[j];
                    sortIDs[j] = sortIDs[j + 1];
                    sortIDs[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < sortIDs.length - 1; i++) {
            if (sortIDs[i] == sortIDs[i + 1]) {
                throw new IllegalArgumentException();
            }
            DebugLog.debug0x(""query for "", sortIDs[i]);
        }
        DebugLog.debug0x(""query for "", sortIDs[sortIDs.length - 1]);
        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);
    }
"
7937,17985016,7,"    public void setRandom(boolean random) {
        this.random = random;
        if (random) {
            possibleScores = new int[NUM_SCORES];
            for (int i = 0; i < NUM_SCORES - 1; i++) {
                getRandomScore: while (true) {
                    int score = (int) (Math.random() * 20) + 1;
                    for (int j = 0; j < i; j++) {
                        if (score == possibleScores[j]) {
                            continue getRandomScore;
                        }
                    }
                    possibleScores[i] = score;
                    break;
                }
            }
            possibleScores[NUM_SCORES - 1] = 25;
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < NUM_SCORES - 1; i++) {
                    if (possibleScores[i] > possibleScores[i + 1]) {
                        int t = possibleScores[i];
                        possibleScores[i] = possibleScores[i + 1];
                        possibleScores[i + 1] = t;
                        sorted = false;
                    }
                }
            }
            setPossibleScores(possibleScores);
        }
    }
"
4147,5682569,7,"    public void metodo1() {
        int temp;
        boolean flagDesordenado = true;
        while (flagDesordenado) {
            flagDesordenado = false;
            for (int i = 0; i < this.tamanoTabla - 1; i++) {
                if (tabla[i] > tabla[i + 1]) {
                    flagDesordenado = true;
                    temp = tabla[i];
                    tabla[i] = tabla[i + 1];
                    tabla[i + 1] = temp;
                }
            }
        }
    }
"
1964,200484,7,"    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
"
518,2086683,7,"    private PieceSet[] getPieceSets() {
        Resource[] resources = boardManager.getResources(""pieces"");
        PieceSet[] pieceSets = new PieceSet[resources.length];
        for (int i = 0; i < resources.length; i++) pieceSets[i] = (PieceSet) resources[i];
        for (int i = 0; i < resources.length; i++) {
            for (int j = 0; j < resources.length - (i + 1); j++) {
                String name1 = pieceSets[j].getName();
                String name2 = pieceSets[j + 1].getName();
                if (name1.compareTo(name2) > 0) {
                    PieceSet tmp = pieceSets[j];
                    pieceSets[j] = pieceSets[j + 1];
                    pieceSets[j + 1] = tmp;
                }
            }
        }
        return pieceSets;
    }
"
11388,2086684,7,"    private BoardPattern[] getBoardPatterns() {
        Resource[] resources = boardManager.getResources(""boards"");
        BoardPattern[] boardPatterns = new BoardPattern[resources.length];
        for (int i = 0; i < resources.length; i++) boardPatterns[i] = (BoardPattern) resources[i];
        for (int i = 0; i < resources.length; i++) {
            for (int j = 0; j < resources.length - (i + 1); j++) {
                String name1 = boardPatterns[j].getName();
                String name2 = boardPatterns[j + 1].getName();
                if (name1.compareTo(name2) > 0) {
                    BoardPattern tmp = boardPatterns[j];
                    boardPatterns[j] = boardPatterns[j + 1];
                    boardPatterns[j + 1] = tmp;
                }
            }
        }
        return boardPatterns;
    }
"
5834,8786313,7,"    @DeclarePerfMonTimer(""SortingTest.bubbleSort"")
    private void bubbleSort(int values[]) {
        int len = values.length - 1;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len - i; j++) {
                if (values[j] > values[j + 1]) {
                    int tmp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = tmp;
                }
            }
        }
    }
"
8784,16375558,7,"    private void sort() {
        for (int i = 0; i < density.length; i++) {
            for (int j = density.length - 2; j >= i; j--) {
                if (density[j] > density[j + 1]) {
                    KDNode n = nonEmptyNodesArray[j];
                    nonEmptyNodesArray[j] = nonEmptyNodesArray[j + 1];
                    nonEmptyNodesArray[j + 1] = n;
                    double d = density[j];
                    density[j] = density[j + 1];
                    density[j + 1] = d;
                }
            }
        }
    }
"
10448,12065181,7,"    private void sortMasters() {
        masterCounter = 0;
        for (int i = 0; i < maxID; i++) {
            if (users[i].getMasterPoints() > 0) {
                masterHandleList[masterCounter] = users[i].getHandle();
                masterPointsList[masterCounter] = users[i].getMasterPoints();
                masterCounter = masterCounter + 1;
            }
        }
        for (int i = masterCounter; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (masterPointsList[j] > masterPointsList[j + 1]) {
                    int tempp = masterPointsList[j];
                    String temppstring = masterHandleList[j];
                    masterPointsList[j] = masterPointsList[j + 1];
                    masterHandleList[j] = masterHandleList[j + 1];
                    masterPointsList[j + 1] = tempp;
                    masterHandleList[j + 1] = temppstring;
                }
            }
        }
    }
"
6290,4449697,7,"    private int[] sortNodesToGoal(Graph g, int parent, int goal) {
        float a, b;
        int tempI, tempR;
        float tempF;
        int len = g.nodeList[parent].edges.length;
        int[] nodes = new int[len];
        float[] dists = new float[len];
        int[] ref = new int[len];
        if (len == 0) return null;
        if (len == 1) {
            ref[0] = 0;
            return ref;
        }
        for (int i = 0; i < len; i++) {
            nodes[i] = g.getOtherNode(parent, g.nodeList[parent].edges[i]);
            a = g.nodeList[nodes[i]].x - g.nodeList[goal].x;
            b = g.nodeList[nodes[i]].y - g.nodeList[goal].y;
            dists[i] = (float) Math.sqrt(a * a + b * b);
            ref[i] = i;
        }
        for (int i = len - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                if (dists[j] > dists[j + 1]) {
                    tempI = nodes[j];
                    nodes[j] = nodes[j + 1];
                    nodes[j + 1] = tempI;
                    tempF = dists[j];
                    dists[j] = dists[j + 1];
                    dists[j + 1] = tempF;
                    tempR = ref[j];
                    ref[j] = ref[j + 1];
                    ref[j + 1] = tempR;
                }
            }
        }
        return ref;
    }
"
7107,2450,7,"    public void process(String dir) {
        String[] list = new File(dir).list();
        if (list == null) return;
        int n = list.length;
        long[] bubblesort = new long[list.length + 1];
        if (!statustext) {
            IJ.log(""Current Directory is: "" + dir);
            IJ.log("" "");
            IJ.log(""DICOM File Name / "" + prefix1 + "" / "" + prefix2 + "" / "" + prefix3 + "" / "" + pick);
            IJ.log("" "");
        }
        for (int i = 0; i < n; i++) {
            IJ.showStatus(i + ""/"" + n);
            File f = new File(dir + list[i]);
            if (!f.isDirectory()) {
                ImagePlus img = new Opener().openImage(dir, list[i]);
                if (img != null && img.getStackSize() == 1) {
                    if (!scoutengine(img)) return;
                    if (!statustext) {
                        IJ.log(list[i] + ""/"" + whichprefix1 + ""/"" + whichprefix2 + ""/"" + whichprefix3 + ""/"" + whichcase);
                    }
                    int lastDigit = whichcase.length() - 1;
                    while (lastDigit > 0) {
                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;
                    }
                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);
                    bubblesort[i] = Long.parseLong(whichcase);
                }
            }
        }
        if (statussorta || statussortd || statustext) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (statussorta) {
                        if (bubblesort[i] > bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    } else {
                        if (bubblesort[i] < bubblesort[i + 1]) {
                            long temp = bubblesort[i];
                            tempp = list[i];
                            bubblesort[i] = bubblesort[i + 1];
                            list[i] = list[i + 1];
                            bubblesort[i + 1] = temp;
                            list[i + 1] = tempp;
                            sorted = false;
                        }
                    }
                }
            }
            IJ.log("" "");
            for (int i = 0; i < n; i++) {
                if (!statustext) {
                    IJ.log(list[i] + "" / "" + bubblesort[i]);
                } else {
                    IJ.log(dir + list[i]);
                }
            }
        }
        if (open_as_stack || only_images) {
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < n - 1; i++) {
                    if (bubblesort[i] > bubblesort[i + 1]) {
                        long temp = bubblesort[i];
                        tempp = list[i];
                        bubblesort[i] = bubblesort[i + 1];
                        list[i] = list[i + 1];
                        bubblesort[i + 1] = temp;
                        list[i + 1] = tempp;
                        sorted = false;
                    }
                }
            }
            if (only_images) {
                Opener o = new Opener();
                int counter = 0;
                IJ.log("" "");
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break; else {
                        ImagePlus imp = o.openImage(path);
                        counter++;
                        if (imp != null) {
                            IJ.log(counter + "" + "" + path);
                            imp.show();
                        } else IJ.log(counter + "" - "" + path);
                    }
                }
                return;
            }
            int width = 0, height = 0, type = 0;
            ImageStack stack = null;
            double min = Double.MAX_VALUE;
            double max = -Double.MAX_VALUE;
            int k = 0;
            try {
                for (int i = 0; i < n; i++) {
                    String path = (dir + list[i]);
                    if (path == null) break;
                    if (list[i].endsWith("".txt"")) continue;
                    ImagePlus imp = new Opener().openImage(path);
                    if (imp != null && stack == null) {
                        width = imp.getWidth();
                        height = imp.getHeight();
                        type = imp.getType();
                        ColorModel cm = imp.getProcessor().getColorModel();
                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);
                    }
                    if (stack != null) k = stack.getSize() + 1;
                    IJ.showStatus(k + ""/"" + n);
                    IJ.showProgress((double) k / n);
                    if (imp == null) IJ.log(list[i] + "": unable to open""); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + "": wrong dimensions""); else if (imp.getType() != type) IJ.log(list[i] + "": wrong type""); else {
                        ImageProcessor ip = imp.getProcessor();
                        if (grayscale) ip = ip.convertToByte(true);
                        if (halfSize) ip = ip.resize(width / 2, height / 2);
                        if (ip.getMin() < min) min = ip.getMin();
                        if (ip.getMax() > max) max = ip.getMax();
                        String label = imp.getTitle();
                        String info = (String) imp.getProperty(""Info"");
                        if (info != null) label += ""\n"" + info;
                        stack.addSlice(label, ip);
                    }
                    System.gc();
                }
            } catch (OutOfMemoryError e) {
                IJ.outOfMemory(""FolderOpener"");
                stack.trim();
            }
            if (stack != null && stack.getSize() > 0) {
                ImagePlus imp2 = new ImagePlus(""Stack"", stack);
                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);
                imp2.show();
            }
            IJ.showProgress(1.0);
        }
    }
"
5862,6016307,7,"    public static int[] rank(double[] data) {
        int[] rank = new int[data.length];
        for (int i = 0; i < data.length; i++) rank[i] = i;
        boolean swapped;
        double dtmp;
        int i, j, itmp;
        for (i = 0; i < data.length - 1; i++) {
            swapped = false;
            for (j = 0; j < data.length - 1 - i; j++) {
                if (data[j] < data[j + 1]) {
                    dtmp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = dtmp;
                    itmp = rank[j];
                    rank[j] = rank[j + 1];
                    rank[j + 1] = itmp;
                    swapped = true;
                }
            }
        }
        return rank;
    }
"
10210,5405559,7,"    public void sort(int[] order, double[] values) {
        int temp = 0;
        boolean done = false;
        for (int i = 0; i < values.length; i++) {
            order[i] = i;
        }
        if (desendingValues) {
            while (!done) {
                done = true;
                for (int i = values.length - 2; i >= 0; i--) {
                    if (values[order[i]] < values[order[i + 1]]) {
                        done = false;
                        temp = order[i];
                        order[i] = order[i + 1];
                        order[i + 1] = temp;
                    }
                }
            }
        } else {
            while (!done) {
                done = true;
                for (int i = values.length - 2; i >= 0; i--) {
                    if (values[order[i]] > values[order[i + 1]]) {
                        done = false;
                        temp = order[i];
                        order[i] = order[i + 1];
                        order[i + 1] = temp;
                    }
                }
            }
        }
    }
"
6518,186569,7,"    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
"
1237,20548201,7,"    public void sorter() {
        String inputLine1, inputLine2;
        String epiNames[] = new String[1000];
        String epiEpisodes[] = new String[1000];
        int lineCounter = 0;
        try {
            String pluginDir = pluginInterface.getPluginDirectoryName();
            String eplist_file = pluginDir + System.getProperty(""file.separator"") + ""EpisodeList.txt"";
            File episodeList = new File(eplist_file);
            if (!episodeList.isFile()) {
                episodeList.createNewFile();
            }
            final BufferedReader in = new BufferedReader(new FileReader(episodeList));
            while ((inputLine1 = in.readLine()) != null) {
                if ((inputLine2 = in.readLine()) != null) {
                    epiNames[lineCounter] = inputLine1;
                    epiEpisodes[lineCounter] = inputLine2;
                    lineCounter++;
                }
            }
            in.close();
            int epiLength = epiNames.length;
            for (int i = 0; i < (lineCounter); i++) {
                for (int j = 0; j < (lineCounter - 1); j++) {
                    if (epiNames[j].compareToIgnoreCase(epiNames[j + 1]) > 0) {
                        String temp = epiNames[j];
                        epiNames[j] = epiNames[j + 1];
                        epiNames[j + 1] = temp;
                        String temp2 = epiEpisodes[j];
                        epiEpisodes[j] = epiEpisodes[j + 1];
                        epiEpisodes[j + 1] = temp2;
                    }
                }
            }
            File episodeList2 = new File(eplist_file);
            BufferedWriter bufWriter = new BufferedWriter(new FileWriter(episodeList2));
            for (int i = 0; i <= lineCounter; i++) {
                if (epiNames[i] == null) {
                    break;
                }
                bufWriter.write(epiNames[i] + ""\n"");
                bufWriter.write(epiEpisodes[i] + ""\n"");
            }
            bufWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
"
4339,3197876,7,"    public ArrayList<String> showTopLetters() {
        int[] tempArray = new int[engCountLetters.length];
        char[] tempArrayLetters = new char[abcEng.length];
        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();
        tempArray = engCountLetters.clone();
        tempArrayLetters = abcEng.clone();
        int tempCount;
        char tempLetters;
        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {
            for (int i = 0; i < abcEng.length - 1; i++) {
                if (tempArray[i] > tempArray[i + 1]) {
                    tempCount = tempArray[i];
                    tempLetters = tempArrayLetters[i];
                    tempArray[i] = tempArray[i + 1];
                    tempArrayLetters[i] = tempArrayLetters[i + 1];
                    tempArray[i + 1] = tempCount;
                    tempArrayLetters[i + 1] = tempLetters;
                }
            }
        }
        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {
            resultTopFiveLetters.add(tempArrayLetters[i] + "":"" + tempArray[i]);
        }
        return resultTopFiveLetters;
    }
"
4863,9221721,7,"    public SOCTradeOffer makeOffer(SOCPossiblePiece targetPiece) {
        D.ebugPrintln(""***** MAKE OFFER *****"");
        if (targetPiece == null) {
            return null;
        }
        SOCTradeOffer offer = null;
        SOCResourceSet targetResources = null;
        switch(targetPiece.getType()) {
            case SOCPossiblePiece.CARD:
                targetResources = SOCGame.CARD_SET;
                break;
            case SOCPossiblePiece.ROAD:
                targetResources = SOCGame.ROAD_SET;
                break;
            case SOCPossiblePiece.SETTLEMENT:
                targetResources = SOCGame.SETTLEMENT_SET;
                break;
            case SOCPossiblePiece.CITY:
                targetResources = SOCGame.CITY_SET;
                break;
        }
        SOCResourceSet ourResources = ourPlayerData.getResources();
        D.ebugPrintln(""*** targetResources = "" + targetResources);
        D.ebugPrintln(""*** ourResources = "" + ourResources);
        if (ourResources.contains(targetResources)) {
            return offer;
        }
        if (ourResources.getAmount(SOCResourceConstants.UNKNOWN) > 0) {
            D.ebugPrintln(""AGG WE HAVE UNKNOWN RESOURCES !!!! %%%%%%%%%%%%%%%%%%%%%%%%%%%%"");
            return offer;
        }
        SOCTradeOffer batna = getOfferToBank(targetResources);
        D.ebugPrintln(""*** BATNA = "" + batna);
        SOCBuildingSpeedEstimate estimate = new SOCBuildingSpeedEstimate(ourPlayerData.getNumbers());
        SOCResourceSet giveResourceSet = new SOCResourceSet();
        SOCResourceSet getResourceSet = new SOCResourceSet();
        int batnaBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
        D.ebugPrintln(""*** batnaBuildingTime = "" + batnaBuildingTime);
        if (batna != null) {
            batnaBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, batna.getGiveSet(), batna.getGetSet(), estimate);
        }
        D.ebugPrintln(""*** batnaBuildingTime = "" + batnaBuildingTime);
        int[] rollsPerResource = estimate.getRollsPerResource();
        int[] neededRsrc = new int[5];
        int[] notNeededRsrc = new int[5];
        int neededRsrcCount = 0;
        int notNeededRsrcCount = 0;
        for (int rsrcType = SOCResourceConstants.CLAY; rsrcType <= SOCResourceConstants.WOOD; rsrcType++) {
            if (targetResources.getAmount(rsrcType) > 0) {
                neededRsrc[neededRsrcCount] = rsrcType;
                neededRsrcCount++;
            } else {
                notNeededRsrc[notNeededRsrcCount] = rsrcType;
                notNeededRsrcCount++;
            }
        }
        for (int j = neededRsrcCount - 1; j >= 0; j--) {
            for (int i = 0; i < j; i++) {
                if (rollsPerResource[neededRsrc[i]] > rollsPerResource[neededRsrc[i + 1]]) {
                    int tmp = neededRsrc[i];
                    neededRsrc[i] = neededRsrc[i + 1];
                    neededRsrc[i + 1] = tmp;
                }
            }
        }
        if (D.ebugOn) {
            for (int i = 0; i < neededRsrcCount; i++) {
                D.ebugPrintln(""NEEDED RSRC: "" + neededRsrc[i] + "" : "" + rollsPerResource[neededRsrc[i]]);
            }
        }
        for (int j = notNeededRsrcCount - 1; j >= 0; j--) {
            for (int i = 0; i < j; i++) {
                if (rollsPerResource[notNeededRsrc[i]] > rollsPerResource[notNeededRsrc[i + 1]]) {
                    int tmp = notNeededRsrc[i];
                    notNeededRsrc[i] = notNeededRsrc[i + 1];
                    notNeededRsrc[i + 1] = tmp;
                }
            }
        }
        if (D.ebugOn) {
            for (int i = 0; i < notNeededRsrcCount; i++) {
                D.ebugPrintln(""NOT-NEEDED RSRC: "" + notNeededRsrc[i] + "" : "" + rollsPerResource[notNeededRsrc[i]]);
            }
        }
        boolean[] someoneIsSellingResource = new boolean[SOCResourceConstants.MAXPLUSONE];
        for (int rsrcType = SOCResourceConstants.CLAY; rsrcType <= SOCResourceConstants.WOOD; rsrcType++) {
            someoneIsSellingResource[rsrcType] = false;
            for (int pn = 0; pn < SOCGame.MAXPLAYERS; pn++) {
                if ((pn != ourPlayerData.getPlayerNumber()) && (isSellingResource[pn][rsrcType])) {
                    someoneIsSellingResource[rsrcType] = true;
                    D.ebugPrintln(""*** player "" + pn + "" is selling "" + rsrcType);
                    break;
                }
            }
        }
        int getRsrcIdx = neededRsrcCount - 1;
        while ((getRsrcIdx >= 0) && ((ourResources.getAmount(neededRsrc[getRsrcIdx]) >= targetResources.getAmount(neededRsrc[getRsrcIdx])) || (!someoneIsSellingResource[neededRsrc[getRsrcIdx]]))) {
            getRsrcIdx--;
        }
        if (getRsrcIdx >= 0) {
            D.ebugPrintln(""*** getRsrc = "" + neededRsrc[getRsrcIdx]);
            getResourceSet.add(1, neededRsrc[getRsrcIdx]);
            D.ebugPrintln(""*** offer should be null : offer = "" + offer);
            int giveRsrcIdx = 0;
            while ((giveRsrcIdx < notNeededRsrcCount) && (offer == null)) {
                D.ebugPrintln(""*** ourResources.getAmount("" + notNeededRsrc[giveRsrcIdx] + "") = "" + ourResources.getAmount(notNeededRsrc[giveRsrcIdx]));
                if (ourResources.getAmount(notNeededRsrc[giveRsrcIdx]) > 0) {
                    giveResourceSet.clear();
                    giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx]);
                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                    D.ebugPrintln(""*** offer = "" + offer);
                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                }
                giveRsrcIdx++;
            }
            D.ebugPrintln(""*** ourResources = "" + ourResources);
            if (offer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                    D.ebugPrintln(""*** ourResources.getAmount("" + neededRsrc[giveRsrcIdx1] + "") = "" + ourResources.getAmount(neededRsrc[giveRsrcIdx1]));
                    D.ebugPrintln(""*** targetResources.getAmount("" + neededRsrc[giveRsrcIdx1] + "") = "" + targetResources.getAmount(neededRsrc[giveRsrcIdx1]));
                    if ((ourResources.getAmount(neededRsrc[giveRsrcIdx1]) > targetResources.getAmount(neededRsrc[giveRsrcIdx1])) && (neededRsrc[giveRsrcIdx1] != neededRsrc[getRsrcIdx])) {
                        giveResourceSet.clear();
                        giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                        int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                        if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                            offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                            D.ebugPrintln(""*** offer = "" + offer);
                            D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                        }
                    }
                    giveRsrcIdx1++;
                }
            }
            D.ebugPrintln(""*** ourResources = "" + ourResources);
            SOCResourceSet leftovers = ourResources.copy();
            leftovers.subtract(targetResources);
            D.ebugPrintln(""*** leftovers = "" + leftovers);
            if (offer == null) {
                int giveRsrcIdx1 = 0;
                int giveRsrcIdx2 = 0;
                while ((giveRsrcIdx1 < notNeededRsrcCount) && (offer == null)) {
                    if (ourResources.getAmount(notNeededRsrc[giveRsrcIdx1]) > 0) {
                        while ((giveRsrcIdx2 < notNeededRsrcCount) && (offer == null)) {
                            giveResourceSet.clear();
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx2]);
                            if (ourResources.contains(giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            giveRsrcIdx2++;
                        }
                        giveRsrcIdx2 = 0;
                        while ((giveRsrcIdx2 < neededRsrcCount) && (offer == null)) {
                            if (neededRsrc[giveRsrcIdx2] != neededRsrc[getRsrcIdx]) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx2]);
                                if (leftovers.contains(giveResourceSet)) {
                                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                    if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                        offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                        D.ebugPrintln(""*** offer = "" + offer);
                                        D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                    }
                                }
                            }
                            giveRsrcIdx2++;
                        }
                    }
                    giveRsrcIdx1++;
                }
                giveRsrcIdx1 = 0;
                giveRsrcIdx2 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                    if ((leftovers.getAmount(neededRsrc[giveRsrcIdx1]) > 0) && (neededRsrc[giveRsrcIdx1] != neededRsrc[getRsrcIdx])) {
                        while ((giveRsrcIdx2 < notNeededRsrcCount) && (offer == null)) {
                            giveResourceSet.clear();
                            giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx2]);
                            if (leftovers.contains(giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            giveRsrcIdx2++;
                        }
                        giveRsrcIdx2 = 0;
                        while ((giveRsrcIdx2 < neededRsrcCount) && (offer == null)) {
                            if (neededRsrc[giveRsrcIdx2] != neededRsrc[getRsrcIdx]) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx2]);
                                if (leftovers.contains(giveResourceSet)) {
                                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                    if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                        offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                        D.ebugPrintln(""*** offer = "" + offer);
                                        D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                    }
                                }
                            }
                            giveRsrcIdx2++;
                        }
                    }
                    giveRsrcIdx1++;
                }
            }
        }
        if (offer == null) {
            SOCResourceSet leftovers = ourResources.copy();
            leftovers.subtract(targetResources);
            D.ebugPrintln(""*** leftovers = "" + leftovers);
            int getRsrcIdx2 = notNeededRsrcCount - 1;
            while ((getRsrcIdx2 >= 0) && (!someoneIsSellingResource[neededRsrc[getRsrcIdx2]])) {
                getRsrcIdx2--;
            }
            while ((getRsrcIdx2 >= 0) && (offer == null)) {
                getResourceSet.clear();
                getResourceSet.add(1, notNeededRsrc[getRsrcIdx2]);
                leftovers.add(1, notNeededRsrc[getRsrcIdx2]);
                if (offer == null) {
                    int giveRsrcIdx1 = 0;
                    while ((giveRsrcIdx1 < notNeededRsrcCount) && (offer == null)) {
                        if ((leftovers.getAmount(notNeededRsrc[giveRsrcIdx1]) > 0) && (notNeededRsrc[giveRsrcIdx1] != notNeededRsrc[getRsrcIdx2])) {
                            leftovers.subtract(1, notNeededRsrc[giveRsrcIdx1]);
                            if (getOfferToBank(targetResources, leftovers) != null) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if (offerBuildingTime < batnaBuildingTime) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, notNeededRsrc[getRsrcIdx2]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            leftovers.add(1, notNeededRsrc[giveRsrcIdx1]);
                        }
                        giveRsrcIdx1++;
                    }
                }
                if (offer == null) {
                    int giveRsrcIdx1 = 0;
                    while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                        if (leftovers.getAmount(neededRsrc[giveRsrcIdx1]) > 0) {
                            leftovers.subtract(1, neededRsrc[giveRsrcIdx1]);
                            if (getOfferToBank(targetResources, leftovers) != null) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if (offerBuildingTime < batnaBuildingTime) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, notNeededRsrc[getRsrcIdx2]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            leftovers.add(1, neededRsrc[giveRsrcIdx1]);
                        }
                        giveRsrcIdx1++;
                    }
                }
                leftovers.subtract(1, notNeededRsrc[getRsrcIdx2]);
                getRsrcIdx2--;
            }
        }
        return offer;
    }
"
7596,8166293,7,"    public static void main(String[] args) {
        int dizi[] = { 23, 78, 45, 8, 3, 32, 56, 39, 92, 28 };
        boolean test = false;
        int kars = 0;
        int tas = 0;
        while (true) {
            for (int j = 0; j < dizi.length - 1; j++) {
                kars++;
                if (dizi[j] > dizi[j + 1]) {
                    int temp = dizi[j];
                    dizi[j] = dizi[j + 1];
                    dizi[j + 1] = temp;
                    test = true;
                    tas++;
                }
            }
            if (!test) {
                break;
            } else {
                test = false;
            }
        }
        for (int i = 0; i < dizi.length; i++) {
            System.out.print(dizi[i] + "" "");
        }
        for (int i = 0; i < 5; i++) {
            System.out.println(""i"" + i);
        }
    }
"
7346,529986,7,"    void bsort(int a[], int lo, int hi) throws Exception {
        for (int j = hi; j > lo; j--) {
            for (int i = lo; i < j; i++) {
                if (a[i] > a[i + 1]) {
                    int T = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = T;
                    pause();
                }
            }
        }
    }
"
3351,19260977,7,"    public int[] sort() {
        boolean t = true;
        int temp = 0;
        int[] mas = new int[N];
        Random rand = new Random();
        for (int i = 0; i < N; i++) {
            mas[i] = rand.nextInt(10) + 1;
        }
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
        return mas;
    }
"
396,11261440,7,"    private static String func(String sf) {
        int total = 0, temp;
        String fnctn[] = { ""sin"", ""cos"", ""tan"", ""log"", ""ln"", ""sqrt"", ""!"" }, temp2 = """";
        int pos[] = new int[7];
        for (int n = 0; n < fnctn.length; n++) {
            pos[n] = sf.lastIndexOf(fnctn[n]);
        }
        for (int m = 0; m < fnctn.length; m++) {
            total += pos[m];
        }
        if (total == -7) {
            return sf;
        }
        for (int i = pos.length; i > 1; i--) {
            for (int j = 0; j < i - 1; j++) {
                if (pos[j] < pos[j + 1]) {
                    temp = pos[j];
                    pos[j] = pos[j + 1];
                    pos[j + 1] = temp;
                    temp2 = fnctn[j];
                    fnctn[j] = fnctn[j + 1];
                    fnctn[j + 1] = temp2;
                }
            }
        }
        if (fnctn[0].equals(""sin"")) {
            if ((pos[0] == 0 || sf.charAt(pos[0] - 1) != 'a')) {
                return func(Functions.sine(sf, pos[0], false));
            } else {
                return func(Functions.asin(sf, pos[0], false));
            }
        } else if (fnctn[0].equals(""cos"")) {
            if ((pos[0] == 0 || sf.charAt(pos[0] - 1) != 'a')) {
                return func(Functions.cosine(sf, pos[0], false));
            } else {
                return func(Functions.acos(sf, pos[0], false));
            }
        } else if (fnctn[0].equals(""tan"")) {
            if ((pos[0] == 0 || sf.charAt(pos[0] - 1) != 'a')) {
                return func(Functions.tangent(sf, pos[0], false));
            } else {
                return func(Functions.atan(sf, pos[0], false));
            }
        } else if (fnctn[0].equals(""log"")) {
            return func(Functions.logarithm(sf, pos[0]));
        } else if (fnctn[0].equals(""ln"")) {
            return func(Functions.lnat(sf, pos[0]));
        } else if (fnctn[0].equals(""sqrt"")) {
            return func(Functions.sqroot(sf, pos[0]));
        } else {
            return func(Functions.factorial(sf, pos[0]));
        }
    }
"
10553,12122419,7,"    private Vector _sort(Pair[] ps, String id, int num) {
        Vector ret = new Vector();
        boolean swapped = true;
        int j = 0;
        Pair tmp;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < ps.length - j; i++) {
                if (ps[i].c > ps[i + 1].c) {
                    tmp = ps[i];
                    ps[i] = ps[i + 1];
                    ps[i + 1] = tmp;
                    swapped = true;
                }
            }
        }
        int m = Math.min(num, ps.length);
        for (int i = m - 1; i >= 0; i--) {
            if (id == null) ret.addElement(ps[i].n); else if (ps[i].n.startsWith(id) && !ps[i].n.equals(id)) ret.addElement(ps[i].n);
        }
        return ret;
    }
"
747,6925921,7,"    public static void bubbleSort(int[] polje) {
        boolean swapped;
        int temp;
        int n = polje.length;
        do {
            swapped = false;
            n--;
            for (int i = 0; i < n - 1; i++) {
                if (polje[i] > polje[i + 1]) {
                    temp = polje[i];
                    polje[i] = polje[i + 1];
                    polje[i + 1] = temp;
                    swapped = true;
                }
            }
        } while (swapped);
    }
"
2701,12561704,7,"    private void bubbleSort(int[] mas) {
        boolean t = true;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    int temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
    }
"
11101,101811,7,"    public void bubbleSort(int[] arr) {
        boolean swapped = true;
        int j = 0;
        int tmp;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < arr.length - j; i++) {
                if (arr[i] > arr[i + 1]) {
                    tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                    swapped = true;
                }
            }
        }
    }
"
9527,1920567,7,"    public static void sortSeries(double[] series) {
        if (series == null) {
            throw new IllegalArgumentException(""Incorrect series. It's null-pointed"");
        }
        int k = 0;
        int right = series.length - 1;
        while (right > 0) {
            k = 0;
            for (int i = 0; i <= right - 1; i++) {
                if (series[i] > series[i + 1]) {
                    k = i;
                    double tmp = series[i];
                    series[i] = series[i + 1];
                    series[i + 1] = tmp;
                }
            }
            right = k;
        }
    }
"
5957,6963063,7,"    public static void main(String args[]) {
        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };
        int sort = 0;
        for (int j = 0; j < (mas.length); j++) {
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    sort = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = sort;
                }
            }
        }
        for (int i = 0; i < mas.length; i++) {
            System.out.print("" "" + mas[i]);
        }
    }
"
6307,3365958,7,"    private void bubbleSort(int[] mas) {
        boolean t = true;
        int temp = 0;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
    }
"
9704,7227330,7,"    private void sort() {
        boolean unsortiert = true;
        Datei tmp = null;
        while (unsortiert) {
            unsortiert = false;
            for (int i = 0; i < this.size - 1; i++) {
                if (dateien[i] != null && dateien[i + 1] != null) {
                    if (dateien[i].compareTo(dateien[i + 1]) < 0) {
                        tmp = dateien[i];
                        dateien[i] = dateien[i + 1];
                        dateien[i + 1] = tmp;
                        unsortiert = true;
                    }
                }
            }
        }
    }
"
6827,15568623,7,"    public Resultado procesar() {
        if (resultado != null) return resultado;
        int[] a = new int[elems.size()];
        Iterator iter = elems.iterator();
        int w = 0;
        while (iter.hasNext()) {
            a[w] = ((Integer) iter.next()).intValue();
            w++;
        }
        int n = a.length;
        long startTime = System.currentTimeMillis();
        int i, j, temp;
        for (i = 0; i < n - 1; i++) {
            for (j = i; j < n - 1; j++) {
                if (a[i] > a[j + 1]) {
                    temp = a[i];
                    a[i] = a[j + 1];
                    a[j + 1] = temp;
                    pasos++;
                }
            }
        }
        long endTime = System.currentTimeMillis();
        resultado = new Resultado((int) (endTime - startTime), pasos, a.length);
        System.out.println(""Resultado BB: "" + resultado);
        return resultado;
    }
"
9015,15195064,7,"    public int[] do_it(final int[] x) {
        int temp = 0;
        int j = x.length;
        while (j > 0) {
            for (int i = 0; i < j - 1; i++) {
                if (x[i] > x[i + 1]) {
                    temp = x[i];
                    x[i] = x[i + 1];
                    x[i + 1] = temp;
                }
                ;
            }
            ;
            j--;
        }
        ;
        return x;
    }
"
4447,14132422,7,"    public static void bubble_sort(Sortable[] objects) {
        for (int i = objects.length; --i >= 0; ) {
            boolean flipped = false;
            for (int j = 0; j < i; j++) {
                if (objects[j].greater_than(objects[j + 1])) {
                    Sortable tmp = objects[j];
                    objects[j] = objects[j + 1];
                    objects[j + 1] = tmp;
                    flipped = true;
                }
            }
            if (!flipped) return;
        }
    }
"
8284,13344290,7,"    public static int best(int r, int n, int s) {
        if ((n <= 0) || (r < 0) || (r > n) || (s < 0)) return 0;
        int[] rolls = new int[n];
        for (int i = 0; i < n; i++) rolls[i] = d(s);
        boolean found;
        do {
            found = false;
            for (int x = 0; x < n - 1; x++) {
                if (rolls[x] < rolls[x + 1]) {
                    int t = rolls[x];
                    rolls[x] = rolls[x + 1];
                    rolls[x + 1] = t;
                    found = true;
                }
            }
        } while (found);
        int sum = 0;
        for (int i = 0; i < r; i++) sum += rolls[i];
        return sum;
    }
"
5245,7327761,7,"    private void fillProductResult() {
        this.ProductResult = new int[this.linearDim + 1][this.linearDim + 1];
        for (int j = 1; j < this.linearDim + 1; j++) {
            this.ProductResult[1][j] = j;
            this.ProductResult[j][1] = j;
        }
        int[] doubleSort = new int[2 * this.GradeCount - 1];
        int permuteCounter = 0;
        int doubleKey = 0;
        int j = 2;
        int k = 2;
        int m = 1;
        int n = 1;
        int tempSort = 0;
        for (j = 2; j < this.linearDim + 1; j++) {
            for (k = 2; k < this.linearDim + 1; k++) {
                permuteCounter = 0;
                doubleKey = 0;
                for (m = 1; m < this.GradeCount; m++) {
                    doubleSort[m] = this.ABasis.getBasis(j, m);
                    doubleSort[m + this.GradeCount - 1] = this.ABasis.getBasis(k, m);
                }
                m = 1;
                for (m = 1; m < 2 * this.GradeCount - 1; m++) {
                    for (n = 1; n < 2 * this.GradeCount - 2; n++) {
                        if (doubleSort[n] > doubleSort[n + 1]) {
                            tempSort = doubleSort[n];
                            doubleSort[n] = doubleSort[n + 1];
                            doubleSort[n + 1] = tempSort;
                            if (!(doubleSort[n] == 0 || doubleSort[n + 1] == 0)) {
                                permuteCounter += 1;
                            }
                        }
                    }
                    n = 1;
                }
                m = 1;
                permuteCounter = permuteCounter % 2;
                for (m = 1; m < 2 * this.GradeCount - 2; m++) {
                    if (doubleSort[m] == 0) continue;
                    if (doubleSort[m] == doubleSort[m + 1]) {
                        tempSort = doubleSort[m];
                        doubleSort[m] = 0;
                        doubleSort[m + 1] = 0;
                        m += 1;
                        permuteCounter += intSignature[tempSort - 1];
                    }
                }
                m = 1;
                permuteCounter = permuteCounter % 2;
                for (m = 1; m < 2 * this.GradeCount - 1; m++) {
                    for (n = 1; n < 2 * this.GradeCount - 2; n++) {
                        if (doubleSort[n] > doubleSort[n + 1]) {
                            tempSort = doubleSort[n];
                            doubleSort[n] = doubleSort[n + 1];
                            doubleSort[n + 1] = tempSort;
                            if (!(doubleSort[n] == 0 || doubleSort[n + 1] == 0)) {
                                permuteCounter += 1;
                            }
                        }
                    }
                    n = 1;
                }
                m = 1;
                permuteCounter = permuteCounter % 2;
                for (m = 1; m < 2 * this.GradeCount - 1; m++) {
                    doubleKey += (int) doubleSort[m] * Math.pow(this.GradeCount, 2 * this.GradeCount - 2 - m);
                }
                m = 1;
                this.ProductResult[j][k] = 0;
                for (m = 1; m < this.linearDim + 1; m++) {
                    if (doubleKey == this.ABasis.getBasisKey(m)) {
                        this.ProductResult[j][k] = m * (int) Math.pow(-1.0, permuteCounter);
                        break;
                    }
                }
                m = 1;
            }
            k = 2;
        }
    }
"
9244,7041871,7,"    public static void bubbleSort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            System.out.println("""" + (i + 1) + """");
            for (int k = 0; k < array.length; k++) {
                System.out.print(array[k] + "" "");
            }
            System.out.println();
        }
    }
"
724,3338750,7,"    public void sortPlayersTurn() {
        Token tempT = new Token();
        Player tempP = new Player(""test name"", tempT);
        int tempN = 0;
        boolean exchangeMade = true;
        for (int i = 0; i < playerNum - 1 && exchangeMade; i++) {
            exchangeMade = false;
            for (int j = 0; j < playerNum - 1 - i; j++) {
                if (diceSum[j] < diceSum[j + 1]) {
                    tempP = players[j];
                    tempN = diceSum[j];
                    players[j] = players[j + 1];
                    diceSum[j] = diceSum[j + 1];
                    players[j + 1] = tempP;
                    diceSum[j + 1] = tempN;
                    exchangeMade = true;
                }
            }
        }
    }
"
218,21273051,7,"    public RobotList<Float> sort_incr_Float(RobotList<Float> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value > distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Float> sol = new RobotList<Float>(Float.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Float(distri[i].value));
        }
        return sol;
    }
"
4190,17630910,7,"    public static int[] sortDescending(double input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] < input[j + 1]) {
                    double mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
"
11132,11892804,7,"    private int[] Tri(int[] pertinence, int taille) {
        boolean change = true;
        int tmp;
        while (change) {
            change = false;
            for (int i = 0; i < taille - 2; i++) {
                if (pertinence[i] < pertinence[i + 1]) {
                    tmp = pertinence[i];
                    pertinence[i] = pertinence[i + 1];
                    pertinence[i + 1] = tmp;
                    change = true;
                }
            }
        }
        return pertinence;
    }
"
3307,12483251,7,"    private void weightAndPlaceClasses() {
        int rows = getRows();
        for (int curRow = _maxPackageRank; curRow < rows; curRow++) {
            xPos = getHGap() / 2;
            BOTLObjectSourceDiagramNode[] rowObject = getObjectsInRow(curRow);
            for (int i = 0; i < rowObject.length; i++) {
                if (curRow == _maxPackageRank) {
                    int nDownlinks = rowObject[i].getDownlinks().size();
                    rowObject[i].setWeight((nDownlinks > 0) ? (1 / nDownlinks) : 2);
                } else {
                    Vector uplinks = rowObject[i].getUplinks();
                    int nUplinks = uplinks.size();
                    if (nUplinks > 0) {
                        float average_col = 0;
                        for (int j = 0; j < uplinks.size(); j++) {
                            average_col += ((BOTLObjectSourceDiagramNode) (uplinks.elementAt(j))).getColumn();
                        }
                        average_col /= nUplinks;
                        rowObject[i].setWeight(average_col);
                    } else {
                        rowObject[i].setWeight(1000);
                    }
                }
            }
            int[] pos = new int[rowObject.length];
            for (int i = 0; i < pos.length; i++) {
                pos[i] = i;
            }
            boolean swapped = true;
            while (swapped) {
                swapped = false;
                for (int i = 0; i < pos.length - 1; i++) {
                    if (rowObject[pos[i]].getWeight() > rowObject[pos[i + 1]].getWeight()) {
                        int temp = pos[i];
                        pos[i] = pos[i + 1];
                        pos[i + 1] = temp;
                        swapped = true;
                    }
                }
            }
            for (int i = 0; i < pos.length; i++) {
                rowObject[pos[i]].setColumn(i);
                if ((i > _vMax) && (rowObject[pos[i]].getUplinks().size() == 0) && (rowObject[pos[i]].getDownlinks().size() == 0)) {
                    if (getColumns(rows - 1) > _vMax) {
                        rows++;
                    }
                    rowObject[pos[i]].setRank(rows - 1);
                } else {
                    rowObject[pos[i]].setLocation(new Point(xPos, yPos));
                    xPos += rowObject[pos[i]].getSize().getWidth() + getHGap();
                }
            }
            yPos += getRowHeight(curRow) + getVGap();
        }
    }
"
200,13696846,7,"    protected void sort(int a) {
        int[] masiv = new int[a];
        Random rand = new Random();
        for (int i = 0; i <= a; i++) {
            masiv[i] = rand.nextInt(200);
        }
        int d;
        for (int j = 0; j < a; j++) {
            for (int i = 0; i < a; i++) {
                if (masiv[i] < masiv[i + 1]) {
                } else {
                    d = masiv[i];
                    masiv[i] = masiv[i + 1];
                    masiv[i + 1] = d;
                }
            }
        }
        while (a != 0) {
            System.out.println(""sort: "" + masiv[a]);
            a--;
        }
    }
"
1470,19972831,7,"    public static int[] simplex_reverse_sort(int[] vertices) {
        if (vertices.length <= 1) return vertices;
        for (int j = vertices.length - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (vertices[i + 1] > vertices[i]) {
                    int dummy = vertices[i];
                    vertices[i] = vertices[i + 1];
                    vertices[i + 1] = dummy;
                }
            }
        }
        return vertices;
    }
"
9484,11371499,7,"    public void sortArray() {
        int a;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1; j++) {
                if (array[j] < array[j + 1]) {
                    a = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = a;
                }
            }
        }
    }
"
5317,12176858,7,"    void sortclasses() {
        int i, j;
        boolean domore;
        vclassptr = new int[numc];
        for (i = 0; i < numc; i++) vclassptr[i] = i;
        domore = true;
        while (domore == true) {
            domore = false;
            for (i = 0; i < numc - 1; i++) {
                if (vclassctr[vclassptr[i]] < vclassctr[vclassptr[i + 1]]) {
                    int temp = vclassptr[i];
                    vclassptr[i] = vclassptr[i + 1];
                    vclassptr[i + 1] = temp;
                    domore = true;
                }
            }
        }
    }
"
5210,253908,7,"    public static void main(String args[]) {
        int i, j, l;
        short NUMNUMBERS = 256;
        short numbers[] = new short[NUMNUMBERS];
        Darjeeling.print(""START"");
        for (l = 0; l < 100; l++) {
            for (i = 0; i < NUMNUMBERS; i++) numbers[i] = (short) (NUMNUMBERS - 1 - i);
            for (i = 0; i < NUMNUMBERS; i++) {
                for (j = 0; j < NUMNUMBERS - i - 1; j++) if (numbers[j] > numbers[j + 1]) {
                    short temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
        }
        Darjeeling.print(""END"");
    }
"
5932,16064530,7,"    private void bubbleSort() {
        for (int i = 0; i < testfield.length; i++) {
            for (int j = 0; j < testfield.length - i - 1; j++) if (testfield[j] > testfield[j + 1]) {
                short temp = testfield[j];
                testfield[j] = testfield[j + 1];
                testfield[j + 1] = temp;
            }
        }
    }
"
5259,630656,7,"    public static void main(String args[]) {
        int i, j, l;
        short NUMNUMBERS = 256;
        short numbers[] = new short[NUMNUMBERS];
        Darjeeling.print(""START"");
        for (l = 0; l < 100; l++) {
            for (i = 0; i < NUMNUMBERS; i++) numbers[i] = (short) (NUMNUMBERS - 1 - i);
            for (i = 0; i < NUMNUMBERS; i++) {
                for (j = 0; j < NUMNUMBERS - i - 1; j++) if (numbers[j] > numbers[j + 1]) {
                    short temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
        }
        Darjeeling.print(""END"");
    }
"
4649,9075137,7,"    public boolean implies(Permission permission) {
        if (!permissionClass.isInstance(permission)) {
            return false;
        }
        GCFPermission perm = (GCFPermission) permission;
        int perm_low = perm.getMinPort();
        int perm_high = perm.getMaxPort();
        Enumeration search = permissions.elements();
        int count = permissions.size();
        int port_low[] = new int[count];
        int port_high[] = new int[count];
        int port_range_count = 0;
        while (search.hasMoreElements()) {
            GCFPermission cur_perm = (GCFPermission) search.nextElement();
            if (cur_perm.impliesByHost(perm)) {
                if (cur_perm.impliesByPorts(perm)) {
                    return true;
                }
                port_low[port_range_count] = cur_perm.getMinPort();
                port_high[port_range_count] = cur_perm.getMaxPort();
                port_range_count++;
            }
        }
        for (int i = 0; i < port_range_count; i++) {
            for (int j = 0; j < port_range_count - 1; j++) {
                if (port_low[j] > port_low[j + 1]) {
                    int tmp = port_low[j];
                    port_low[j] = port_low[j + 1];
                    port_low[j + 1] = tmp;
                    tmp = port_high[j];
                    port_high[j] = port_high[j + 1];
                    port_high[j + 1] = tmp;
                }
            }
        }
        int current_low = port_low[0];
        int current_high = port_high[0];
        for (int i = 1; i < port_range_count; i++) {
            if (port_low[i] > current_high + 1) {
                if (current_low <= perm_low && current_high >= perm_high) {
                    return true;
                }
                if (perm_low <= current_high) {
                    return false;
                }
                current_low = port_low[i];
                current_high = port_high[i];
            } else {
                if (current_high < port_high[i]) {
                    current_high = port_high[i];
                }
            }
        }
        return (current_low <= perm_low && current_high >= perm_high);
    }
"
2596,1668091,7,"    protected static int[] sort(int[] arr) {
        for (int i = arr.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        return arr;
    }
"
135,21273058,7,"    public RobotList<Percentage> sort_decr_Percentage(RobotList<Percentage> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i).percent);
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value < distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Percentage> sol = new RobotList<Percentage>(Percentage.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Percentage(distri[i].value));
        }
        return sol;
    }
"
11544,18378776,7,"    public int[] getRandMas(int n) {
        boolean t = true;
        int interim = 0;
        int[] mas = new int[n];
        Random rand = new Random();
        for (int i = 0; i < n; i++) {
            mas[i] = rand.nextInt(10) + 1;
        }
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    interim = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = interim;
                    t = true;
                }
            }
        }
        return mas;
    }
"
10898,4860089,7,"    public int[] sort() {
        int i, tmp;
        int[] newIndex = new int[nrows];
        for (i = 0; i < nrows; i++) {
            newIndex[i] = i;
        }
        boolean change = true;
        if (this.ascending) {
            if (data[0][column] instanceof Comparable) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if (((Comparable) data[newIndex[i]][column]).compareTo((Comparable) data[newIndex[i + 1]][column]) > 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
                return newIndex;
            }
            if (data[0][column] instanceof String || data[0][column] instanceof ClassLabel) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if ((data[newIndex[i]][column].toString()).compareTo(data[newIndex[i + 1]][column].toString()) > 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
            }
            return newIndex;
        }
        if (!this.ascending) {
            if (data[0][column] instanceof Comparable) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if (((Comparable) data[newIndex[i]][column]).compareTo((Comparable) data[newIndex[i + 1]][column]) < 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
                return newIndex;
            }
            if (data[0][column] instanceof String || data[0][column] instanceof ClassLabel) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if ((data[newIndex[i]][column].toString()).compareTo(data[newIndex[i + 1]][column].toString()) < 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
            }
            return newIndex;
        } else return newIndex;
    }
"
3458,17630905,7,"    public static int[] sortAscending(int input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] > input[j + 1]) {
                    int mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
"
8,23677139,7,"	public static void BubbleSortLong1(long[] num) {
		boolean flag = true; // set flag to true to begin first pass
		long temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
"
6499,3673682,7,"    private void DrawModel(Graphics offg, int obj_num, boolean object, float h, float s, int vt_num, int fc_num) {
        int px[] = new int[3];
        int py[] = new int[3];
        int count = 0;
        int tmp[] = new int[fc_num];
        double tmp_depth[] = new double[fc_num];
        rotate(vt_num);
        offg.setColor(Color.black);
        for (int i = 0; i < fc_num; i++) {
            double a1 = fc[i].vt1.x - fc[i].vt0.x;
            double a2 = fc[i].vt1.y - fc[i].vt0.y;
            double a3 = fc[i].vt1.z - fc[i].vt0.z;
            double b1 = fc[i].vt2.x - fc[i].vt1.x;
            double b2 = fc[i].vt2.y - fc[i].vt1.y;
            double b3 = fc[i].vt2.z - fc[i].vt1.z;
            fc[i].nx = a2 * b3 - a3 * b2;
            fc[i].ny = a3 * b1 - a1 * b3;
            fc[i].nz = a1 * b2 - a2 * b1;
            if (fc[i].nz < 0) {
                fc[i].nx = a2 * b3 - a3 * b2;
                fc[i].ny = a3 * b1 - a1 * b3;
                tmp[count] = i;
                tmp_depth[count] = fc[i].getDepth();
                count++;
            }
        }
        int lim = count - 1;
        do {
            int m = 0;
            for (int n = 0; n <= lim - 1; n++) {
                if (tmp_depth[n] < tmp_depth[n + 1]) {
                    double t = tmp_depth[n];
                    tmp_depth[n] = tmp_depth[n + 1];
                    tmp_depth[n + 1] = t;
                    int ti = tmp[n];
                    tmp[n] = tmp[n + 1];
                    tmp[n + 1] = ti;
                    m = n;
                }
            }
            lim = m;
        } while (lim != 0);
        for (int m = 0; m < count; m++) {
            int i = tmp[m];
            double l = Math.sqrt(fc[i].nx * fc[i].nx + fc[i].ny * fc[i].ny + fc[i].nz * fc[i].nz);
            test(offg, i, l, h, s);
            px[0] = (int) (fc[i].vt0.x * m_Scale + centerp.x);
            py[0] = (int) (-fc[i].vt0.y * m_Scale + centerp.y);
            px[1] = (int) (fc[i].vt1.x * m_Scale + centerp.x);
            py[1] = (int) (-fc[i].vt1.y * m_Scale + centerp.y);
            px[2] = (int) (fc[i].vt2.x * m_Scale + centerp.x);
            py[2] = (int) (-fc[i].vt2.y * m_Scale + centerp.y);
            offg.fillPolygon(px, py, 3);
        }
        if (labelFlag && object) {
            offg.setFont(Fonts.FONT_REAL);
            offg.drawString(d_con.getPointerData().getRealObjName(obj_num), (int) ((fc[0].vt0.x + 10) * m_Scale + centerp.x), (int) (-(fc[0].vt0.y + 10) * m_Scale + centerp.y));
        }
    }
"
7224,10479536,7,"    private void bubbleSort(int values[]) {
        PerfMonTimer timerOuter = PerfMonTimer.start(""SortingTest.bubbleSort"");
        try {
            int len = values.length - 1;
            for (int i = 0; i < len; i++) {
                for (int j = 0; j < len - i; j++) {
                    if (values[j] > values[j + 1]) {
                        int tmp = values[j];
                        values[j] = values[j + 1];
                        values[j + 1] = tmp;
                    }
                }
            }
        } finally {
            PerfMonTimer.stop(timerOuter);
        }
    }
"
3290,17630909,7,"    public static int[] sortAscending(double input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] > input[j + 1]) {
                    double mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
"
11993,10174628,7,"    @Override
    public T[] sort(T[] values) {
        super.compareTimes = 0;
        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values.length - i - 1; j++) {
                super.compareTimes++;
                if (values[j].compareTo(values[j + 1]) > 0) {
                    T temp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = temp;
                }
            }
        }
        return values;
    }
"
850,17583188,7,"    byte[] toByteArray() throws IOException {
        DataElement element = new DataElement(DataElement.DATSEQ);
        final boolean sort = true;
        if (sort) {
            int[] sortIDs = new int[attributes.size()];
            int k = 0;
            for (Enumeration e = attributes.keys(); e.hasMoreElements(); ) {
                Integer key = (Integer) e.nextElement();
                sortIDs[k] = key.intValue();
                k++;
            }
            for (int i = 0; i < sortIDs.length; i++) {
                for (int j = 0; j < sortIDs.length - i - 1; j++) {
                    if (sortIDs[j] > sortIDs[j + 1]) {
                        int temp = sortIDs[j];
                        sortIDs[j] = sortIDs[j + 1];
                        sortIDs[j + 1] = temp;
                    }
                }
            }
            for (int i = 0; i < sortIDs.length; i++) {
                element.addElement(new DataElement(DataElement.U_INT_2, sortIDs[i]));
                element.addElement(getAttributeValue(sortIDs[i]));
            }
        } else {
            for (Enumeration e = attributes.keys(); e.hasMoreElements(); ) {
                Integer key = (Integer) e.nextElement();
                element.addElement(new DataElement(DataElement.U_INT_2, key.intValue()));
                element.addElement((DataElement) attributes.get(key));
            }
        }
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        (new SDPOutputStream(out)).writeElement(element);
        return out.toByteArray();
    }
"
9513,9225969,7,"    public void sort(int[] mas) {
        int temp;
        boolean t = true;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
    }
"
9786,13799349,7,"    void bubbleSort(int ids[]) {
        boolean flag = true;
        int temp;
        while (flag) {
            flag = false;
            for (int i = 0; i < ids.length - 1; i++) if (ids[i] < ids[i + 1]) {
                temp = ids[i];
                ids[i] = ids[i + 1];
                ids[i + 1] = temp;
                flag = true;
            }
        }
    }
"
8142,21273060,7,"    public RobotList<Location> sort_decr_Location(RobotList<Location> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i)));
            }
        } else if (field.equals(""x"")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).x);
            }
        } else if (field.equals(""y"")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).y);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value < enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Location> new_location_list = new RobotList<Location>(Location.class);
        for (int i = 0; i < length; i++) {
            new_location_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_location_list;
    }
"
10758,8794510,7,"    public static void bubbleSort(Auto[] xs) {
        boolean unsorted = true;
        while (unsorted) {
            unsorted = false;
            for (int i = 0; i < xs.length - 1; i++) {
                if (!(xs[i].getPreis() >= xs[i + 1].getPreis())) {
                    Auto dummy = xs[i];
                    xs[i] = xs[i + 1];
                    xs[i + 1] = dummy;
                    unsorted = true;
                }
            }
        }
    }
"
1516,21273052,7,"    public RobotList<Float> sort_decr_Float(RobotList<Float> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value < distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Float> sol = new RobotList<Float>(Float.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Float(distri[i].value));
        }
        return sol;
    }
"
2050,8586224,13,"    protected void permute(int v[], Random random) {
        for (int i = v.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            if (i != j) {
                int tmp = v[i];
                v[i] = v[j];
                v[j] = tmp;
            }
        }
    }
"
1134,11392861,13,"    public static int[] cs_randperm(int n, int seed) {
        int p[], k, j, t;
        if (seed == 0) return (null);
        p = new int[n];
        for (k = 0; k < n; k++) p[k] = n - k - 1;
        if (seed == -1) return (p);
        Random r = new Random(seed);
        for (k = 0; k < n; k++) {
            j = k + r.nextInt(n - k);
            t = p[j];
            p[j] = p[k];
            p[k] = t;
        }
        return (p);
    }
"
1557,7848932,13,"        private Target randomize(Target t) {
            if (t != null && t.getNext() != null) {
                ArrayList list = new ArrayList();
                while (t != null) {
                    list.add(t);
                    t = t.getNext();
                }
                Target[] arr = (Target[]) list.toArray(new Target[list.size()]);
                if (true) {
                    Arrays.sort(arr, new Comparator() {

                        public int compare(Object lhs, Object rhs) {
                            return ((Target) rhs).name.compareTo(((Target) lhs).name);
                        }
                    });
                    for (int i = 0; i < arr.length; ++i) {
                        t = arr[i].setNext(t);
                    }
                }
                if (params.random != null) {
                    t = null;
                    Random r = params.random;
                    for (int i = arr.length; --i >= 1; ) {
                        int x = r.nextInt(i + 1);
                        t = arr[x].setNext(t);
                        arr[x] = arr[i];
                    }
                    t = arr[0].setNext(t);
                }
            }
            return t;
        }
"
332,13088706,13,"    public static void shuffle(Object[] array) {
        int n = array.length;
        Object temp;
        for (int i = 1; i < n; ++i) {
            int swap = s_random.nextInt(i + 1);
            temp = array[swap];
            array[swap] = array[i];
            array[i] = temp;
        }
    }
"
1429,3596848,13,"    private static void solve_l2r_lr_dual(Problem prob, double w[], double eps, double Cp, double Cn) {
        int l = prob.l;
        int w_size = prob.n;
        int i, s, iter = 0;
        double xTx[] = new double[l];
        int max_iter = 1000;
        int index[] = new int[l];
        double alpha[] = new double[2 * l];
        byte y[] = new byte[l];
        int max_inner_iter = 100;
        double innereps = 1e-2;
        double innereps_min = Math.min(1e-8, eps);
        double upper_bound[] = new double[] { Cn, 0, Cp };
        for (i = 0; i < w_size; i++) w[i] = 0;
        for (i = 0; i < l; i++) {
            if (prob.y[i] > 0) {
                y[i] = +1;
            } else {
                y[i] = -1;
            }
            alpha[2 * i] = Math.min(0.001 * upper_bound[GETI(y, i)], 1e-8);
            alpha[2 * i + 1] = upper_bound[GETI(y, i)] - alpha[2 * i];
            xTx[i] = 0;
            for (FeatureNode xi : prob.x[i]) {
                xTx[i] += (xi.value) * (xi.value);
                w[xi.index - 1] += y[i] * alpha[2 * i] * xi.value;
            }
            index[i] = i;
        }
        while (iter < max_iter) {
            for (i = 0; i < l; i++) {
                int j = i + random.nextInt(l - i);
                swap(index, i, j);
            }
            int newton_iter = 0;
            double Gmax = 0;
            for (s = 0; s < l; s++) {
                i = index[s];
                byte yi = y[i];
                double C = upper_bound[GETI(y, i)];
                double ywTx = 0, xisq = xTx[i];
                for (FeatureNode xi : prob.x[i]) {
                    ywTx += w[xi.index - 1] * xi.value;
                }
                ywTx *= y[i];
                double a = xisq, b = ywTx;
                int ind1 = 2 * i, ind2 = 2 * i + 1, sign = 1;
                if (0.5 * a * (alpha[ind2] - alpha[ind1]) + b < 0) {
                    ind1 = 2 * i + 1;
                    ind2 = 2 * i;
                    sign = -1;
                }
                double alpha_old = alpha[ind1];
                double z = alpha_old;
                if (C - z < 0.5 * C) z = 0.1 * z;
                double gp = a * (z - alpha_old) + sign * b + Math.log(z / (C - z));
                Gmax = Math.max(Gmax, Math.abs(gp));
                final double eta = 0.1;
                int inner_iter = 0;
                while (inner_iter <= max_inner_iter) {
                    if (Math.abs(gp) < innereps) break;
                    double gpp = a + C / (C - z) / z;
                    double tmpz = z - gp / gpp;
                    if (tmpz <= 0) z *= eta; else z = tmpz;
                    gp = a * (z - alpha_old) + sign * b + Math.log(z / (C - z));
                    newton_iter++;
                    inner_iter++;
                }
                if (inner_iter > 0) {
                    alpha[ind1] = z;
                    alpha[ind2] = C - z;
                    for (FeatureNode xi : prob.x[i]) {
                        w[xi.index - 1] += sign * (z - alpha_old) * yi * xi.value;
                    }
                }
            }
            iter++;
            if (iter % 10 == 0) info(""."");
            if (Gmax < eps) break;
            if (newton_iter < l / 10) innereps = Math.max(innereps_min, 0.1 * innereps);
        }
        info(""%noptimization finished, #iter = %d%n"", iter);
        if (iter >= max_iter) info(""%nWARNING: reaching max number of iterations%nUsing -s 0 may be faster (also see FAQ)%n%n"");
        double v = 0;
        for (i = 0; i < w_size; i++) v += w[i] * w[i];
        v *= 0.5;
        for (i = 0; i < l; i++) v += alpha[2 * i] * Math.log(alpha[2 * i]) + alpha[2 * i + 1] * Math.log(alpha[2 * i + 1]) - upper_bound[GETI(y, i)] * Math.log(upper_bound[GETI(y, i)]);
        info(""Objective value = %f%n"", v);
    }
"
889,632530,13,"    protected void permute(Sequence s) {
        Random rnd = new java.util.Random();
        for (int i = s.size() - 1; i > 0; i--) {
            int j = rnd.nextInt(i + 1);
            if (j < i) s.swapElements(s.atRank(i), s.atRank(j));
        }
    }
"
80,7357528,13,"    private ArrayList<Move> shuffle(ArrayList<Move> list) {
        Random random = new Random();
        for (int index = (list.size() - 1); index > 0; index--) {
            int other = random.nextInt(index + 1);
            Move temp = list.get(other);
            list.set(other, list.get(index));
            list.set(index, temp);
        }
        return list;
    }
"
2291,9883524,13,"    private void choose() {
        final int n = operators.length;
        if (nPick < n) {
            if (unequalWeights) {
                chooseUsingWeights();
            } else {
                for (int k = 0; k < nPick; ++k) {
                    final int which = k + MathUtils.nextInt(n - k);
                    final MCMCOperator tmp = currentRound[k];
                    currentRound[k] = currentRound[which];
                    currentRound[which] = tmp;
                }
            }
        }
    }
"
1225,966813,13,"    void shuffle(MersenneTwisterFast random) {
        int numObjs = fitnesses.length;
        float[] fitnesses = this.fitnesses;
        int[] indices = this.indices;
        float f;
        int i;
        int rand;
        for (int x = numObjs - 1; x >= 1; x--) {
            rand = random.nextInt(x + 1);
            f = fitnesses[x];
            fitnesses[x] = fitnesses[rand];
            fitnesses[rand] = f;
            i = indices[x];
            indices[x] = indices[rand];
            indices[rand] = i;
        }
    }
"
2456,540829,13,"    protected void permute(Sequence s) {
        Random rnd = new java.util.Random();
        for (int i = s.size() - 1; i > 0; i--) {
            int j = rnd.nextInt(i + 1);
            if (j < i) s.swapElements(s.atRank(i), s.atRank(j));
        }
    }
"
1018,6644705,13,"    public static void randomize(long[] arr, int start, int end) {
        for (int i = end; i > 1 + start; i--) {
            int rnd_index = start + rnd.nextInt(i - start);
            long tmp = arr[i - 1];
            arr[i - 1] = arr[rnd_index];
            arr[rnd_index] = tmp;
        }
    }
"
1413,4490316,13,"    public static void randomize(long[] arr, int start, int end) {
        for (int i = end; i > 1 + start; i--) {
            int rnd_index = start + rnd.nextInt(i - start);
            long tmp = arr[i - 1];
            arr[i - 1] = arr[rnd_index];
            arr[rnd_index] = tmp;
        }
    }
"
1627,5172908,13,"    private static void shufflePool(List<Letter> a) {
        int n = a.toArray().length;
        Random random = new Random();
        random.nextInt();
        for (int i = 0; i < n; i++) {
            int change = i + random.nextInt(n - i);
            swap(a, i, change);
        }
    }
"
1269,20328640,13,"    public static final void shuffle(Object[] list) {
        for (int i = list.length - 1; i >= 0; i--) {
            int j = rand.nextInt(i + 1);
            if (i == j) {
                continue;
            }
            Object tmp = list[i];
            list[i] = list[j];
            list[j] = tmp;
        }
    }
"
2183,7436917,13,"    public IntChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            String tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
"
1912,2949081,13,"    public static int[] cs_randperm(int n, int seed) {
        int p[], k, j, t;
        if (seed == 0) return (null);
        p = new int[n];
        for (k = 0; k < n; k++) p[k] = n - k - 1;
        if (seed == -1) return (p);
        Random r = new Random(seed);
        for (k = 0; k < n; k++) {
            j = k + r.nextInt(n - k);
            t = p[j];
            p[j] = p[k];
            p[k] = t;
        }
        return (p);
    }
"
221,6088697,13,"    private void assertComparatorYieldsOrder(String[] orderedObjects, Comparator<String> comparator) {
        String[] keys = (String[]) orderedObjects.clone();
        boolean isInNewOrder = false;
        while (keys.length > 1 && isInNewOrder == false) {
            shuffle: {
                Random rand = new Random();
                for (int i = keys.length - 1; i > 0; i--) {
                    String swap = keys[i];
                    int j = rand.nextInt(i + 1);
                    keys[i] = keys[j];
                    keys[j] = swap;
                }
            }
            testShuffle: {
                for (int i = 0; i < keys.length && !isInNewOrder; i++) {
                    if (!orderedObjects[i].equals(keys[i])) {
                        isInNewOrder = true;
                    }
                }
            }
        }
        Arrays.sort(keys, comparator);
        for (int i = 0; i < orderedObjects.length; i++) {
            assertEquals(orderedObjects[i], keys[i]);
        }
    }
"
2174,1721214,13,"    public boolean shufflePatterns() {
        this.checker.init(""shufflePatterns"");
        this.checker.addCheck(this.patterns != null, ""The pattern list is a null pointer."");
        this.checker.addCheck(this.patterns.size() > 0, ""The pattern list is empty."");
        if (this.checker.isSecure()) {
            Random r = new Random();
            int j = 0;
            for (int i = 0; i < this.patterns.size(); i++) {
                j = r.nextInt(i + 1);
                Pattern temp = this.patterns.get(i);
                this.patterns.set(i, this.patterns.get(j));
                this.patterns.set(j, temp);
            }
            return true;
        }
        return false;
    }
"
478,13912756,13,"    public RandomOrderIntCG(IntChoiceGenerator sub) {
        super(sub.id);
        setPreviousChoiceGenerator(sub.getPreviousChoiceGenerator());
        choices = new int[sub.getTotalNumberOfChoices()];
        for (int i = 0; i < choices.length; i++) {
            sub.advance();
            choices[i] = sub.getNextChoice();
        }
        for (int i = choices.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            int tmp = choices[i];
            choices[i] = choices[j];
            choices[j] = tmp;
        }
        nextIdx = -1;
    }
"
1966,3596849,13,"    private static void solve_l1r_l2_svc(Problem prob_col, double[] w, double eps, double Cp, double Cn) {
        int l = prob_col.l;
        int w_size = prob_col.n;
        int j, s, iter = 0;
        int max_iter = 1000;
        int active_size = w_size;
        int max_num_linesearch = 20;
        double sigma = 0.01;
        double d, G_loss, G, H;
        double Gmax_old = Double.POSITIVE_INFINITY;
        double Gmax_new;
        double Gmax_init = 0;
        double d_old, d_diff;
        double loss_old = 0;
        double loss_new;
        double appxcond, cond;
        int[] index = new int[w_size];
        byte[] y = new byte[l];
        double[] b = new double[l];
        double[] xj_sq = new double[w_size];
        double[] C = new double[] { Cn, 0, Cp };
        for (j = 0; j < l; j++) {
            b[j] = 1;
            if (prob_col.y[j] > 0) y[j] = 1; else y[j] = -1;
        }
        for (j = 0; j < w_size; j++) {
            w[j] = 0;
            index[j] = j;
            xj_sq[j] = 0;
            for (FeatureNode xi : prob_col.x[j]) {
                int ind = xi.index - 1;
                double val = xi.value;
                xi.value *= y[ind];
                xj_sq[j] += C[GETI(y, ind)] * val * val;
            }
        }
        while (iter < max_iter) {
            Gmax_new = 0;
            for (j = 0; j < active_size; j++) {
                int i = j + random.nextInt(active_size - j);
                swap(index, i, j);
            }
            for (s = 0; s < active_size; s++) {
                j = index[s];
                G_loss = 0;
                H = 0;
                for (FeatureNode xi : prob_col.x[j]) {
                    int ind = xi.index - 1;
                    if (b[ind] > 0) {
                        double val = xi.value;
                        double tmp = C[GETI(y, ind)] * val;
                        G_loss -= tmp * b[ind];
                        H += tmp * val;
                    }
                }
                G_loss *= 2;
                G = G_loss;
                H *= 2;
                H = Math.max(H, 1e-12);
                double Gp = G + 1;
                double Gn = G - 1;
                double violation = 0;
                if (w[j] == 0) {
                    if (Gp < 0) violation = -Gp; else if (Gn > 0) violation = Gn; else if (Gp > Gmax_old / l && Gn < -Gmax_old / l) {
                        active_size--;
                        swap(index, s, active_size);
                        s--;
                        continue;
                    }
                } else if (w[j] > 0) violation = Math.abs(Gp); else violation = Math.abs(Gn);
                Gmax_new = Math.max(Gmax_new, violation);
                if (Gp <= H * w[j]) d = -Gp / H; else if (Gn >= H * w[j]) d = -Gn / H; else d = -w[j];
                if (Math.abs(d) < 1.0e-12) continue;
                double delta = Math.abs(w[j] + d) - Math.abs(w[j]) + G * d;
                d_old = 0;
                int num_linesearch;
                for (num_linesearch = 0; num_linesearch < max_num_linesearch; num_linesearch++) {
                    d_diff = d_old - d;
                    cond = Math.abs(w[j] + d) - Math.abs(w[j]) - sigma * delta;
                    appxcond = xj_sq[j] * d * d + G_loss * d + cond;
                    if (appxcond <= 0) {
                        for (FeatureNode x : prob_col.x[j]) {
                            b[x.index - 1] += d_diff * x.value;
                        }
                        break;
                    }
                    if (num_linesearch == 0) {
                        loss_old = 0;
                        loss_new = 0;
                        for (FeatureNode x : prob_col.x[j]) {
                            int ind = x.index - 1;
                            if (b[ind] > 0) {
                                loss_old += C[GETI(y, ind)] * b[ind] * b[ind];
                            }
                            double b_new = b[ind] + d_diff * x.value;
                            b[ind] = b_new;
                            if (b_new > 0) {
                                loss_new += C[GETI(y, ind)] * b_new * b_new;
                            }
                        }
                    } else {
                        loss_new = 0;
                        for (FeatureNode x : prob_col.x[j]) {
                            int ind = x.index - 1;
                            double b_new = b[ind] + d_diff * x.value;
                            b[ind] = b_new;
                            if (b_new > 0) {
                                loss_new += C[GETI(y, ind)] * b_new * b_new;
                            }
                        }
                    }
                    cond = cond + loss_new - loss_old;
                    if (cond <= 0) break; else {
                        d_old = d;
                        d *= 0.5;
                        delta *= 0.5;
                    }
                }
                w[j] += d;
                if (num_linesearch >= max_num_linesearch) {
                    info(""#"");
                    for (int i = 0; i < l; i++) b[i] = 1;
                    for (int i = 0; i < w_size; i++) {
                        if (w[i] == 0) continue;
                        for (FeatureNode x : prob_col.x[i]) {
                            b[x.index - 1] -= w[i] * x.value;
                        }
                    }
                }
            }
            if (iter == 0) Gmax_init = Gmax_new;
            iter++;
            if (iter % 10 == 0) info(""."");
            if (Gmax_new <= eps * Gmax_init) {
                if (active_size == w_size) break; else {
                    active_size = w_size;
                    info(""*"");
                    Gmax_old = Double.POSITIVE_INFINITY;
                    continue;
                }
            }
            Gmax_old = Gmax_new;
        }
        info(""%noptimization finished, #iter = %d%n"", iter);
        if (iter >= max_iter) info(""%nWARNING: reaching max number of iterations%n"");
        double v = 0;
        int nnz = 0;
        for (j = 0; j < w_size; j++) {
            for (FeatureNode x : prob_col.x[j]) {
                x.value *= prob_col.y[x.index - 1];
            }
            if (w[j] != 0) {
                v += Math.abs(w[j]);
                nnz++;
            }
        }
        for (j = 0; j < l; j++) if (b[j] > 0) v += C[GETI(y, j)] * b[j] * b[j];
        info(""Objective value = %f%n"", v);
        info(""#nonzeros/#features = %d/%d%n"", nnz, w_size);
    }
"
755,10496866,13,"    public static void svm_cross_validation(svm_problem prob, svm_parameter param, int nr_fold, double[] target) {
        int i;
        int[] fold_start = new int[nr_fold + 1];
        int l = prob.l;
        int[] perm = new int[l];
        if ((param.svm_type == svm_parameter.C_SVC || param.svm_type == svm_parameter.NU_SVC) && nr_fold < l) {
            int[] tmp_nr_class = new int[1];
            int[][] tmp_label = new int[1][];
            int[][] tmp_start = new int[1][];
            int[][] tmp_count = new int[1][];
            svm_group_classes(prob, tmp_nr_class, tmp_label, tmp_start, tmp_count, perm);
            int nr_class = tmp_nr_class[0];
            int[] start = tmp_start[0];
            int[] count = tmp_count[0];
            int[] fold_count = new int[nr_fold];
            int c;
            int[] index = new int[l];
            for (i = 0; i < l; i++) index[i] = perm[i];
            for (c = 0; c < nr_class; c++) for (i = 0; i < count[c]; i++) {
                int j = i + rand.nextInt(count[c] - i);
                do {
                    int _ = index[start[c] + j];
                    index[start[c] + j] = index[start[c] + i];
                    index[start[c] + i] = _;
                } while (false);
            }
            for (i = 0; i < nr_fold; i++) {
                fold_count[i] = 0;
                for (c = 0; c < nr_class; c++) fold_count[i] += (i + 1) * count[c] / nr_fold - i * count[c] / nr_fold;
            }
            fold_start[0] = 0;
            for (i = 1; i <= nr_fold; i++) fold_start[i] = fold_start[i - 1] + fold_count[i - 1];
            for (c = 0; c < nr_class; c++) for (i = 0; i < nr_fold; i++) {
                int begin = start[c] + i * count[c] / nr_fold;
                int end = start[c] + (i + 1) * count[c] / nr_fold;
                for (int j = begin; j < end; j++) {
                    perm[fold_start[i]] = index[j];
                    fold_start[i]++;
                }
            }
            fold_start[0] = 0;
            for (i = 1; i <= nr_fold; i++) fold_start[i] = fold_start[i - 1] + fold_count[i - 1];
        } else {
            for (i = 0; i < l; i++) perm[i] = i;
            for (i = 0; i < l; i++) {
                int j = i + rand.nextInt(l - i);
                do {
                    int _ = perm[i];
                    perm[i] = perm[j];
                    perm[j] = _;
                } while (false);
            }
            for (i = 0; i <= nr_fold; i++) fold_start[i] = i * l / nr_fold;
        }
        for (i = 0; i < nr_fold; i++) {
            int begin = fold_start[i];
            int end = fold_start[i + 1];
            int j, k;
            svm_problem subprob = new svm_problem();
            subprob.l = l - (end - begin);
            subprob.x = new svm_node[subprob.l][];
            subprob.y = new double[subprob.l];
            k = 0;
            for (j = 0; j < begin; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            for (j = end; j < l; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            svm_model submodel = svm_train(subprob, param);
            if (param.probability == 1 && (param.svm_type == svm_parameter.C_SVC || param.svm_type == svm_parameter.NU_SVC)) {
                double[] prob_estimates = new double[svm_get_nr_class(submodel)];
                for (j = begin; j < end; j++) target[perm[j]] = svm_predict_probability(submodel, prob.x[perm[j]], prob_estimates);
            } else for (j = begin; j < end; j++) target[perm[j]] = svm_predict(submodel, prob.x[perm[j]]);
        }
    }
"
367,2451218,13,"    public TaggedDoubleChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            double tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
"
1891,3596847,13,"    private static void solve_l2r_l1l2_svc(Problem prob, double[] w, double eps, double Cp, double Cn, SolverType solver_type) {
        int l = prob.l;
        int w_size = prob.n;
        int i, s, iter = 0;
        double C, d, G;
        double[] QD = new double[l];
        int max_iter = 1000;
        int[] index = new int[l];
        double[] alpha = new double[l];
        byte[] y = new byte[l];
        int active_size = l;
        double PG;
        double PGmax_old = Double.POSITIVE_INFINITY;
        double PGmin_old = Double.NEGATIVE_INFINITY;
        double PGmax_new, PGmin_new;
        double diag[] = new double[] { 0.5 / Cn, 0, 0.5 / Cp };
        double upper_bound[] = new double[] { Double.POSITIVE_INFINITY, 0, Double.POSITIVE_INFINITY };
        if (solver_type == SolverType.L2R_L1LOSS_SVC_DUAL) {
            diag[0] = 0;
            diag[2] = 0;
            upper_bound[0] = Cn;
            upper_bound[2] = Cp;
        }
        for (i = 0; i < w_size; i++) w[i] = 0;
        for (i = 0; i < l; i++) {
            alpha[i] = 0;
            if (prob.y[i] > 0) {
                y[i] = +1;
            } else {
                y[i] = -1;
            }
            QD[i] = diag[GETI(y, i)];
            for (FeatureNode xi : prob.x[i]) {
                QD[i] += xi.value * xi.value;
            }
            index[i] = i;
        }
        while (iter < max_iter) {
            PGmax_new = Double.NEGATIVE_INFINITY;
            PGmin_new = Double.POSITIVE_INFINITY;
            for (i = 0; i < active_size; i++) {
                int j = i + random.nextInt(active_size - i);
                swap(index, i, j);
            }
            for (s = 0; s < active_size; s++) {
                i = index[s];
                G = 0;
                byte yi = y[i];
                for (FeatureNode xi : prob.x[i]) {
                    G += w[xi.index - 1] * xi.value;
                }
                G = G * yi - 1;
                C = upper_bound[GETI(y, i)];
                G += alpha[i] * diag[GETI(y, i)];
                PG = 0;
                if (alpha[i] == 0) {
                    if (G > PGmax_old) {
                        active_size--;
                        swap(index, s, active_size);
                        s--;
                        continue;
                    } else if (G < 0) {
                        PG = G;
                    }
                } else if (alpha[i] == C) {
                    if (G < PGmin_old) {
                        active_size--;
                        swap(index, s, active_size);
                        s--;
                        continue;
                    } else if (G > 0) {
                        PG = G;
                    }
                } else {
                    PG = G;
                }
                PGmax_new = Math.max(PGmax_new, PG);
                PGmin_new = Math.min(PGmin_new, PG);
                if (Math.abs(PG) > 1.0e-12) {
                    double alpha_old = alpha[i];
                    alpha[i] = Math.min(Math.max(alpha[i] - G / QD[i], 0.0), C);
                    d = (alpha[i] - alpha_old) * yi;
                    for (FeatureNode xi : prob.x[i]) {
                        w[xi.index - 1] += d * xi.value;
                    }
                }
            }
            iter++;
            if (iter % 10 == 0) info(""."");
            if (PGmax_new - PGmin_new <= eps) {
                if (active_size == l) break; else {
                    active_size = l;
                    info(""*"");
                    PGmax_old = Double.POSITIVE_INFINITY;
                    PGmin_old = Double.NEGATIVE_INFINITY;
                    continue;
                }
            }
            PGmax_old = PGmax_new;
            PGmin_old = PGmin_new;
            if (PGmax_old <= 0) PGmax_old = Double.POSITIVE_INFINITY;
            if (PGmin_old >= 0) PGmin_old = Double.NEGATIVE_INFINITY;
        }
        info(NL + ""optimization finished, #iter = %d"" + NL, iter);
        if (iter >= max_iter) info(""%nWARNING: reaching max number of iterations%nUsing -s 2 may be faster (also see FAQ)%n%n"");
        double v = 0;
        int nSV = 0;
        for (i = 0; i < w_size; i++) v += w[i] * w[i];
        for (i = 0; i < l; i++) {
            v += alpha[i] * (alpha[i] * diag[GETI(y, i)] - 2);
            if (alpha[i] > 0) ++nSV;
        }
        info(""Objective value = %f"" + NL, v / 2);
        info(""nSV = %d"" + NL, nSV);
    }
"
1456,10258420,13,"    private short[] geraConfInicial(int n, short[] array) {
        int swap;
        short aux;
        Random random = new Random();
        for (int pos = n - 1; pos > 0; --pos) {
            swap = random.nextInt(pos + 1);
            aux = array[pos];
            array[pos] = array[swap];
            array[swap] = aux;
        }
        return array;
    }
"
670,6138230,13,"    public DoubleChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            String tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
"
1582,2315719,13,"    public TypedObjectChoice randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            int tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
"
175,10868405,13,"    public void shuffle() {
        Random rng = new Random();
        int n = this.cards.size();
        while (--n > 0) {
            int k = rng.nextInt(n + 1);
            Card temp = this.cards.get(n);
            this.cards.set(n, this.cards.get(k));
            this.cards.set(k, temp);
        }
    }
"
1883,10366826,13,"    private void assertComparatorYieldsOrder(Object[] orderedObjects, Comparator comparator) {
        Object[] keys = (Object[]) orderedObjects.clone();
        boolean isInNewOrder = false;
        while (keys.length > 1 && isInNewOrder == false) {
            shuffle: {
                Random rand = new Random();
                for (int i = keys.length - 1; i > 0; i--) {
                    Object swap = keys[i];
                    int j = rand.nextInt(i + 1);
                    keys[i] = keys[j];
                    keys[j] = swap;
                }
            }
            testShuffle: {
                for (int i = 0; i < keys.length && !isInNewOrder; i++) {
                    if (!orderedObjects[i].equals(keys[i])) {
                        isInNewOrder = true;
                    }
                }
            }
        }
        Arrays.sort(keys, comparator);
        for (int i = 0; i < orderedObjects.length; i++) {
            assertEquals(orderedObjects[i], keys[i]);
        }
    }
"
599,15064,13,"    private int[] randomiseCars(int n) {
        int[] cars = new int[n];
        for (int i = 0; i < n; i++) cars[i] = i;
        Random r = new Random();
        for (int i = 0; i < n; i++) {
            int j = i + r.nextInt(n - i);
            int tmp = cars[i];
            cars[i] = cars[j];
            cars[j] = tmp;
        }
        return cars;
    }
"
874,4490317,13,"    public static void randomize(int[] arr, int start, int end) {
        for (int i = end; i > 1 + start; i--) {
            int rnd_index = start + rnd.nextInt(i - start);
            int tmp = arr[i - 1];
            arr[i - 1] = arr[rnd_index];
            arr[rnd_index] = tmp;
        }
    }
"
1135,7839341,13,"    public static void shuffle(Object[] array, Random rng) {
        for (int i = array.length - 1; i >= 0; i--) {
            int index = rng.nextInt(i + 1);
            Object a = array[index];
            array[index] = array[i];
            array[i] = a;
        }
    }
"
567,3596828,13,"    public static void crossValidation(Problem prob, Parameter param, int nr_fold, int[] target) {
        int i;
        int[] fold_start = new int[nr_fold + 1];
        int l = prob.l;
        int[] perm = new int[l];
        for (i = 0; i < l; i++) perm[i] = i;
        for (i = 0; i < l; i++) {
            int j = i + random.nextInt(l - i);
            swap(perm, i, j);
        }
        for (i = 0; i <= nr_fold; i++) fold_start[i] = i * l / nr_fold;
        for (i = 0; i < nr_fold; i++) {
            int begin = fold_start[i];
            int end = fold_start[i + 1];
            int j, k;
            Problem subprob = new Problem();
            subprob.bias = prob.bias;
            subprob.n = prob.n;
            subprob.l = l - (end - begin);
            subprob.x = new FeatureNode[subprob.l][];
            subprob.y = new int[subprob.l];
            k = 0;
            for (j = 0; j < begin; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            for (j = end; j < l; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            Model submodel = train(subprob, param);
            for (j = begin; j < end; j++) target[perm[j]] = predict(submodel, prob.x[perm[j]]);
        }
    }
"
1366,3894025,13,"    public void shuffle() {
        Random rand = new Random();
        for (int i = size() - 1; i > 0; i--) {
            int newIndex = rand.nextInt(i + 1);
            T temp = get(newIndex);
            set(newIndex, get(i));
            set(i, temp);
        }
    }
"
1779,13088707,13,"    public static void shuffle(int[] array, int n) {
        for (int i = 1; i < n; ++i) {
            int swap = s_random.nextInt(i + 1);
            int temp = array[swap];
            array[swap] = array[i];
            array[i] = temp;
        }
    }
"
857,5936119,13,"    public boolean batchFinished() throws Exception {
        Instances data = getInputFormat();
        if (data == null) throw new IllegalStateException(""No input instance format defined"");
        if (m_Converter == null) {
            int[] randomIndices = new int[m_ClassCounts.length];
            for (int i = 0; i < randomIndices.length; i++) {
                randomIndices[i] = i;
            }
            for (int j = randomIndices.length - 1; j > 0; j--) {
                int toSwap = m_Random.nextInt(j + 1);
                int tmpIndex = randomIndices[j];
                randomIndices[j] = randomIndices[toSwap];
                randomIndices[toSwap] = tmpIndex;
            }
            double[] randomizedCounts = new double[m_ClassCounts.length];
            for (int i = 0; i < randomizedCounts.length; i++) {
                randomizedCounts[i] = m_ClassCounts[randomIndices[i]];
            }
            if (m_ClassOrder == RANDOM) {
                m_Converter = randomIndices;
                m_ClassCounts = randomizedCounts;
            } else {
                int[] sorted = Utils.sort(randomizedCounts);
                m_Converter = new int[sorted.length];
                if (m_ClassOrder == FREQ_ASCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[i]];
                    }
                } else if (m_ClassOrder == FREQ_DESCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[sorted.length - i - 1]];
                    }
                } else {
                    throw new IllegalArgumentException(""Class order not defined!"");
                }
                double[] tmp2 = new double[m_ClassCounts.length];
                for (int i = 0; i < m_Converter.length; i++) {
                    tmp2[i] = m_ClassCounts[m_Converter[i]];
                }
                m_ClassCounts = tmp2;
            }
            FastVector values = new FastVector(data.classAttribute().numValues());
            for (int i = 0; i < data.numClasses(); i++) {
                values.addElement(data.classAttribute().value(m_Converter[i]));
            }
            FastVector newVec = new FastVector(data.numAttributes());
            for (int i = 0; i < data.numAttributes(); i++) {
                if (i == data.classIndex()) {
                    newVec.addElement(new Attribute(data.classAttribute().name(), values, data.classAttribute().getMetadata()));
                } else {
                    newVec.addElement(data.attribute(i));
                }
            }
            Instances newInsts = new Instances(data.relationName(), newVec, 0);
            newInsts.setClassIndex(data.classIndex());
            setOutputFormat(newInsts);
            int[] temp = new int[m_Converter.length];
            for (int i = 0; i < temp.length; i++) {
                temp[m_Converter[i]] = i;
            }
            m_Converter = temp;
            for (int xyz = 0; xyz < data.numInstances(); xyz++) {
                Instance datum = data.instance(xyz);
                if (!datum.isMissing(datum.classIndex())) {
                    datum.setClassValue((float) m_Converter[(int) datum.classValue()]);
                }
                push(datum);
            }
        }
        flushInput();
        m_NewBatch = true;
        return (numPendingOutput() != 0);
    }
"
2033,17621069,13,"    public static synchronized void shuffle(int[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            int temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
"
817,16677102,13,"    public final void randomize(int[] index, Random random) {
        for (int j = index.length - 1; j > 0; j--) {
            int k = random.nextInt(j + 1);
            int temp = index[j];
            index[j] = index[k];
            index[k] = temp;
        }
    }
"
1868,10917227,13,"    public static Graph wireKOut(Graph g, int k, Random r) {
        final int n = g.size();
        if (n < 2) {
            return g;
        }
        if (n <= k) {
            k = n - 1;
        }
        int[] nodes = new int[n];
        for (int i = 0; i < nodes.length; ++i) {
            nodes[i] = i;
        }
        for (int i = 0; i < n; ++i) {
            int j = 0;
            while (j < k) {
                int newedge = j + r.nextInt(n - j);
                int tmp = nodes[j];
                nodes[j] = nodes[newedge];
                nodes[newedge] = tmp;
                if (nodes[j] != i) {
                    g.setEdge(i, nodes[j]);
                    j++;
                }
            }
        }
        return g;
    }
"
2279,11205237,13,"    public ChoiceGenerator randomize() {
        for (int i = values.size() - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            SCEvent tmp = values.get(i);
            values.set(i, values.get(j));
            values.set(j, tmp);
        }
        return this;
    }
"
93,20328638,13,"    public static final void shuffle(int[] list) {
        for (int i = list.length - 1; i >= 0; i--) {
            int j = rand.nextInt(i + 1);
            if (i == j) {
                continue;
            }
            int tmp = list[i];
            list[i] = list[j];
            list[j] = tmp;
        }
    }
"
678,7079645,13,"    public synchronized boolean setSource(File file) {
        if (!file.isDirectory()) {
            return false;
        }
        m_current = -1;
        Random rand = new Random();
        m_files = file.listFiles(new ValidFileFilter());
        if (m_random) {
            List<File> fileList = Arrays.asList(m_files);
            Collections.shuffle(fileList, rand);
            m_files = fileList.toArray(m_files);
        }
        m_innerCount = 0;
        m_multiStimuliParsers = false;
        List<int[]> orderList = new LinkedList<int[]>();
        int[] order = null;
        StimuliParser parser = new FolderParser(m_maxsize, m_spp, 1, m_controls, false);
        StimuliParser parser2 = null;
        if (m_spp > 1) parser2 = new FolderParser(m_maxsize, m_spp - 1, 1, m_controls, false);
        if (parser.setSource(m_files[0])) {
            List<int[]> singleOrderList = new LinkedList<int[]>();
            m_multiStimuliParsers = true;
            order = new int[2];
            order[0] = 0;
            int thiscount = parser.getInnerStimuliCount();
            for (int i = 0; i < thiscount; ++i) {
                order[1] = i;
                singleOrderList.add(order.clone());
            }
            m_innerCount += thiscount;
            if (m_random) {
                Collections.shuffle(singleOrderList, rand);
            }
            orderList.addAll(singleOrderList);
        } else if (m_spp > 1) {
            File tiedFolder = getTiedFolder(m_files[0]);
            if (tiedFolder.isDirectory()) {
                List<int[]> singleOrderList = new LinkedList<int[]>();
                m_multiStimuliParsers = true;
                parser2.setSource(tiedFolder);
                order = new int[2];
                order[0] = 0;
                int thiscount = parser2.getInnerStimuliCount();
                for (int i = 0; i < thiscount; ++i) {
                    order[1] = i;
                    singleOrderList.add(order.clone());
                }
                m_innerCount += thiscount;
                if (m_random) Collections.shuffle(singleOrderList, rand);
                orderList.addAll(singleOrderList);
            }
        }
        if (m_multiStimuliParsers) {
            for (int i = 1; i < m_files.length; ++i) {
                List<int[]> singleOrderList = new LinkedList<int[]>();
                order[0] = i;
                int thiscount;
                if (!parser.setSource(m_files[i])) {
                    File tiedFolder = getTiedFolder(m_files[i]);
                    parser2.setSource(tiedFolder);
                    thiscount = parser2.getInnerStimuliCount();
                } else thiscount = parser.getInnerStimuliCount();
                for (int j = 0; j < thiscount; ++j) {
                    order[1] = j;
                    singleOrderList.add(order.clone());
                }
                m_innerCount += thiscount;
                if (m_random) {
                    Collections.shuffle(singleOrderList, rand);
                }
                orderList.addAll(singleOrderList);
            }
        } else {
            order = new int[m_spp];
            for (int i = 0; i < m_spp; ++i) order[i] = i;
            int h = 0;
            int choices = 0;
            while (true) {
                orderList.add(order.clone());
                ++choices;
                if (order[h] == m_files.length - m_spp + h) {
                    if (h == 0) break;
                    ++order[--h];
                    for (int i = h + 1; i < m_spp; ++i) order[i] = order[i - 1] + 1;
                } else {
                    h = m_spp - 1;
                    ++order[h];
                }
            }
            m_innerCount = choices;
            if (m_random) Collections.shuffle(orderList, rand);
        }
        if (m_sequences > 1) {
            m_innerCount *= m_sequences;
            List<int[]> holder = new LinkedList<int[]>(orderList);
            for (int i = 1; i < m_sequences; ++i) {
                List<int[]> temp = new LinkedList<int[]>();
                for (int[] v : orderList) temp.add(v.clone());
                Collections.shuffle(temp, rand);
                holder.addAll(temp);
            }
            orderList = holder;
        }
        m_order = orderList.toArray(new int[m_innerCount][order.length]);
        if (!m_multiStimuliParsers && m_random) {
            int temp;
            for (int[] v : m_order) {
                for (int i = 1; i < v.length; ++i) {
                    int swapi = rand.nextInt(i + 1);
                    if (swapi != i) {
                        temp = v[i];
                        v[i] = v[swapi];
                        v[swapi] = temp;
                    }
                }
            }
        }
        m_parsers = new StimuliParser[m_order[0].length];
        return true;
    }
"
1313,13140215,13,"    @Override
    public void shuffleInstances() {
        Random random = new Random(seed);
        for (int i = 0; i < userRecords.length; i++) {
            for (int j = userRecords[i].length - 1; j > 0; j--) {
                Rating r = userRecords[i][j];
                int k = random.nextInt(j + 1);
                userRecords[i][j] = userRecords[i][k];
                userRecords[i][k] = r;
            }
        }
    }
"
73,17621072,13,"    public static synchronized void shuffle(char[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            char temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
"
1407,628864,13,"    protected void permute(Sequence s) {
        Random rnd = new java.util.Random();
        for (int i = s.size() - 1; i > 0; i--) {
            int j = rnd.nextInt(i + 1);
            if (j < i) s.swapElements(s.atRank(i), s.atRank(j));
        }
    }
"
2508,7200130,13,"    public static void shuffle(int[] a, Random rand) {
        for (int i = a.length - 1; i >= 1; i--) {
            int j = rand.nextInt(i + 1);
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }
"
1177,2423912,13,"    public static void shuffle(double[] source, Random randomizer) {
        int n = source.length;
        for (int i = n - 1; i > 0; i--) {
            int j = randomizer.nextInt(i + 1);
            double k = source[j];
            source[j] = source[i];
            source[i] = k;
        }
    }
"
2008,5226973,13,"    void shuffle() {
        Random random = new Random();
        for (int i = cards.size() - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            Card c = cards.get(j);
            cards.set(j, cards.get(i));
            cards.set(i, c);
        }
    }
"
1419,1313371,13,"    public static int[] permute(int N, Random rand) {
        int[] a = new int[N];
        for (int i = 0; i < N; i++) a[i] = i;
        for (int i = 0; i < N; i++) {
            int r = rand.nextInt(i + 1);
            int swap = a[r];
            a[r] = a[i];
            a[i] = swap;
        }
        return a;
    }
"
2059,6938966,13,"    public static void shuffleArray(int[] a) {
        int n = a.length;
        Random random = new Random();
        random.nextInt();
        for (int i = 0; i < n; i++) {
            int change = i + random.nextInt(n - i);
            swap(a, i, change);
        }
    }
"
70,17621070,13,"    public static synchronized void shuffle(double[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            double temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
"
44,21745053,13,"    public static Graph wireKOut(Graph g, int k, Random r) {
        final int n = g.size();
        if (n < 2) {
            return g;
        }
        if (n <= k) {
            k = n - 1;
        }
        int[] nodes = new int[n];
        for (int i = 0; i < nodes.length; ++i) {
            nodes[i] = i;
        }
        for (int i = 0; i < n; ++i) {
            int j = 0;
            while (j < k) {
                int newedge = j + r.nextInt(n - j);
                int tmp = nodes[j];
                nodes[j] = nodes[newedge];
                nodes[newedge] = tmp;
                if (nodes[j] != i) {
                    g.setEdge(i, nodes[j]);
                    j++;
                }
            }
        }
        return g;
    }
"
2447,7670209,13,"    public static void shuffleList(List<Integer> a) {
        int n = a.size();
        Random random = new Random();
        random.nextInt();
        for (int i = 0; i < n; i++) {
            int change = i + random.nextInt(n - i);
            swap(a, i, change);
        }
    }
"
2246,17621073,13,"    public static synchronized void shuffle(byte[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            byte temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
"
2268,8533735,13,"    public void shuffle() {
        Card tempCard = new Card();
        for (int i = 0; i < NUM_CARDS; i++) {
            int j = i + r.nextInt(NUM_CARDS - i);
            tempCard = cards[j];
            cards[j] = cards[i];
            cards[i] = tempCard;
        }
        position = 0;
    }
"
2290,17467511,13,"    public static final void randomShuffle(int[] v, Random r) {
        int n = v.length;
        while (--n > 0) {
            int k = r.nextInt(n + 1);
            int temp = v[n];
            v[n] = v[k];
            v[k] = temp;
        }
    }
"
430,18412513,13,"    private void assertComparatorYieldsOrder(Object[] orderedObjects, Comparator comparator) {
        Object[] keys = (Object[]) orderedObjects.clone();
        boolean isInNewOrder = false;
        while (keys.length > 1 && isInNewOrder == false) {
            shuffle: {
                Random rand = new Random();
                for (int i = keys.length - 1; i > 0; i--) {
                    Object swap = keys[i];
                    int j = rand.nextInt(i + 1);
                    keys[i] = keys[j];
                    keys[j] = swap;
                }
            }
            testShuffle: {
                for (int i = 0; i < keys.length && !isInNewOrder; i++) {
                    if (!orderedObjects[i].equals(keys[i])) {
                        isInNewOrder = true;
                    }
                }
            }
        }
        Arrays.sort(keys, comparator);
        for (int i = 0; i < orderedObjects.length; i++) {
            assertEquals(orderedObjects[i], keys[i]);
        }
    }
"
29,19654783,13,"    public static <T> void shuffle(T[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            T swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
"
1088,7839340,13,"    public static void shuffle(int[] array, Random rng) {
        for (int i = array.length - 1; i >= 0; i--) {
            int index = rng.nextInt(i + 1);
            int a = array[index];
            array[index] = array[i];
            array[i] = a;
        }
    }
"
1723,12962394,13,"    public final void randomize(int[] index, Random random) {
        for (int j = index.length - 1; j > 0; j--) {
            int k = random.nextInt(j + 1);
            int temp = index[j];
            index[j] = index[k];
            index[k] = temp;
        }
    }
"
1803,17510245,13,"    void permute(int[] a, int n) {
        for (int i = 0; i < n; i++) {
            int j = random.nextInt(i + 1);
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }
"
1547,19654780,13,"    public static void shuffle(int[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            int swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
"
178,22181822,13,"    public int[] shuffle(int[] d) {
        int n = d.length;
        int[] res = new int[n];
        System.arraycopy(d, 0, res, 0, n);
        for (int i = 0; i < n; i++) {
            int p = i + random.nextInt(n - i);
            int q = res[p];
            res[p] = res[i];
            res[i] = q;
        }
        return (res);
    }
"
2596,19076717,13,"    @SuppressWarnings(""unused"")
    public static void main(String[] args) {
        int angleCount = 10800;
        float[] angles = new float[angleCount];
        float[] sinerror = new float[angleCount];
        float[] coserror = new float[angleCount];
        float[] atanerror = new float[angleCount];
        for (int i = 0; i < angleCount; i++) {
            float angle = (float) (Math.PI * 2 * i / angleCount);
            angles[i] = angle;
            float rs = (float) Math.sin(angle);
            float ls = sin(angle);
            sinerror[i] = Math.abs(rs - ls);
            float rc = (float) Math.cos(angle);
            float lc = cos(angle);
            coserror[i] = Math.abs(rc - lc);
            float ratan = (float) Math.atan2(100 * rs, 100 * rc);
            float latan = atan2(100 * rs, 100 * rc);
            atanerror[i] = MathUtils.angleDiff(ratan, latan);
        }
        float maxSin = -1, minSin = Float.MAX_VALUE, meanSin = 0;
        float maxCos = -1, minCos = Float.MAX_VALUE, meanCos = 0;
        float maxAtan = -1, minAtan = Float.MAX_VALUE, meanAtan = 0;
        for (int i = 0; i < angleCount; i++) {
            maxSin = Math.max(maxSin, sinerror[i]);
            minSin = Math.min(minSin, sinerror[i]);
            maxCos = Math.max(maxCos, coserror[i]);
            minCos = Math.min(minCos, coserror[i]);
            maxAtan = Math.max(maxAtan, atanerror[i]);
            minAtan = Math.min(minAtan, atanerror[i]);
            meanSin += sinerror[i];
            meanCos += coserror[i];
            meanAtan += atanerror[i];
        }
        meanSin /= angleCount;
        meanCos /= angleCount;
        meanAtan /= angleCount;
        System.out.println(""Accuracy:"");
        System.out.println(""sin/cos table size = "" + sin.length);
        System.out.println(""Sin\tmin\t\tmax\t\tmean"");
        System.out.println(""\t"" + minSin + ""\t"" + maxSin + ""\t"" + meanSin);
        System.out.println(""Cos\tmin\t\tmax\t\tmean"");
        System.out.println(""\t"" + minCos + ""\t"" + maxCos + ""\t"" + meanCos);
        System.out.println(""atan2 table size = "" + atan2.length);
        System.out.println(""Atan2\tmin\t\tmax\t\tmean (in degrees)"");
        System.out.println(""\t"" + Math.toDegrees(minAtan) + ""\t"" + Math.toDegrees(maxAtan) + ""\t"" + Math.toDegrees(meanAtan));
        System.out.println(""Performance:"");
        Random rng = new Random();
        for (int i = angles.length - 1; i >= 0; i--) {
            int index = rng.nextInt(i + 1);
            float a = angles[index];
            angles[index] = angles[i];
            angles[i] = a;
        }
        System.out.println(""testing"");
        int tests = (int) 2E7;
        for (int i = 0; i < 10; i++) {
            long t = System.currentTimeMillis();
            float jm = testMathSin(tests, angles);
            long duration = System.currentTimeMillis() - t;
            double jp = (double) tests / duration;
            t = System.currentTimeMillis();
            float fm = testFastSin(tests, angles);
            duration = System.currentTimeMillis() - t;
            double fp = (double) tests / duration;
            System.out.println(""Fast sin is "" + fp / jp + "" times faster than java sin"");
        }
        float[] coords = new float[100];
        float r = 100;
        for (int i = 0; i < coords.length; i++) {
            coords[i] = rng.nextFloat() * 2 * r - r;
        }
        for (int i = 0; i < 10; i++) {
            long t = System.currentTimeMillis();
            float jm = testMathAtan(tests, coords);
            long duration = System.currentTimeMillis() - t;
            double jp = (double) tests / duration;
            t = System.currentTimeMillis();
            float fm = testFastAtan(tests, coords);
            duration = System.currentTimeMillis() - t;
            double fp = (double) tests / duration;
            System.out.println(""Fast atan is "" + fp / jp + "" times faster than java atan"");
        }
    }
"
1525,13160464,13,"    public void shuffle() {
        currentDeckPosition = 0;
        int n = 52;
        while (--n > 0) {
            int k = rand.nextInt(n + 1);
            int temp = deck[n];
            deck[n] = deck[k];
            deck[k] = temp;
        }
    }
"
1732,17621071,13,"    public static synchronized void shuffle(float[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            float temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
"
1837,9210368,13,"    public ThreadChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            ThreadInfo tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
"
96,19654781,13,"    public static void shuffle(double[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            double swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
"
1954,16380022,13,"    public void shuffle(Random rand) {
        for (int i = cards.length - 1; i >= 0; i--) {
            int r = rand.nextInt(i + 1);
            Card t = cards[i];
            cards[i] = cards[r];
            cards[r] = t;
        }
        nextCard = 0;
    }
"
1873,20740028,13,"    public static String computeSignature(List words) {
        if (words.size() == 0) return ""(empty word list)"";
        readCaches();
        firstNew = true;
        int len = words.size() + 1;
        String[] word = new String[len];
        words.toArray(word);
        word[len - 1] = String.valueOf((char) 0xffff);
        Arrays.sort(word);
        List list = new ArrayList();
        String prev = word[0];
        int c = 0;
        for (int i = 0, imax = len; i < imax; i++) {
            String w = word[i];
            if (w.equals(prev)) c++; else {
                int freq = getFreq(prev);
                if (freq < Integer.MAX_VALUE) list.add(new WordFreq(prev, c, freq));
                prev = w;
                c = 1;
            }
        }
        if (list.size() == 0) return ""(no valid words)"";
        WordFreq[] bogus = new WordFreq[0];
        WordFreq[] wordfreq = (WordFreq[]) list.toArray(bogus);
        int validlen = Math.min(SignatureLength, wordfreq.length);
        if (""tfidf"".equals(Algorithm)) {
            Arrays.sort(wordfreq, new byRelFreq());
        } else if (""rarest"".equals(Algorithm)) {
            Arrays.sort(wordfreq, new byWebFreq());
        } else if (""random"".equals(Algorithm)) {
            Random rand = new Random();
            for (int i = 0, imax = validlen; i < imax; i++) {
                int swapi = rand.nextInt(imax);
                WordFreq tmp = wordfreq[i];
                wordfreq[i] = wordfreq[swapi];
                wordfreq[swapi] = tmp;
            }
        } else if (""random100k"".equals(Algorithm)) {
            Random rand = new Random();
            validlen = 0;
            for (int i = 0, imax = wordfreq.length; i < imax; i++) {
                WordFreq tmp = wordfreq[i];
                if (tmp.webcnt < 100000) {
                    int swapi = rand.nextInt(validlen + 1);
                    wordfreq[i] = wordfreq[validlen];
                    wordfreq[validlen] = wordfreq[swapi];
                    wordfreq[swapi] = tmp;
                    validlen++;
                }
            }
            validlen = Math.min(validlen, SignatureLength);
        } else {
            Arrays.sort(wordfreq, new byRoFreq());
        }
        if (DEBUG) {
            System.out.println(""* Rankings *"");
            for (int i = 0; i < Math.min(25, wordfreq.length); i++) System.out.println(wordfreq[i]);
        }
        StringBuffer sigsb = new StringBuffer(100);
        for (int i = 0, imax = validlen; i < imax; i++) {
            if (i > 0) sigsb.append(' ');
            sigsb.append(wordfreq[i].word);
            if (StudyOut != null) StudyOut.print(wordfreq[i].pagecnt + ""/"" + wordfreq[i].webcnt + "" "");
        }
        if (StudyOut != null) StudyOut.println();
        if (Verbose && newwords.size() > 0) {
            System.out.println();
        }
        writeCache();
        return sigsb.substring(0);
    }
"
867,14009710,13,"    public DoubleThresholdGenerator randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            double tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
"
411,426940,44,"    public static boolean isPalindrome(String str) {
        int begin = 0;
        int end = str.length() - 1;
        if (str == null) return false;
        while (begin < (int) (str.length() / 2)) {
            if (str.charAt(begin) != str.charAt(end)) return false; else {
                begin++;
                end--;
            }
        }
        return true;
    }
"
772,531920,44,"    public static boolean isPalindrome(String numberString) {
        if (numberString.length() % 2 == 0) {
            String firstHalf = numberString.substring(0, numberString.length() / 2);
            String secondHalf = numberString.substring(numberString.length() / 2);
            String secondHalfReverse = (new StringBuffer(secondHalf)).reverse().toString();
            return firstHalf.equals(secondHalfReverse);
        }
        return false;
    }
"
2429,244232,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
52,891389,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
965,590962,44,"    private static boolean isPalindrome(String string) {
        for (int k = 0; k < string.length() / 2; k++) {
            if (string.charAt(k) != string.charAt(string.length() - (k + 1))) return false;
        }
        return true;
    }
"
1720,193052,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1055,278438,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
63,165906,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
572,379079,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1133,299388,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
194,513245,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2510,279854,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2595,160204,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2533,3868943,44,"    public static boolean isPalindrome(String word) {
        boolean result = false;
        if (word.length() <= 1) result = true; else if (word.charAt(0) == word.charAt(word.length() - 1)) result = isPalindrome(word.substring(1, word.length() - 1));
        return result;
    }
"
2866,2401,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1505,936423,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2357,314560,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1697,461150,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1094,487412,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1728,241850,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1980,136941,44,"    private static boolean isPalindrome(String sub) {
        int length = sub.length() / 2;
        for (int k = 0; k < length; k++) {
            if (sub.charAt(k) != sub.charAt(sub.length() - k - 1)) return false;
        }
        return true;
    }
"
783,234582,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2894,351289,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
393,174086,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
256,193559,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1370,296921,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
859,541800,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1375,111977,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2089,103828,44,"    public static boolean isPalindrome(String word) {
        int left = 0;
        int right = word.length() - 1;
        while (left < right) {
            if (word.charAt(left) != word.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
"
809,422433,44,"    public static void main(String[] args) throws IOException {
        String strIn;
        StringBuffer original, reversed;
        char charIn;
        int wrapCount = 0;
        int charCount = 0;
        BufferedReader dataIn = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(""Playing with Palindromes\n"");
        System.out.print(""\nEnter a word, or phrase with no punctuation: "");
        strIn = dataIn.readLine();
        while (strIn.length() > 0) {
            original = new StringBuffer(strIn.trim());
            for (int i = 0; i < original.length(); ++i) if (original.charAt(i) == ' ') original.deleteCharAt(i);
            reversed = new StringBuffer(original.toString());
            reversed.reverse();
            if (original.toString().equalsIgnoreCase(reversed.toString())) System.out.println(""Entered string is a palindrome!""); else System.out.println(""Entered string is NOT a palindrome!"");
            System.out.print(""\nEnter a word or phrase with no punctuation: "");
            strIn = dataIn.readLine();
        }
        System.out.println(""Program complete.\n"");
    }
"
51,640608,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
44,853456,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
102,892626,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1584,245664,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2441,776779,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
450,217749,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2418,454856,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1650,917316,44,"    public static void main(String[] args) throws IOException {
        String strIn;
        StringBuffer original, reversed;
        char charIn;
        int wrapCount = 0;
        int charCount = 0;
        BufferedReader dataIn = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(""Playing with Palindromes\n"");
        System.out.print(""\nEnter a word, or phrase with no punctuation: "");
        strIn = dataIn.readLine();
        while (strIn.length() > 0) {
            original = new StringBuffer(strIn.trim());
            for (int i = 0; i < original.length(); ++i) if (original.charAt(i) == ' ') original.deleteCharAt(i);
            reversed = new StringBuffer(original.toString());
            reversed.reverse();
            if (original.toString().equalsIgnoreCase(reversed.toString())) System.out.println(""Entered string is a palindrome!""); else System.out.println(""Entered string is NOT a palindrome!"");
            System.out.print(""\nEnter a word or phrase with no punctuation: "");
            strIn = dataIn.readLine();
        }
        System.out.println(""Program complete.\n"");
    }
"
1047,311165,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
761,120777,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1244,28333,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1777,202150,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
506,207270,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
527,843063,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1075,202241,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2880,298516,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1538,53721,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
790,305471,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2552,910478,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2682,28134,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
144,652689,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1803,913382,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
727,473025,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1321,497855,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1462,801886,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1813,361550,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1149,947100,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2645,694023,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1873,128025,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2827,238319,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1991,10731,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
543,187827,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1572,357575,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2423,157745,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2508,370546,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1114,454280,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1694,45590,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
0,518705,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
203,353067,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2892,681078,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1740,116118,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2683,489465,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1036,403115,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2218,881838,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
650,80860,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2228,812839,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1289,136067,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1752,7760,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2743,928483,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
436,345907,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1907,741288,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1830,714205,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
414,292889,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1674,858381,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2482,53655,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2855,863587,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2539,950313,44,"    private static boolean checkPalindrome(String string) {
        int length = string.length() / 2;
        int fullLength = string.length();
        for (int k = 0; k < length; k++) {
            if (string.charAt(k) != string.charAt(fullLength - 1 - k)) return false;
        }
        return true;
    }
"
289,520192,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1344,162827,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1423,673501,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1783,286788,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
521,739813,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2825,932291,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1234,474315,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
124,718536,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2271,748153,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2447,775734,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1161,63416,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
612,227071,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2095,695789,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2381,605828,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1656,334117,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1220,745910,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
246,661979,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1097,428049,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2811,755766,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
139,789018,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1010,235425,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
929,250687,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2769,13839383,44,"    private boolean isPalindrome(int[] m) {
        for (int i = 0; i < m.length / 2; i++) {
            if (m[i] != m[m.length - 1 - i]) {
                return false;
            }
        }
        return true;
    }
"
141,281236,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
789,124387,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2498,203112,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2370,211684,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2325,911773,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1847,128735,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1352,65492,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2910,396827,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
162,946510,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
533,12934,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2290,563743,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
831,383564,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
644,259442,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
842,59199,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1770,512226,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2778,469060,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1723,157777,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1360,147667,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
321,910688,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1601,10067403,44,"    private boolean isPalindrome(int i) {
        String s = String.valueOf(i);
        return s.equals(StringUtils.reverse(s));
    }
"
2091,281391,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2309,646739,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1442,631361,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
598,359835,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
108,23355904,44,"    public static boolean checkPalindrome(String string) {
        if (string == null) {
            return false;
        }
        String reverse = new StringBuilder(string).reverse().toString();
        if (string.equals(reverse)) {
            return true;
        }
        return false;
    }
"
897,670344,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
318,847422,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1399,8972522,44,"    public static boolean isPalindrome(String stringToTest) {
        String workingCopyString = removeJunk(stringToTest);
        String reversedCopyString = reverse(stringToTest);
        return reversedCopyString.equalsIgnoreCase(workingCopyString);
    }
"
637,689531,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
56,4328782,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1213,242004,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1491,821502,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2783,912096,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
874,820621,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2494,546905,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
43,916273,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1431,682345,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
839,939304,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2639,927500,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2614,801168,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2633,230245,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
3684,3721994,7,"    private void backSpace() {
        int textPos = getTextPosition() - 1;
        if (textPos < 0) return;
        for (int i = textPos; i < text.length - 1; i++) text[i] = text[i + 1];
        text[text.length - 1] = fillValue;
        showText();
        setCaretPosition(textPos + textPos / 2, false, false);
    }
"
8509,12879742,7,"    private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandPronunciation(edu.cmu.sphinx.decoder.linguist.PronunciationState state) {
        Pronunciation pronunciation = state.getPronunciation();
        Unit[] units = pronunciation.getUnits();
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = state;
        for (int i = 0; i < units.length; i++) {
            edu.cmu.sphinx.decoder.linguist.UnitState unitState = null;
            if (i == 0 || i == (units.length - 1)) {
                unitState = new edu.cmu.sphinx.decoder.linguist.UnitState(state, i, units[i]);
            } else {
                Unit[] leftContext = new Unit[1];
                Unit[] rightContext = new Unit[1];
                leftContext[0] = units[i - 1];
                rightContext[0] = units[i + 1];
                Context context = LeftRightContext.get(leftContext, rightContext);
                Unit unit = new Unit(units[i].getName(), units[i].isFiller(), context);
                unitState = new edu.cmu.sphinx.decoder.linguist.UnitState(state, i, unit);
            }
            attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), unitInsertionProbability);
            lastState = expandUnit(unitState);
            if (unitState.getUnit().isSilence()) {
                attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), logMath.getLogOne());
            }
        }
        Unit lastUnit = units[units.length - 1];
        if (addSelfLoopWordEndSilence && !lastUnit.isSilence()) {
            addLoopSilence(lastState, state);
        }
        return lastState;
    }
"
862,403888,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
8874,13478255,7,"    public FuzzyNumber calc(FuzzyNumber af, FuzzyNumber bf) {
        double b[] = bf.data(), a[] = af.data();
        double c[] = new double[b.length];
        double atmp[] = new double[2], btmp[] = new double[2];
        for (int i = 0; i < b.length; i += 3) {
            atmp[0] = a[i];
            atmp[1] = a[i + 1];
            btmp[0] = b[i];
            btmp[1] = b[i + 1];
            double res[] = div(atmp, btmp);
            c[i] = res[0];
            c[i + 1] = res[1];
            c[i + 2] = a[i + 2];
        }
        return new DiscreteNumber(c);
    }
"
13291,20432115,7,"    public void load(String filename) {
        FHimageIDLength = 0;
        FHcolorMapType = 0;
        FHimageType = 0;
        FHcolorMapOrigin = 0;
        FHcolorMapLength = 0;
        FHcolorMapDepth = 0;
        FHimageXOrigin = 0;
        FHimageYOrigin = 0;
        FHwidth = 0;
        FHheight = 0;
        FHbitCount = 0;
        FHimageDescriptor = 0;
        filePointer = 0;
        InputStream dis = ClassLoader.getSystemResourceAsStream(filename);
        try {
            if (dis == null) dis = new FileInputStream(filename);
            fileContents = new byte[dis.available()];
            dis.read(fileContents);
            try {
                dis.close();
            } catch (Exception x) {
            }
            FHimageIDLength = (byte) readUnsignedByte();
            FHcolorMapType = (byte) readUnsignedByte();
            FHimageType = (byte) readUnsignedByte();
            FHcolorMapOrigin = readShort();
            FHcolorMapLength = readShort();
            FHcolorMapDepth = (byte) readUnsignedByte();
            FHimageXOrigin = readShort();
            FHimageYOrigin = readShort();
            FHwidth = readShort();
            FHheight = readShort();
            FHbitCount = (byte) readUnsignedByte();
            FHimageDescriptor = (byte) readUnsignedByte();
            if (FHimageType != 2 && FHimageType != 3) {
                if (FHimageType == 10) loadCompressed();
                fileContents = null;
                return;
            }
            int bytesPerPixel = (FHbitCount / 8);
            data = new byte[FHwidth * FHheight * bytesPerPixel];
            System.arraycopy(fileContents, filePointer, data, 0, data.length);
            if (FHbitCount == 24 || FHbitCount == 32) {
                for (int loop = 0; loop < data.length; loop += bytesPerPixel) {
                    byte btemp = data[loop];
                    data[loop] = data[loop + 2];
                    data[loop + 2] = btemp;
                }
            }
            fileContents = null;
        } catch (Exception x) {
            x.printStackTrace();
            System.out.println(x.getMessage());
        }
    }
"
3547,3419346,7,"    public int remove_node(NeighborInfo ni) {
        int result = 0;
        int i;
        for (i = 0; i < leaf_pred_count; ++i) {
            if (leaf_preds[i].node_id == ni.node_id) break;
        }
        if (i != leaf_pred_count) {
            result |= REMOVED_PREDECESSOR;
            for (; i < leaf_pred_count - 1; ++i) leaf_preds[i] = leaf_preds[i + 1];
            --leaf_pred_count;
        }
        for (i = 0; i < leaf_succ_count; ++i) {
            if (leaf_succs[i].node_id == ni.node_id) break;
        }
        if (i != leaf_succ_count) {
            result |= REMOVED_SUCCESSOR;
            for (; i < leaf_succ_count - 1; ++i) leaf_succs[i] = leaf_succs[i + 1];
            --leaf_succ_count;
        }
        return result;
    }
"
14719,22891844,7,"    @Override
    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
        if (!f.hasTag(STRING_TAG)) {
            return super.execIdCall(f, cx, scope, thisObj, args);
        }
        int id = f.methodId();
        again: for (; ; ) {
            switch(id) {
                case ConstructorId_charAt:
                case ConstructorId_charCodeAt:
                case ConstructorId_indexOf:
                case ConstructorId_lastIndexOf:
                case ConstructorId_split:
                case ConstructorId_substring:
                case ConstructorId_toLowerCase:
                case ConstructorId_toUpperCase:
                case ConstructorId_substr:
                case ConstructorId_concat:
                case ConstructorId_slice:
                case ConstructorId_equalsIgnoreCase:
                case ConstructorId_match:
                case ConstructorId_search:
                case ConstructorId_replace:
                case ConstructorId_localeCompare:
                case ConstructorId_toLocaleLowerCase:
                    {
                        if (args.length > 0) {
                            thisObj = ScriptRuntime.toObject(scope, ScriptRuntime.toString(args[0]));
                            Object[] newArgs = new Object[args.length - 1];
                            for (int i = 0; i < newArgs.length; i++) newArgs[i] = args[i + 1];
                            args = newArgs;
                        } else {
                            thisObj = ScriptRuntime.toObject(scope, ScriptRuntime.toString(thisObj));
                        }
                        id = -id;
                        continue again;
                    }
                case ConstructorId_fromCharCode:
                    {
                        int N = args.length;
                        if (N < 1) return """";
                        StringBuffer sb = new StringBuffer(N);
                        for (int i = 0; i != N; ++i) {
                            sb.append(ScriptRuntime.toUint16(args[i]));
                        }
                        return sb.toString();
                    }
                case Id_constructor:
                    {
                        String s = (args.length >= 1) ? ScriptRuntime.toString(args[0]) : """";
                        if (thisObj == null) {
                            return new NativeString(s);
                        }
                        return s;
                    }
                case Id_toString:
                case Id_valueOf:
                    return realThis(thisObj, f).string;
                case Id_toSource:
                    {
                        String s = realThis(thisObj, f).string;
                        return ""(new String(\"""" + ScriptRuntime.escapeString(s) + ""\""))"";
                    }
                case Id_charAt:
                case Id_charCodeAt:
                    {
                        String target = ScriptRuntime.toString(thisObj);
                        double pos = ScriptRuntime.toInteger(args, 0);
                        if (pos < 0 || pos >= target.length()) {
                            if (id == Id_charAt) return """"; else return ScriptRuntime.NaNobj;
                        }
                        char c = target.charAt((int) pos);
                        if (id == Id_charAt) return String.valueOf(c); else return ScriptRuntime.wrapInt(c);
                    }
                case Id_indexOf:
                    return ScriptRuntime.wrapInt(js_indexOf(ScriptRuntime.toString(thisObj), args));
                case Id_lastIndexOf:
                    return ScriptRuntime.wrapInt(js_lastIndexOf(ScriptRuntime.toString(thisObj), args));
                case Id_split:
                    return ScriptRuntime.checkRegExpProxy(cx).js_split(cx, scope, ScriptRuntime.toString(thisObj), args);
                case Id_substring:
                    return js_substring(cx, ScriptRuntime.toString(thisObj), args);
                case Id_toLowerCase:
                    return ScriptRuntime.toString(thisObj).toLowerCase(ScriptRuntime.ROOT_LOCALE);
                case Id_toUpperCase:
                    return ScriptRuntime.toString(thisObj).toUpperCase(ScriptRuntime.ROOT_LOCALE);
                case Id_substr:
                    return js_substr(ScriptRuntime.toString(thisObj), args);
                case Id_concat:
                    return js_concat(ScriptRuntime.toString(thisObj), args);
                case Id_slice:
                    return js_slice(ScriptRuntime.toString(thisObj), args);
                case Id_bold:
                    return tagify(thisObj, ""b"", null, null);
                case Id_italics:
                    return tagify(thisObj, ""i"", null, null);
                case Id_fixed:
                    return tagify(thisObj, ""tt"", null, null);
                case Id_strike:
                    return tagify(thisObj, ""strike"", null, null);
                case Id_small:
                    return tagify(thisObj, ""small"", null, null);
                case Id_big:
                    return tagify(thisObj, ""big"", null, null);
                case Id_blink:
                    return tagify(thisObj, ""blink"", null, null);
                case Id_sup:
                    return tagify(thisObj, ""sup"", null, null);
                case Id_sub:
                    return tagify(thisObj, ""sub"", null, null);
                case Id_fontsize:
                    return tagify(thisObj, ""font"", ""size"", args);
                case Id_fontcolor:
                    return tagify(thisObj, ""font"", ""color"", args);
                case Id_link:
                    return tagify(thisObj, ""a"", ""href"", args);
                case Id_anchor:
                    return tagify(thisObj, ""a"", ""name"", args);
                case Id_equals:
                case Id_equalsIgnoreCase:
                    {
                        String s1 = ScriptRuntime.toString(thisObj);
                        String s2 = ScriptRuntime.toString(args, 0);
                        return ScriptRuntime.wrapBoolean((id == Id_equals) ? s1.equals(s2) : s1.equalsIgnoreCase(s2));
                    }
                case Id_match:
                case Id_search:
                case Id_replace:
                    {
                        int actionType;
                        if (id == Id_match) {
                            actionType = RegExpProxy.RA_MATCH;
                        } else if (id == Id_search) {
                            actionType = RegExpProxy.RA_SEARCH;
                        } else {
                            actionType = RegExpProxy.RA_REPLACE;
                        }
                        return ScriptRuntime.checkRegExpProxy(cx).action(cx, scope, thisObj, args, actionType);
                    }
                case Id_localeCompare:
                    {
                        Collator collator = Collator.getInstance(cx.getLocale());
                        collator.setStrength(Collator.IDENTICAL);
                        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);
                        return ScriptRuntime.wrapNumber(collator.compare(ScriptRuntime.toString(thisObj), ScriptRuntime.toString(args, 0)));
                    }
                case Id_toLocaleLowerCase:
                    {
                        return ScriptRuntime.toString(thisObj).toLowerCase(cx.getLocale());
                    }
                case Id_toLocaleUpperCase:
                    {
                        return ScriptRuntime.toString(thisObj).toUpperCase(cx.getLocale());
                    }
                case Id_trim:
                    {
                        String str = ScriptRuntime.toString(thisObj);
                        char[] chars = str.toCharArray();
                        int start = 0;
                        while (start < chars.length && ScriptRuntime.isJSWhitespaceOrLineTerminator(chars[start])) {
                            start++;
                        }
                        int end = chars.length;
                        while (end > start && ScriptRuntime.isJSWhitespaceOrLineTerminator(chars[end - 1])) {
                            end--;
                        }
                        return str.substring(start, end);
                    }
            }
            throw new IllegalArgumentException(String.valueOf(id));
        }
    }
"
251,74585,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
3842,4030760,7,"    private final void deleteRoomAt(int index) {
        for (int i = index; i < events_fill_p; i++) events[i] = events[i + 1];
        events_fill_p--;
    }
"
3425,3178135,7,"    private static <E> void dualPivotQuicksort(final E[] a, final int low, final int high, final Comparator<? super E> cmp) {
        if (high - low < 16) {
            insertionsort0(a, low, high + 1, cmp);
            return;
        }
        final int seventh = (high - low + 1 >>> 3) + (high - low + 1 >>> 6) + 1;
        final int e3 = low + high >>> 1;
        final int e2 = e3 - seventh;
        final int e1 = e2 - seventh;
        final int e4 = e3 + seventh;
        final int e5 = e4 + seventh;
        if (cmp.compare(a[e2], a[e1]) < 0) {
            final E t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (cmp.compare(a[e3], a[e2]) < 0) {
            final E t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (cmp.compare(t, a[e1]) < 0) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (cmp.compare(a[e4], a[e3]) < 0) {
            final E t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (cmp.compare(t, a[e2]) < 0) {
                a[e3] = a[e2];
                a[e2] = t;
                if (cmp.compare(t, a[e1]) < 0) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (cmp.compare(a[e5], a[e4]) < 0) {
            final E t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (cmp.compare(t, a[e3]) < 0) {
                a[e4] = a[e3];
                a[e3] = t;
                if (cmp.compare(t, a[e2]) < 0) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (cmp.compare(t, a[e1]) < 0) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        final E pivot1, pivot2;
        int left = low;
        int right = high;
        if (cmp.compare(pivot1 = a[e2], pivot2 = a[e4]) != 0) {
            a[e2] = a[low];
            a[e4] = a[high];
            while (cmp.compare(a[++left], pivot1) < 0) {
            }
            while (cmp.compare(a[--right], pivot2) > 0) {
            }
            outer: for (int k = left; k <= right; k++) {
                final E ak = a[k];
                if (cmp.compare(ak, pivot1) < 0) {
                    a[k] = a[left];
                    a[left] = ak;
                    left++;
                } else if (cmp.compare(ak, pivot2) > 0) {
                    while (cmp.compare(a[right], pivot2) > 0) {
                        if (right-- == k) break outer;
                    }
                    if (cmp.compare(a[right], pivot1) < 0) {
                        a[k] = a[left];
                        a[left] = a[right];
                        left++;
                    } else {
                        a[k] = a[right];
                    }
                    a[right] = ak;
                    right--;
                }
            }
            a[low] = a[left - 1];
            a[left - 1] = pivot1;
            a[high] = a[right + 1];
            a[right + 1] = pivot2;
            dualPivotQuicksort(a, low, left - 2, cmp);
            dualPivotQuicksort(a, right + 2, high, cmp);
            if (left < e1 && e5 < right) {
                while (cmp.compare(a[left], pivot1) == 0) left++;
                while (cmp.compare(a[right], pivot2) == 0) right--;
                outer: for (int k = left; k <= right; k++) {
                    final E ak = a[k];
                    if (cmp.compare(ak, pivot1) == 0) {
                        a[k] = a[left];
                        a[left] = ak;
                        left++;
                    } else if (cmp.compare(ak, pivot2) == 0) {
                        while (cmp.compare(a[right], pivot2) == 0) {
                            if (right-- == k) break outer;
                        }
                        if (cmp.compare(a[right], pivot1) == 0) {
                            a[k] = a[left];
                            a[left] = pivot1;
                            left++;
                        } else {
                            a[k] = a[right];
                        }
                        a[right] = ak;
                        right--;
                    }
                }
            }
            dualPivotQuicksort(a, left, right, cmp);
        } else {
            for (int k = low; k <= right; k++) {
                if (cmp.compare(a[k], pivot1) == 0) continue;
                final E ak = a[k];
                if (cmp.compare(ak, pivot1) < 0) {
                    a[k] = a[left];
                    a[left] = ak;
                    left++;
                } else {
                    while (cmp.compare(a[right], pivot1) > 0) right--;
                    if (cmp.compare(a[right], pivot1) < 0) {
                        a[k] = a[left];
                        a[left] = a[right];
                        left++;
                    } else {
                        a[k] = pivot1;
                    }
                    a[right] = ak;
                    right--;
                }
            }
            dualPivotQuicksort(a, low, left - 1, cmp);
            dualPivotQuicksort(a, right + 1, high, cmp);
        }
    }
"
11091,16929312,7,"    public Tile useTile(int i) {
        if ((tray[i] == null) || (i >= TRAY_SIZE) || (i < 0)) return null;
        Tile t = tray[i];
        for (int j = i; j < getNumUnusedTiles() - 1; j++) tray[j] = tray[j + 1];
        tray[getNumUnusedTiles() - 1] = null;
        setNumUnusedTiles(getNumUnusedTiles() - 1);
        return t;
    }
"
9887,14883249,7,"    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException(""You can't remove an item until you've done at least one next()"");
        }
        if (list[position - 1] != null) {
            for (int i = position - 1; i < (list.length - 1); i++) {
                list[i] = list[i + 1];
            }
            list[list.length - 1] = null;
        }
    }
"
9936,14958336,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
"
14870,23169453,7,"    public Result invoke(Session session, Object[] data, Object[] aggregateData, boolean push) {
        Result result;
        if (push) {
            session.sessionContext.push();
        }
        if (isPSM()) {
            try {
                session.sessionContext.routineArguments = data;
                session.sessionContext.routineVariables = ValuePool.emptyObjectArray;
                if (variableCount > 0) {
                    session.sessionContext.routineVariables = new Object[variableCount];
                }
                result = statement.execute(session);
                if (aggregateData != null) {
                    for (int i = 0; i < aggregateData.length; i++) {
                        aggregateData[i] = data[i + 1];
                    }
                }
            } catch (Throwable e) {
                result = Result.newErrorResult(e);
            }
        } else {
            if (isAggregate) {
                data = convertArgsToJava(session, data);
            }
            result = invokeJavaMethod(session, data);
            if (isAggregate) {
                Object[] callResult = new Object[data.length];
                convertArgsToSQL(session, callResult, data);
                for (int i = 0; i < aggregateData.length; i++) {
                    aggregateData[i] = callResult[i + 1];
                }
            }
        }
        if (push) {
            session.sessionContext.pop();
        }
        return result;
    }
"
1254,589679,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
4374,5002810,7,"    private void ordenaPorNdGrupos(boolean inverso) {
        if (inverso) {
            for (int x = materias.length - 2; x >= 0; x--) for (int y = x; y <= materias.length - 2; y++) {
                if (materias[y].length < materias[y + 1].length) {
                    Grupo tmp[] = materias[y];
                    materias[y] = materias[y + 1];
                    materias[y + 1] = tmp;
                } else break;
            }
        } else {
            for (int x = materias.length - 2; x >= 0; x--) for (int y = x; y <= materias.length - 2; y++) {
                if (materias[y].length > materias[y + 1].length) {
                    Grupo tmp[] = materias[y];
                    materias[y] = materias[y + 1];
                    materias[y + 1] = tmp;
                } else break;
            }
        }
    }
"
5079,5818876,7,"    private int[] push(int[] ind, int sub) {
        int[] new_ind = new int[ind.length - 1];
        if (sub == 0) {
            for (int i = 0; i < ind.length - 1; i++) new_ind[i] = ind[i + 1];
        } else if (sub == ind.length) {
            for (int i = 0; i < ind.length - 1; i++) new_ind[i] = ind[i];
        } else {
            for (int i = 0; i < sub; i++) new_ind[i] = ind[i];
            for (int i = sub; i < ind.length - 1; i++) new_ind[i] = ind[i + 1];
        }
        return new_ind;
    }
"
12333,19135765,7,"    void executeCommand(String[] cmd) {
        boolean result;
        CommandHandler handler;
        if (cmd[0].equals(helpCommand)) {
            if (cmd.length == 1) printAvailableCommands(); else {
                for (int i = 0; i < handlers.size(); i++) {
                    handler = (CommandHandler) handlers.elementAt(i);
                    if (handler.getCommandName().equals(cmd[1])) {
                        handler.printCommandHelp(System.out, CommandHandler.longHelp);
                    }
                }
            }
            return;
        }
        for (int i = 0; i < handlers.size(); i++) {
            handler = (CommandHandler) handlers.elementAt(i);
            if (handler.getCommandName().equals(cmd[0])) {
                String[] cmdArgs = new String[cmd.length - 1];
                for (int j = 0; j < cmdArgs.length; j++) cmdArgs[j] = cmd[j + 1];
                try {
                    System.out.println();
                    result = handler.processCommand(cmdArgs, orb, System.out);
                    if (result == CommandHandler.parseError) {
                        handler.printCommandHelp(System.out, CommandHandler.longHelp);
                    }
                    System.out.println();
                } catch (Exception ex) {
                }
                return;
            }
        }
        printAvailableCommands();
    }
"
8495,12860887,7,"    private void fixLinkages() {
        int i, j;
        for (i = 0; i < MAX_LINK && pano_id_link[i] != null; i++) {
            if (pano_id_link[i].equals(mPanoIdPrev)) {
                for (j = i; j < MAX_LINK; j++) {
                    pano_id_link[j] = pano_id_link[j + 1];
                }
                break;
            }
        }
        if (pano_id_link[0] == null) {
            pano_id_link[0] = mPanoIdPrev;
        }
        if (pano_id_link[1] == null) {
            pano_id_link[1] = pano_id_link[0];
        }
    }
"
5646,6760292,7,"    public int removePlayer(Player pl) {
        if (pl == null || num_players == 0 || num_filled == 0) {
            System.out.println(""ERROR: null player or no players in BattleGame.removePlayer"");
            return BG_STATUS_NOADD;
        }
        int idx = getPlayerIndex(pl.getPlayerID());
        if (idx >= 0 && idx < num_filled) {
            for (int i = idx; i < (num_filled - 1); i++) {
                players[i] = players[i + 1];
            }
            players[num_filled - 1] = null;
            num_filled--;
        }
        status = BG_STATUS_AWAIT;
        return status;
    }
"
3015,2438827,7,"    public int[] getStateSequence(double[][] ob) {
        int l = ob.length;
        int stateCount = stProb.length;
        int[][] top = new int[l][stateCount];
        double[][] d = new double[l][stateCount];
        for (int i = 0; i < stateCount; i++) {
            d[0][i] = stProb[i] + getLogDensity(i, ob[0]);
        }
        for (int t = 1; t < l; t++) {
            for (int i = 0; i < stateCount; i++) {
                double max = -Double.MAX_VALUE;
                int top_state = -1;
                for (int j = 0; j < stateCount; j++) {
                    double v = d[t - 1][j] + transProb[j][i];
                    if (v > max) {
                        max = v;
                        top_state = j;
                    }
                }
                d[t][i] = max + getLogDensity(i, ob[t]);
                top[t][i] = top_state;
            }
        }
        int[] seq = new int[l];
        double max = -Double.MAX_VALUE;
        int maxi = -1;
        for (int i = 0; i < stateCount; i++) {
            double v = d[l - 1][i];
            if (v > max) {
                max = v;
                maxi = i;
            }
        }
        seq[l - 1] = maxi;
        for (int t = l - 2; t >= 0; t--) {
            seq[t] = top[t + 1][seq[t + 1]];
        }
        return seq;
    }
"
11910,18402828,7,"        private void shiftLeft(long[] arr) {
            for (int i = 0; i < arr.length - 1; i++) {
                arr[i] = arr[i + 1];
            }
        }
"
13487,20639772,7,"    private void sortKey(String[] names) {
        for (int i = 0; i + 1 < names.length; i++) {
            if (names[i].compareTo(names[i + 1]) > 0) {
                String temp = names[i];
                names[i] = names[i + 1];
                names[i + 1] = temp;
                int j = i;
                boolean done = false;
                while (j != 0 && !done) {
                    if (names[j].compareTo(names[j - 1]) < 0) {
                        temp = names[j];
                        names[j] = names[j - 1];
                        names[j - 1] = temp;
                    } else done = true;
                    j--;
                }
            }
        }
    }
"
2554,1828887,7,"    public static String[] getReferenceFileNames(String configFile) throws IOException {
        String[] referenceFiles = null;
        LineReader reader = new LineReader(configFile);
        try {
            for (String line : reader) {
                line = line.trim();
                if (Regex.commentOrEmptyLine.matches(line)) continue;
                if (line.indexOf(""="") == -1) {
                    String[] fds = Regex.spaces.split(line);
                    if (""oracle"".equals(fds[0]) && fds.length >= 3) {
                        referenceFiles = new String[fds.length - 2];
                        for (int i = 0; i < referenceFiles.length; i++) referenceFiles[i] = fds[i + 1].trim();
                    }
                }
            }
        } finally {
            reader.close();
        }
        return referenceFiles;
    }
"
7889,11138641,7,"    protected void process() {
        int i, j, k, m, ch, off;
        int len, chunkLength;
        long progOff, progLen;
        float f1, f2, f3;
        double d1, d4;
        AudioFile inF = null;
        AudioFile nOutF = null;
        AudioFile tOutF = null;
        AudioFile eOutF = null;
        AudioFileDescr inStream = null;
        AudioFileDescr nOutStream = null;
        AudioFileDescr tOutStream = null;
        AudioFileDescr eOutStream = null;
        float[][] inBuf = null;
        float[][] nOutBuf = null;
        float[][] tOutBuf = null;
        float[][] eOutBuf = null;
        float[] convBuf1, fftBuf, weightBuf, window, wincorr, maxima;
        int[] maximaPos;
        int numMaxima;
        int inLength, inChanNum, outLength, outChanNum;
        int framesRead, framesWritten;
        int fftLength, frameLength, winStep;
        double totalTilt, totalNoise, totalEnergy;
        boolean outNoise, outTilt, outEnergy;
        MessageFormat msgForm;
        Object[] msgArgs = new Object[1];
        PathField ggOutput;
        topLevel: try {
            inF = AudioFile.openAsRead(new File(pr.text[PR_INPUTFILE]));
            inStream = inF.getDescr();
            inChanNum = inStream.channels;
            inLength = (int) inStream.length;
            if (inLength * inChanNum < 1) throw new EOFException(ERR_EMPTY);
            if (!threadRunning) break topLevel;
            outChanNum = inChanNum;
            outNoise = pr.bool[PR_OUTNOISE];
            outTilt = pr.bool[PR_OUTTILT];
            outEnergy = pr.bool[PR_OUTENERGY];
            if (!outNoise && !outTilt && !outEnergy) throw new IOException(ERR_NOOUTPUT);
            if (outNoise) {
                ggOutput = (PathField) gui.getItemObj(GG_NOUTPUTFILE);
                if (ggOutput == null) throw new IOException(ERR_MISSINGPROP);
                nOutStream = new AudioFileDescr(inStream);
                nOutStream.channels = outChanNum;
                ggOutput.fillStream(nOutStream);
                nOutF = AudioFile.openAsWrite(nOutStream);
                if (!threadRunning) break topLevel;
            }
            if (outTilt) {
                ggOutput = (PathField) gui.getItemObj(GG_TOUTPUTFILE);
                if (ggOutput == null) throw new IOException(ERR_MISSINGPROP);
                tOutStream = new AudioFileDescr(inStream);
                tOutStream.channels = outChanNum;
                ggOutput.fillStream(tOutStream);
                tOutF = AudioFile.openAsWrite(tOutStream);
                if (!threadRunning) break topLevel;
            }
            if (outEnergy) {
                ggOutput = (PathField) gui.getItemObj(GG_EOUTPUTFILE);
                if (ggOutput == null) throw new IOException(ERR_MISSINGPROP);
                eOutStream = new AudioFileDescr(inStream);
                eOutStream.channels = outChanNum;
                ggOutput.fillStream(eOutStream);
                eOutF = AudioFile.openAsWrite(eOutStream);
                if (!threadRunning) break topLevel;
            }
            frameLength = 32 << pr.intg[PR_FRAMESIZE];
            fftLength = frameLength << 1;
            winStep = frameLength >> pr.intg[PR_OVERLAP];
            numMaxima = frameLength >> 7;
            outLength = (inLength + winStep - 1) / winStep;
            inBuf = new float[inChanNum][frameLength];
            nOutBuf = new float[outChanNum][8];
            tOutBuf = new float[outChanNum][8];
            eOutBuf = new float[outChanNum][8];
            fftBuf = new float[fftLength + 2];
            window = Filter.createFullWindow(frameLength, Filter.WIN_HAMMING);
            wincorr = new float[frameLength];
            maxima = new float[numMaxima];
            maximaPos = new int[numMaxima];
            totalTilt = 0.0;
            totalNoise = 0.0;
            totalEnergy = 0.0;
            System.arraycopy(window, 0, fftBuf, 0, frameLength);
            for (i = frameLength; i < fftLength; ) {
                fftBuf[i++] = 0.0f;
            }
            Fourier.realTransform(fftBuf, fftLength, Fourier.FORWARD);
            d1 = 0.0;
            for (i = 0, k = 0; i <= fftLength; ) {
                j = i++;
                f1 = (fftBuf[j] * fftBuf[j] + fftBuf[i] * fftBuf[i]);
                fftBuf[j] = f1;
                d1 += f1;
                fftBuf[i++] = 0.0f;
            }
            Fourier.realTransform(fftBuf, fftLength, Fourier.INVERSE);
            Util.mult(fftBuf, 0, frameLength, 1.0f / fftBuf[0]);
            f1 = fftBuf[0];
            for (i = 1; i < frameLength; i++) {
                f1 = ((float) (frameLength - i) / (float) frameLength) / fftBuf[i];
                if (f1 > 500f) break;
                wincorr[i] = f1;
            }
            for (; i < frameLength; i++) {
                wincorr[i] = 500f;
            }
            weightBuf = new float[frameLength + 1];
            f1 = (float) inStream.rate / 2;
            for (i = 0; i <= frameLength; i++) {
                weightBuf[i] = (float) i / (float) frameLength * f1;
            }
            Filter.getDBAweights(weightBuf, weightBuf, frameLength + 1);
            for (i = 0; i <= frameLength; i++) {
                weightBuf[i] *= weightBuf[i];
            }
            progOff = 0;
            progLen = (long) inLength + (long) outLength;
            framesWritten = 0;
            framesRead = 0;
            off = 0;
            while (threadRunning && (framesWritten < outLength)) {
                len = Math.min(inLength - framesRead, frameLength - off);
                chunkLength = len + off;
                inF.readFrames(inBuf, off, len);
                framesRead += len;
                progOff += len;
                setProgression((float) progOff / (float) progLen);
                if (!threadRunning) break topLevel;
                if (chunkLength < frameLength) {
                    for (ch = 0; ch < inChanNum; ch++) {
                        convBuf1 = inBuf[ch];
                        for (i = chunkLength; i < frameLength; i++) {
                            convBuf1[i] = 0.0f;
                        }
                    }
                }
                for (ch = 0; ch < inChanNum; ch++) {
                    convBuf1 = inBuf[ch];
                    System.arraycopy(convBuf1, 0, fftBuf, 0, frameLength);
                    Util.mult(window, 0, fftBuf, 0, frameLength);
                    for (i = frameLength; i < fftLength; ) {
                        fftBuf[i++] = 0.0f;
                    }
                    Fourier.realTransform(fftBuf, fftLength, Fourier.FORWARD);
                    d1 = 0.0;
                    d4 = 0.0;
                    for (i = 0, k = 0; i <= fftLength; k++) {
                        j = i++;
                        f1 = (fftBuf[j] * fftBuf[j] + fftBuf[i] * fftBuf[i]) * weightBuf[k];
                        d4 += f1;
                        if (outTilt) {
                            d1 += f1 * k;
                        }
                        fftBuf[j] = f1;
                        fftBuf[i++] = 0.0f;
                    }
                    if (outTilt) {
                        if (d4 > 0.0) {
                            f1 = (float) (d1 / (d4 * frameLength));
                        } else {
                            f1 = 0.5f;
                        }
                        tOutBuf[ch][0] = f1;
                        totalTilt += f1;
                    }
                    if (outEnergy) {
                        f1 = Math.min(1.0f, (float) (Math.sqrt(d4) / frameLength));
                        eOutBuf[ch][0] = f1;
                        totalEnergy += f1;
                    }
                    if (outNoise) {
                        Fourier.realTransform(fftBuf, fftLength, Fourier.INVERSE);
                        f1 = fftBuf[0];
                        if (f1 > 0.0f) {
                            Util.mult(fftBuf, 0, frameLength, 1.0f / f1);
                            Util.mult(wincorr, 0, fftBuf, 0, frameLength);
                            Util.clear(maxima);
                            for (i = 0; i < numMaxima; i++) {
                                maximaPos[i] = frameLength;
                            }
                            fftBuf[fftLength] = 0f;
                            f2 = 1.1f;
                            d1 = 0.0;
                            for (i = 0; i < frameLength; i++) {
                                f3 = fftBuf[i];
                                if ((f3 > f2) && (f3 > fftBuf[i + 1]) && (f3 > 0.0f)) {
                                    if (f3 > maxima[0]) {
                                        for (j = 1; j < numMaxima; j++) {
                                            if (f3 <= maxima[j]) break;
                                        }
                                        j--;
                                        for (k = 0; k < j; k++) {
                                            maxima[k] = maxima[k + 1];
                                            maximaPos[k] = maximaPos[k + 1];
                                        }
                                        maxima[j] = f3;
                                        maximaPos[j] = i;
                                    }
                                }
                                f2 = f3;
                            }
                            d1 += maxima[0] / 2.0f * (frameLength - maximaPos[0]);
                            f1 = 1.0f;
                            j = 0;
                            do {
                                m = -1;
                                k = frameLength;
                                for (i = 0; i < numMaxima; i++) {
                                    if (maximaPos[i] < k) {
                                        k = maximaPos[i];
                                        m = i;
                                    }
                                }
                                if (m < 0) break;
                                d1 += (f1 + maxima[m]) / 2.0f * (maximaPos[m] - j);
                                j = maximaPos[m];
                                f1 = maxima[m];
                                maximaPos[m] = frameLength;
                            } while (true);
                            f1 = 1.13f - ((float) d1 * 2.1f / frameLength);
                            f1 = Math.min(1.0f, Math.max(0.0f, f1 * f1));
                        } else {
                            f1 = 0.0f;
                        }
                        nOutBuf[ch][0] = f1;
                        totalNoise += f1;
                    }
                }
                if (outTilt) {
                    tOutF.writeFrames(tOutBuf, 0, 1);
                }
                if (outNoise) {
                    nOutF.writeFrames(nOutBuf, 0, 1);
                }
                if (outEnergy) {
                    eOutF.writeFrames(eOutBuf, 0, 1);
                }
                framesWritten++;
                progOff++;
                setProgression((float) progOff / (float) progLen);
                if (!threadRunning) break topLevel;
                off = frameLength - winStep;
                for (ch = 0; ch < inChanNum; ch++) {
                    System.arraycopy(inBuf[ch], winStep, inBuf[ch], 0, off);
                }
            }
            if (!threadRunning) break topLevel;
            if (outNoise) {
                msgArgs[0] = new Double(totalNoise / (outLength * outChanNum) * 100);
                msgForm = new MessageFormat(PTRN_NOISE);
                msgForm.setLocale(Locale.US);
                msgForm.applyPattern(PTRN_NOISE);
                System.out.println(msgForm.format(msgArgs));
            }
            if (outTilt) {
                msgArgs[0] = new Double(totalTilt / (outLength * outChanNum) * (inStream.rate / 2));
                msgForm = new MessageFormat(PTRN_TILT);
                msgForm.setLocale(Locale.US);
                msgForm.applyPattern(PTRN_TILT);
                System.out.println(msgForm.format(msgArgs));
            }
            if (outEnergy) {
                msgArgs[0] = new Double(20 * Math.log(totalEnergy / (outLength * outChanNum)) / Constants.ln10);
                msgForm = new MessageFormat(PTRN_ENERGY);
                msgForm.setLocale(Locale.US);
                msgForm.applyPattern(PTRN_ENERGY);
                System.out.println(msgForm.format(msgArgs));
            }
            inF.close();
            inF = null;
            inStream = null;
            if (nOutF != null) {
                nOutF.close();
                nOutF = null;
            }
            if (tOutF != null) {
                tOutF.close();
                tOutF = null;
            }
            if (eOutF != null) {
                eOutF.close();
                eOutF = null;
            }
        } catch (IOException e1) {
            setError(e1);
        } catch (OutOfMemoryError e2) {
            inStream = null;
            nOutStream = null;
            tOutStream = null;
            inBuf = null;
            nOutBuf = null;
            tOutBuf = null;
            eOutBuf = null;
            fftBuf = null;
            weightBuf = null;
            window = null;
            wincorr = null;
            System.gc();
            setError(new Exception(ERR_MEMORY));
            ;
        }
        if (inF != null) {
            inF.cleanUp();
        }
        if (nOutF != null) {
            nOutF.cleanUp();
        }
        if (tOutF != null) {
            tOutF.cleanUp();
        }
        if (eOutF != null) {
            eOutF.cleanUp();
        }
    }
"
2909,2263082,7,"    private static void rotate(byte[] key) {
        byte[] x = new byte[64];
        System.arraycopy(key, 0, x, 0, x.length);
        for (int i = 0; i < 55; i++) {
            x[i] = x[i + 1];
        }
        x[27] = key[0];
        x[55] = key[28];
        System.arraycopy(x, 0, key, 0, key.length);
    }
"
3635,3517394,7,"        @Override
        public void update() {
            final double[] dx = new double[n - 1];
            final double[] S = new double[n - 1];
            double[] tmp = new double[n];
            for (int i = 0; i < n - 1; ++i) {
                dx[i] = vx_[i + 1] - vx_[i];
                S[i] = (vy_[i + 1] - vy_[i]) / dx[i];
            }
            if (da == CubicInterpolation.DerivativeApprox.Spline) {
                final TridiagonalOperator L = new TridiagonalOperator(n);
                for (int i = 1; i < n - 1; ++i) {
                    L.setMidRow(i, dx[i], 2.0 * (dx[i] + dx[i - 1]), dx[i - 1]);
                    tmp[i] = 3.0 * (dx[i] * S[i - 1] + dx[i - 1] * S[i]);
                }
                switch(leftType) {
                    case NotAKnot:
                        L.setFirstRow(dx[1] * (dx[1] + dx[0]), (dx[0] + dx[1]) * (dx[0] + dx[1]));
                        tmp[0] = S[0] * dx[1] * (2.0 * dx[1] + 3.0 * dx[0]) + S[1] * dx[0] * dx[0];
                        break;
                    case FirstDerivative:
                        L.setFirstRow(1.0, 0.0);
                        tmp[0] = leftValue;
                        break;
                    case SecondDerivative:
                        L.setFirstRow(2.0, 1.0);
                        tmp[0] = 3.0 * S[0] - leftValue * dx[0] / 2.0;
                        break;
                    case Periodic:
                    case Lagrange:
                        throw new LibraryException(""this end condition is not implemented yet"");
                    default:
                        throw new LibraryException(""unknown end condition"");
                }
                switch(rightType) {
                    case NotAKnot:
                        L.setLastRow(-(dx[n - 2] + dx[n - 3]) * (dx[n - 2] + dx[n - 3]), -dx[n - 3] * (dx[n - 3] + dx[n - 2]));
                        tmp[n - 1] = -S[n - 3] * dx[n - 2] * dx[n - 2] - S[n - 2] * dx[n - 3] * (3.0 * dx[n - 2] + 2.0 * dx[n - 3]);
                        break;
                    case FirstDerivative:
                        L.setLastRow(0.0, 1.0);
                        tmp[n - 1] = rightValue;
                        break;
                    case SecondDerivative:
                        L.setLastRow(1.0, 2.0);
                        tmp[n - 1] = 3.0 * S[n - 2] + rightValue * dx[n - 2] / 2.0;
                        break;
                    case Periodic:
                    case Lagrange:
                        throw new LibraryException(""this end condition is not implemented yet"");
                    default:
                        throw new LibraryException(""unknown end condition"");
                }
                tmp = L.solveFor(tmp);
            } else {
                if (n == 2) {
                    tmp[0] = tmp[1] = S[0];
                } else {
                    switch(da) {
                        case FourthOrder:
                            throw new LibraryException(""FourthOrder not implemented yet"");
                        case Parabolic:
                            throw new LibraryException(""Parabolic not implemented yet"");
                        case ModifiedParabolic:
                            throw new LibraryException(""ModifiedParabolic not implemented yet"");
                        case FritschButland:
                            throw new LibraryException(""FritschButland not implemented yet"");
                        case Akima:
                            throw new LibraryException(""Akima not implemented yet"");
                        case Kruger:
                            for (int i = 1; i < n - 1; ++i) {
                                if (S[i - 1] * S[i] < 0.0) {
                                    tmp[i] = 0.0;
                                } else {
                                    tmp[i] = 2.0 / (1.0 / S[i - 1] + 1.0 / S[i]);
                                }
                            }
                            tmp[0] = (3.0 * S[0] - tmp[1]) / 2.0;
                            tmp[n - 1] = (3.0 * S[n - 2] - tmp[n - 2]) / 2.0;
                            break;
                        default:
                            throw new LibraryException(""unknown scheme"");
                    }
                }
            }
            Arrays.fill(ma_, false);
            if (monotonic) {
                double correction;
                double pm, pu, pd, M;
                for (int i = 0; i < n; ++i) {
                    if (i == 0) {
                        if (tmp[i] * S[0] > 0.0) {
                            correction = tmp[i] / Math.abs(tmp[i]) * Math.min(Math.abs(tmp[i]), Math.abs(3.0 * S[0]));
                        } else {
                            correction = 0.0;
                        }
                        if (!Closeness.isClose(correction, tmp[i])) {
                            tmp[i] = correction;
                            ma_[i] = true;
                        }
                    } else if (i == n - 1) {
                        if (tmp[i] * S[n - 2] > 0.0) {
                            correction = tmp[i] / Math.abs(tmp[i]) * Math.min(Math.abs(tmp[i]), Math.abs(3.0 * S[n - 2]));
                        } else {
                            correction = 0.0;
                        }
                        if (!Closeness.isClose(correction, tmp[i])) {
                            tmp[i] = correction;
                            ma_[i] = true;
                        }
                    } else {
                        pm = (S[i - 1] * dx[i] + S[i] * dx[i - 1]) / (dx[i - 1] + dx[i]);
                        M = 3.0 * Math.min(Math.min(Math.abs(S[i - 1]), Math.abs(S[i])), Math.abs(pm));
                        if (i > 1) {
                            if ((S[i - 1] - S[i - 2]) * (S[i] - S[i - 1]) > 0.0) {
                                pd = (S[i - 1] * (2.0 * dx[i - 1] + dx[i - 2]) - S[i - 2] * dx[i - 1]) / (dx[i - 2] + dx[i - 1]);
                                if (pm * pd > 0.0 && pm * (S[i - 1] - S[i - 2]) > 0.0) {
                                    M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pd)));
                                }
                            }
                        }
                        if (i < n - 2) {
                            if ((S[i] - S[i - 1]) * (S[i + 1] - S[i]) > 0.0) {
                                pu = (S[i] * (2.0 * dx[i] + dx[i + 1]) - S[i + 1] * dx[i]) / (dx[i] + dx[i + 1]);
                                if (pm * pu > 0.0 && -pm * (S[i] - S[i - 1]) > 0.0) {
                                    M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pu)));
                                }
                            }
                        }
                        if (tmp[i] * pm > 0.0) {
                            correction = tmp[i] / Math.abs(tmp[i]) * Math.min(Math.abs(tmp[i]), M);
                        } else {
                            correction = 0.0;
                        }
                        if (!Closeness.isClose(correction, tmp[i])) {
                            tmp[i] = correction;
                            ma_[i] = true;
                        }
                    }
                }
            }
            for (int i = 0; i < n - 1; ++i) {
                va_[i] = tmp[i];
                vb_[i] = (3.0 * S[i] - tmp[i + 1] - 2.0 * tmp[i]) / dx[i];
                vc_[i] = (tmp[i + 1] + tmp[i] - 2.0 * S[i]) / (dx[i] * dx[i]);
            }
            vp_[0] = 0.0;
            for (int i = 1; i < n - 1; ++i) {
                vp_[i] = vp_[i - 1] + dx[i - 1] * (vy_[i - 1] + dx[i - 1] * (va_[i - 1] / 2.0 + dx[i - 1] * (vb_[i - 1] / 3.0 + dx[i - 1] * vc_[i - 1] / 4.0)));
            }
        }
"
13220,20308090,7,"    public void removeSegment(int location) {
        numSegments--;
        tempTransformGroups = new TransformGroup[numSegments];
        temp = new int[numSegments];
        ChromosomeSegment newSegments[] = new ChromosomeSegment[numSegments];
        TransformGroup newTransformGroups[] = new TransformGroup[numSegments];
        int newPos[] = new int[numSegments];
        int index = locationToIndex(location);
        int deleted = currentPos[index];
        for (int i = 0; i < index; i++) newPos[i] = currentPos[i];
        for (int i = index; i < newPos.length; i++) newPos[i] = currentPos[i + 1];
        for (int i = 0; i < newPos.length; i++) if (newPos[i] > deleted) newPos[i]--;
        for (int i = 0; i < deleted; i++) {
            newSegments[i] = segments[i];
            newTransformGroups[i] = transformGroups[i];
        }
        for (int i = deleted; i < newSegments.length; i++) {
            newSegments[i] = segments[i + 1];
            newTransformGroups[i] = transformGroups[i + 1];
        }
        segments = newSegments;
        transformGroups = newTransformGroups;
        currentPos = newPos;
    }
"
15049,23505758,7,"    private Object remove(int remove) {
        Object removed = values[remove];
        for (int i = remove; i < size; i++) {
            if (i == headers.length - 1) {
                headers[i] = null;
                values[i] = null;
            } else {
                headers[i] = headers[i + 1];
                values[i] = values[i + 1];
            }
        }
        if (remove < size) size--;
        return removed;
    }
"
12540,19498173,7,"    static void unpadArray(double[] source, double[] target) {
        for (int i = 0; i < target.length; i++) {
            target[i] = source[i + 1];
        }
    }
"
9870,14775949,7,"    public AlgorithmData execute(AlgorithmData data) throws AlgorithmException {
        AlgorithmParameters map = data.getParams();
        function = map.getInt(""distance-function"", EUCLIDEAN);
        factor = map.getFloat(""distance-factor"", 1.0f);
        absolute = map.getBoolean(""distance-absolute"", false);
        calculateMeans = map.getBoolean(""calculate-means"", true);
        kmcGenes = map.getBoolean(""kmc-cluster-genes"", true);
        hcl_function = map.getInt(""hcl-distance-function"", EUCLIDEAN);
        hcl_absolute = map.getBoolean(""hcl-distance-absolute"", false);
        int number_of_iterations = map.getInt(""number-of-iterations"", 0);
        int number_of_clusters = map.getInt(""number-of-clusters"", 0);
        boolean hierarchical_tree = map.getBoolean(""hierarchical-tree"", false);
        int method_linkage = map.getInt(""method-linkage"", 0);
        boolean calculate_genes = map.getBoolean(""calculate-genes"", false);
        boolean calculate_experiments = map.getBoolean(""calculate-experiments"", false);
        this.expMatrix = data.getMatrix(""experiment"");
        number_of_genes = this.expMatrix.getRowDimension();
        number_of_samples = this.expMatrix.getColumnDimension();
        this.clusterConvergence = new int[number_of_clusters];
        KMCluster[] clusters;
        FloatMatrix means = null;
        FloatMatrix medians = null;
        FloatMatrix variances = null;
        if (calculateMeans) {
            clusters = calculate(number_of_genes, number_of_clusters, number_of_iterations);
            means = getMeans(clusters);
            variances = getVariances(clusters, means);
        } else {
            clusters = calculateMedians(number_of_genes, number_of_clusters, number_of_iterations);
            medians = getMedians(clusters);
            variances = getVariances(clusters, medians);
        }
        float[] tempConv = new float[clusterConvergence.length];
        for (int i = 0; i < clusterConvergence.length; i++) {
            tempConv[i] = (float) clusterConvergence[i];
        }
        QSort qsort = new QSort(tempConv);
        tempConv = qsort.getSorted();
        int[] sortedClusterIndices = qsort.getOrigIndx();
        int temp;
        for (int i = 0; i < number_of_clusters - 1; i++) {
            for (int j = 0; j < number_of_clusters - 1 - i; j++) {
                if (tempConv[j] == tempConv[j + 1]) {
                    if (clusters[sortedClusterIndices[j]].size() < clusters[sortedClusterIndices[j + 1]].size()) {
                        temp = sortedClusterIndices[j];
                        sortedClusterIndices[j] = sortedClusterIndices[j + 1];
                        sortedClusterIndices[j + 1] = temp;
                    }
                }
            }
        }
        KMCluster[] newClusterOrder = new KMCluster[clusters.length];
        FloatMatrix newMeansMedsOrder = new FloatMatrix(clusters.length, number_of_samples);
        FloatMatrix newVariancesOrder = new FloatMatrix(clusters.length, number_of_samples);
        for (int i = 0; i < clusters.length; i++) {
            newClusterOrder[i] = clusters[sortedClusterIndices[i]];
            newVariancesOrder.A[i] = variances.A[sortedClusterIndices[i]];
            if (calculateMeans) newMeansMedsOrder.A[i] = means.A[sortedClusterIndices[i]]; else newMeansMedsOrder.A[i] = medians.A[sortedClusterIndices[i]];
            clusterConvergence[i] = (int) (tempConv[i]);
        }
        clusters = newClusterOrder;
        variances = newVariancesOrder;
        if (calculateMeans) means = newMeansMedsOrder; else medians = newMeansMedsOrder;
        AlgorithmEvent event = null;
        if (hierarchical_tree) {
            event = new AlgorithmEvent(this, AlgorithmEvent.SET_UNITS, clusters.length, ""Calculate Hierarchical Trees"");
            fireValueChanged(event);
            event.setIntValue(0);
            event.setId(AlgorithmEvent.PROGRESS_VALUE);
            fireValueChanged(event);
        }
        Cluster result_cluster = new Cluster();
        NodeList nodeList = result_cluster.getNodeList();
        int[] features;
        for (int i = 0; i < clusters.length; i++) {
            if (stop) {
                throw new AbortException();
            }
            features = convert2int(clusters[i]);
            Node node = new Node(features);
            nodeList.addNode(node);
            if (hierarchical_tree) {
                node.setValues(calculateHierarchicalTree(features, method_linkage, calculate_genes, calculate_experiments));
                event.setIntValue(i + 1);
                fireValueChanged(event);
            }
        }
        AlgorithmData result = new AlgorithmData();
        result.addCluster(""cluster"", result_cluster);
        if (calculateMeans) result.addMatrix(""clusters_means"", means); else result.addMatrix(""clusters_means"", medians);
        result.addMatrix(""clusters_variances"", variances);
        result.addParam(""iterations"", String.valueOf(getIterations()));
        result.addParam(""converged"", String.valueOf(getConverged()));
        result.addIntArray(""convergence-iterations"", clusterConvergence);
        return result;
    }
"
2009,949832,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
5440,6187603,7,"    private static synchronized double calc_deltaT(double tjd, double tid_acc) {
        Trace.level++;
        Trace.trace(Trace.level, ""SweDate.deltaT(double, double)"");
        double ans = 0., ans2, ans3;
        double p, B = 0., B2, Y = 0., Ygreg, dd;
        int d[] = new int[6];
        int i, iy, k;
        int tabsiz = TABSIZ;
        int tabsiz = init_dt();
        int tabend = TABSTART + tabsiz - 1;
        Y = 2000.0 + (tjd - SwephData.J2000) / 365.25;
        Ygreg = 2000.0 + (tjd - SwephData.J2000) / 365.2425;
        if (Y < TAB2_START) {
            B = (Y - LTERM_EQUATION_YSTART) * 0.01;
            ans = -20 + LTERM_EQUATION_COEFF * B * B;
            ans = adjust_for_tidacc(tid_acc, ans, Y);
            if (Y >= TAB2_START - 100) {
                ans2 = adjust_for_tidacc(tid_acc, dt2[0], TAB2_START);
                B = (TAB2_START - LTERM_EQUATION_YSTART) * 0.01;
                ans3 = -20 + LTERM_EQUATION_COEFF * B * B;
                ans3 = adjust_for_tidacc(tid_acc, ans3, Y);
                dd = ans3 - ans2;
                B = (Y - (TAB2_START - 100)) * 0.01;
                ans = ans - dd * B;
            }
        }
        if (Y >= TAB2_START && Y < TAB2_END) {
            double Yjul = 2000 + (tjd - 2451557.5) / 365.25;
            p = SMath.floor(Yjul);
            iy = (int) ((p - TAB2_START) / TAB2_STEP);
            dd = (Yjul - (TAB2_START + TAB2_STEP * iy)) / TAB2_STEP;
            ans = dt2[iy] + (dt2[iy + 1] - dt2[iy]) * dd;
            ans = adjust_for_tidacc(tid_acc, ans, Y);
        }
        if (Y >= TAB2_END && Y < TABSTART) {
            B = TABSTART - TAB2_END;
            iy = (TAB2_END - TAB2_START) / TAB2_STEP;
            dd = (Y - TAB2_END) / B;
            ans = dt2[iy] + dd * (dt[0] / 100.0 - dt2[iy]);
            ans = adjust_for_tidacc(tid_acc, ans, Y);
        }
        if (Y >= TABSTART && Y <= tabend) {
            p = SMath.floor(Y);
            iy = (int) (p - TABSTART);
            ans = dt[iy];
            k = iy + 1;
            if (k >= tabsiz) return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
            p = Y - p;
            ans += p * (dt[k] - dt[iy]);
            if ((iy - 1 < 0) || (iy + 2 >= tabsiz)) return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
            k = iy - 2;
            for (i = 0; i < 5; i++) {
                if ((k < 0) || (k + 1 >= tabsiz)) d[i] = 0; else d[i] = dt[k + 1] - dt[k];
                k += 1;
            }
            for (i = 0; i < 4; i++) d[i] = d[i + 1] - d[i];
            B = 0.25 * p * (p - 1.0);
            ans += B * (d[1] + d[2]);
            if (iy + 2 >= tabsiz) return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
            for (i = 0; i < 3; i++) d[i] = d[i + 1] - d[i];
            B = 2.0 * B / 3.0;
            ans += (p - 0.5) * B * d[1];
            if ((iy - 2 < 0) || (iy + 3 > tabsiz)) return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
            for (i = 0; i < 2; i++) d[i] = d[i + 1] - d[i];
            B = 0.125 * B * (p + 1.0) * (p - 2.0);
            ans += B * (d[0] + d[1]);
        }
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
    }
"
3795,3953792,7,"    public BranchOfSimulativeTest() {
        worldAABB = new AABB();
        worldAABB.lowerBound.set(-100, -100);
        worldAABB.upperBound.set(1500, 1000);
        debugDraw = new AngryPigDebugDraw(WIDTH, HEIGHT, 1.0f);
        mWorld = new World(worldAABB, new Vec2(0f, 40f), true);
        pig1 = new Pig();
        pig1.getSprite().setCenterX(ORIBALLPOSTION.x);
        pig1.getSprite().setCenterY(ORIBALLPOSTION.y);
        birds = new Bird[5];
        birds[0] = new Bird();
        birds[0].createBird(mWorld, 770, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[1] = new Bird();
        birds[1].createBird(mWorld, 800, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[2] = new Bird();
        birds[2].createBird(mWorld, 830, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[3] = new Bird();
        birds[3].createBird(mWorld, 860, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[4] = new Bird();
        birds[4].createBird(mWorld, 890, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        RectWood1 = new RectBaseElement(ResourceManager.getLargeWoodRectangleImages());
        RectWood1.create(mWorld, 700, 580);
        CircleWood2 = new CircleBaseElement(ResourceManager.getMiddleWoodBallImages());
        CircleWood2.create(mWorld, 711, 570, 2f, 0.8f, 0.2f, 10f);
        BattenWood3 = new RectBaseElement(ResourceManager.getShortWoodBattenImages());
        BattenWood3.create(mWorld, 900, 575, MathUtils.PI / 2);
        BattenWood4 = new RectBaseElement(ResourceManager.getBombImage());
        BattenWood4.getSprite().setUpdateTime(80);
        BattenWood4.getSprite().setActive(true);
        BattenWood4.create(mWorld, 930, 575, MathUtils.PI / 2);
        BattenWood5 = new RectBaseElement(ResourceManager.getShortWoodBattenImages());
        BattenWood5.create(mWorld, 915, 550);
        RectWood6 = new RectBaseElement(ResourceManager.getMiddleWoodRectangleImages());
        RectWood6.create(mWorld, 925, 540);
        BattenWood7 = new RectBaseElement(ResourceManager.getSmallWoodSquareImages());
        BattenWood7.create(mWorld, 930, 530);
        CircleWood8 = new CircleBaseElement(ResourceManager.getLargeWoodBallImages());
        CircleWood8.create(mWorld, 932, 510, 2.0f, 0.8f, 0.2f, 18f);
        new Ground(mWorld, 0, GROUND_HEIGHT, WIDTH, HEIGHT);
        nanos = new long[fpsAverageCount];
        long nanosPerFrameGuess = (long) (1000000000.0 / targetFPS);
        nanos[fpsAverageCount - 1] = System.nanoTime();
        for (int i = fpsAverageCount - 2; i >= 0; --i) {
            nanos[i] = nanos[i + 1] - nanosPerFrameGuess;
        }
        nanoStart = System.nanoTime();
        frameRatePeriod = (long) (1000000000.0 / targetFPS);
        add(panel);
    }
"
13707,21039957,7,"    public Object[] getBooleanFuncParams(Object[] params, int nScalarInd) {
        if (Helper.hasNulls(params, 1)) return null;
        if (!XFunction.class.isInstance(params[1])) return null;
        XFunction func = (XFunction) params[1];
        if (!func.getReturnType().equals(Boolean.class)) return null;
        Object[] ret = new Object[params.length - 1];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = params[i + 1];
        }
        if (nScalarInd != -1 && nScalarInd != 0 && Vector.class.isInstance(params[nScalarInd])) {
            Vector cv = (Vector) params[nScalarInd];
            if (cv.size() == 0 || cv.elementAt(0) == null) return null;
            ret[nScalarInd - 1] = cv.elementAt(0);
        }
        return ret;
    }
"
9728,14507597,7,"    public void gradient(double[] x, double[] g) {
        for (int i = 0; i < coefficients; i++) {
            xn[i] = x[i + 1];
            gn[i] = g[i + 1];
        }
        unit.gradient(xn, gn);
        for (int i = 0; i < coefficients; i++) {
            x[i + 1] = xn[i];
            g[i + 1] = gn[i];
        }
    }
"
6803,8810332,7,"    public void remove(int cual) {
        if (cual > howmany) {
            System.out.println(""No es posible extraer un elemento en esa posicin."");
        } else {
            array[cual] = null;
            for (int i = cual; i < array.length - 1; i++) {
                array[i] = array[i + 1];
            }
            array[howmany] = null;
            howmany--;
        }
    }
"
4489,5176682,7,"        void deleteKey(int index) {
            for (int i = index; i < numKeys; i++) {
                key[i] = key[i + 1];
                value[i] = value[i + 1];
                child[i + 1] = child[i + 2];
            }
            numKeys--;
        }
"
11808,18298349,7,"    public DoubleMatrix2D getCloseInInfo(int distance) throws IOException {
        int numSimilarPIs = 0;
        int s = modelElements.size();
        DoubleMatrix2D D = DoubleFactory2D.sparse.make(s, s, 0);
        if (distance < 2) {
            return D;
        }
        Iterator<ProcessInstance> it = log.instanceIterator();
        while (it.hasNext()) {
            ProcessInstance pi = it.next();
            numSimilarPIs = MethodsForWorkflowLogDataStructures.getNumberSimilarProcessInstances(pi);
            int[] memory = new int[distance];
            int i = 0;
            AuditTrailEntryList ates = pi.getAuditTrailEntryList();
            if (ates.size() == 0) {
                continue;
            }
            if (usePOInfo && pi.getAttributes().containsKey(ProcessInstance.ATT_PI_PO) && pi.getAttributes().get(ProcessInstance.ATT_PI_PO).equals(""true"")) {
                HashMap<String, Integer> ateIDMap = new HashMap(ates.size());
                HashMap<String, Integer> iD2Ate = new HashMap(ates.size());
                Iterator<AuditTrailEntry> ateIt = ates.iterator();
                int index = 0;
                while (ateIt.hasNext()) {
                    AuditTrailEntry ate = ateIt.next();
                    ateIDMap.put(ate.getAttributes().get(ProcessInstance.ATT_ATE_ID), new Integer(modelElements.findLogEventNumber(ate.getElement(), ate.getType())));
                    iD2Ate.put(ate.getAttributes().get(ProcessInstance.ATT_ATE_ID), new Integer(index));
                    index++;
                }
                ateIt = ates.iterator();
                while (ateIt.hasNext()) {
                    AuditTrailEntry ate = ateIt.next();
                    int ateIndex = modelElements.findLogEventNumber(ate.getElement(), ate.getType());
                    findCloseIn(ates, ate, ateIndex, distance, ateIDMap, iD2Ate, D, numSimilarPIs, new ArrayList(distance));
                }
            } else {
                Iterator<AuditTrailEntry> ateIt = ates.iterator();
                while (ateIt.hasNext()) {
                    AuditTrailEntry ate = ateIt.next();
                    if (i < distance) {
                        memory[i] = modelElements.findLogEventNumber(ate.getElement(), ate.getType());
                        i++;
                        continue;
                    }
                    int index = modelElements.findLogEventNumber(ate.getElement(), ate.getType());
                    if (memory[0] == index) {
                        for (int j = 0; j < distance; j++) {
                            D.set(index, memory[j], D.get(index, memory[j]) + numSimilarPIs);
                        }
                    }
                    for (int j = 0; j < distance - 1; j++) {
                        memory[j] = memory[j + 1];
                    }
                    memory[distance - 1] = index;
                }
            }
        }
        return D;
    }
"
3679,3721981,7,"    public HexTextbox(Composite parent, int style, int numBytes, char defaultValue) {
        super(parent, style);
        this.numBytes = numBytes;
        this.fillValue = defaultValue;
        this.text = new char[2 * numBytes];
        for (int i = 0; i < text.length; i += 2) text[i] = text[i + 1] = defaultValue;
        errorToolTip = new ToolTip(parent.getShell(), SWT.BALLOON | SWT.ERROR);
        errorToolTip.setText(Messages.getString(""HexTextbox.ErrorToolTip.Title""));
        errorToolTip.setMessage(Messages.getString(""HexTextbox.ErrorToolTip.Message""));
        errorToolTip.setAutoHide(true);
        super.setTextLimit(3 * numBytes - 1);
        showText();
        super.addKeyListener(new HexTextboxKeyListener());
    }
"
14847,23077186,7,"    public static void swapBytes(byte[] b, int off, int len) {
        byte tempByte;
        for (int i = off; i < (off + len); i += 2) {
            tempByte = b[i];
            b[i] = b[i + 1];
            b[i + 1] = tempByte;
        }
    }
"
9830,14665367,7,"    void removeConnection(PolyNode fromMe) {
        boolean isFound = false;
        int foundIndex = -1;
        for (int i = 0; i < nConnected; ++i) {
            if (fromMe == connected[i]) {
                isFound = true;
                foundIndex = i;
                break;
            }
        }
        assert (isFound);
        --nConnected;
        for (int i = foundIndex; i < nConnected; ++i) {
            connected[i] = connected[i + 1];
        }
    }
"
3898,4110169,7,"    protected void removeDuplicates(int numDuplicates) {
        if (indices == null) return;
        if (numDuplicates == 0) for (int i = 1; i < size; i++) if (indices[i - 1] == indices[i]) numDuplicates++;
        if (numDuplicates == 0) return;
        assert (indices.length - numDuplicates > 0) : ""size="" + size + "" indices.length="" + indices.length + "" numDuplicates="" + numDuplicates;
        int[] newIndices = new int[size - numDuplicates];
        double[] newValues = values == null ? null : new double[size - numDuplicates];
        newIndices[0] = indices[0];
        assert (indices.length >= size);
        for (int i = 0, j = 0; i < size - 1; i++) {
            if (indices[i] == indices[i + 1]) {
                if (values != null) newValues[j] += values[i];
            } else {
                newIndices[j] = indices[i];
                if (values != null) newValues[j] += values[i];
                j++;
            }
            if (i == size - 2) {
                if (values != null) newValues[j] += values[i + 1];
                newIndices[j] = indices[i + 1];
            }
        }
        this.indices = newIndices;
        this.values = newValues;
        this.size -= numDuplicates;
        this.maxSortedIndex = size - 1;
    }
"
8610,13076072,7,"    private static int chopspace(byte[] buf, int len) {
        for (int i = 0; i < len; i++) {
            if ('A' <= buf[i] && buf[i] <= 'Z') {
                buf[i] = (byte) ('a' + buf[i] - 'A');
            } else if (buf[i] == ' ') {
                len--;
                for (int j = i; j < len; j++) {
                    buf[j] = buf[j + 1];
                }
                i--;
            }
        }
        return len;
    }
"
2536,1820121,7,"    public double[] extractFeature(double[] samples, double sampling_rate, double[][] other_feature_values) throws Exception {
        double ret[] = new double[10];
        double wk1[] = new double[samples.length];
        double wk2[] = new double[samples.length];
        double wkm[] = new double[num_dimensions];
        wk1[0] = samples[0];
        wk2[samples.length - 2] = samples[samples.length - 1];
        for (int i = 1; i < samples.length - 1; ++i) {
            wk1[i] = samples[i];
            wk2[i - 1] = samples[i];
        }
        for (int i = 0; i < num_dimensions; ++i) {
            double num = 0.0;
            double denom = 0.0;
            for (int j = 0; j < (samples.length - i); ++j) {
                num += wk1[j] * wk2[j];
                denom += wk1[j] * wk1[j] + wk2[j] * wk2[j];
            }
            ret[i] = 2.0 * num / denom;
            for (int j = 0; j < i; ++j) {
                ret[j] = wkm[j] - ret[i] * wkm[i - j];
            }
            for (int j = 0; j <= i; ++j) {
                wkm[j] = ret[j];
            }
            for (int j = 0; j < (samples.length - i - 1); ++j) {
                wk1[j] -= wkm[i] * wk2[j];
                wk2[j] = wk2[j + 1] - wkm[i] * wk1[j + 1];
            }
        }
        return ret;
    }
"
12085,18585843,7,"    protected void transform() {
        if (transformed || nvert <= 0) return;
        if (tvert == null || tvert.length < nvert * 3) tvert = new int[nvert * 3];
        float temp[] = new float[4];
        for (int i = nvert * 3; (i -= 3) >= 0; ) {
            temp[0] = vert[i];
            temp[1] = vert[i + 1];
            temp[2] = vert[i + 2];
            temp[3] = 1.0f;
            float[] newVert = mat.mult(temp);
            tvert[i] = (int) newVert[0];
            tvert[i + 1] = (int) newVert[1];
            tvert[i + 2] = (int) newVert[2];
            transformed = true;
        }
    }
"
6388,8071936,7,"    protected void resolveMessage() {
        String[] lines = message.split(LINE_SEPARATOR);
        header = lines[0];
        if (lines.length > 1) {
            bodyEntities = new String[lines.length - 1];
            for (int i = 0; i < lines.length - 1; i++) {
                bodyEntities[i] = lines[i + 1];
            }
        }
    }
"
6187,7785430,7,"    private void _swapShort() {
        byte i = event[index];
        sevent[index] = event[index + 1];
        sevent[index + 1] = i;
        index += 2;
    }
"
8168,12269404,7,"    private void newCluster() {
        for (int k = 0; k < numClusters; k++) {
            if (k != besti && k != bestj) {
                int ak = alias[k];
                distance[ak][abi] = distance[abi][ak] = updatedDistance(besti, bestj, k);
            }
        }
        distance[abi][abi] = 0.0;
        NodeUtils.joinChilds(getRoot(), besti, bestj);
        for (int i = bestj; i < numClusters - 1; i++) {
            alias[i] = alias[i + 1];
        }
        numClusters--;
    }
"
7412,9984720,7,"    private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandPronunciation(edu.cmu.sphinx.decoder.linguist.PronunciationState state) {
        Pronunciation pronunciation = state.getPronunciation();
        Unit[] units = pronunciation.getUnits();
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = state;
        for (int i = 0; i < units.length; i++) {
            edu.cmu.sphinx.decoder.linguist.UnitState unitState = null;
            if (i == 0 || i == (units.length - 1)) {
                unitState = new edu.cmu.sphinx.decoder.linguist.UnitState(state, i, units[i]);
            } else {
                Unit[] leftContext = new Unit[1];
                Unit[] rightContext = new Unit[1];
                leftContext[0] = units[i - 1];
                rightContext[0] = units[i + 1];
                Context context = LeftRightContext.get(leftContext, rightContext);
                Unit unit = new Unit(units[i].getName(), units[i].isFiller(), context);
                unitState = new edu.cmu.sphinx.decoder.linguist.UnitState(state, i, unit);
            }
            attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), unitInsertionProbability);
            lastState = expandUnit(unitState);
            if (unitState.getUnit().isSilence()) {
                attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), logMath.getLogOne());
            }
        }
        Unit lastUnit = units[units.length - 1];
        if (addSelfLoopWordEndSilence && !lastUnit.isSilence()) {
            addLoopSilence(lastState, state);
        }
        return lastState;
    }
"
4029,4334636,7,"    static GeneticOperator getTwiddleOperator(final EvolutionChamber c) {
        return new GeneticOperator() {

            @Override
            public void operate(Population arg0, List arg1) {
                for (int i = 0; i < arg0.size(); i++) {
                    if (Math.random() > c.getBaseMutationRate() / c.getChromosomeLength()) continue;
                    IChromosome chromosome = (IChromosome) ((ICloneable) arg0.getChromosome(i)).clone();
                    Gene[] beforeArray = chromosome.getGenes();
                    int randomPoint = (int) (Math.random() * beforeArray.length);
                    if (randomPoint < beforeArray.length - 1) {
                        Gene swap = beforeArray[randomPoint];
                        beforeArray[randomPoint] = beforeArray[randomPoint + 1];
                        beforeArray[randomPoint + 1] = swap;
                    }
                    try {
                        chromosome.setGenes(beforeArray);
                    } catch (InvalidConfigurationException e) {
                        StringWriter sw = new StringWriter();
                        e.printStackTrace(new PrintWriter(sw));
                        logger.severe(sw.toString());
                    }
                    arg1.add(chromosome);
                }
            }
        };
    }
"
351,133091,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
411,188502,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
9970,14982354,7,"    protected void shiftRight() {
        for (int i = 0; i < DIGITS - 1; i++) {
            mant[i] = mant[i + 1];
        }
        mant[DIGITS - 1] = 0;
        exp++;
    }
"
4231,4669651,7,"    private Object[] fixContinuedLines(String[] code) {
        int arrayLen = code.length;
        int[] reallines = new int[code.length];
        for (int i = 0; i < reallines.length; i++) reallines[i] = i;
        for (int i = 0; i < arrayLen; i++) {
            if (code[i].endsWith("".."")) {
                if (code.length - 1 > i + 1) {
                    code[i] = code[i].substring(0, code[i].length() - 2) + code[i + 1];
                    arrayLen--;
                    for (int l = i + 1; l < arrayLen; l++) {
                        code[l] = code[l + 1];
                        reallines[l]++;
                    }
                    i--;
                }
            }
        }
        return new Object[] { Arrays.copyOf(code, arrayLen), reallines };
    }
"
6071,7693662,7,"    public LookAndFeelPrefPanel() {
        installExtraLookAndFeels();
        UIManager.LookAndFeelInfo[] installedLnfs = UIManager.getInstalledLookAndFeels();
        LnF[] lnfs = new LnF[installedLnfs.length];
        for (int i = 0; i < lnfs.length; i++) {
            lnfs[i] = new LnF(installedLnfs[i]);
        }
        if ((System.getSecurityManager() != null) && PlatformUtils.isJavaBetterThan(""1.5"")) {
            int gtkIndex = -1;
            for (int i = 0; i < lnfs.length; i++) {
                if (lnfs[i].classname.equals(""com.sun.java.swing.plaf.gtk.GTKLookAndFeel"")) {
                    gtkIndex = i;
                    break;
                }
            }
            if (gtkIndex != -1) {
                LnF[] lnfs2 = new LnF[lnfs.length - 1];
                for (int i = 0; i < gtkIndex; i++) lnfs2[i] = lnfs[i];
                for (int i = gtkIndex; i < lnfs2.length; i++) lnfs2[i] = lnfs[i + 1];
                lnfs = lnfs2;
            }
        }
        this.lookAndFeels = new JList(lnfs);
        String lnfClassName = Jin.getInstance().getPrefs().getString(""lookAndFeel.classname"");
        for (int i = 0; i < lookAndFeels.getModel().getSize(); i++) {
            String classname = ((LnF) lookAndFeels.getModel().getElementAt(i)).classname;
            if (lnfClassName.equals(classname)) {
                lookAndFeels.setSelectedIndex(i);
                lookAndFeels.ensureIndexIsVisible(i);
                break;
            }
        }
        createUI();
    }
"
14546,22486859,7,"    public int demote(Move move, int num) {
        if (num < 0) throw new IllegalArgumentException(""cannot perform negative demotion"");
        Move tmp = null;
        int newIndex = 0;
        int oldIndex = getIndex(move);
        if (oldIndex == -1) throw new NullPointerException(""Move is not a current variation""); else move = branches[oldIndex];
        if (num != 0) newIndex = oldIndex + num; else newIndex = branches.length - 1;
        if (newIndex >= branches.length) throw new ArrayIndexOutOfBoundsException(""Move cannot be demoted beyond the end of the list"");
        for (int i = oldIndex; i < newIndex; i++) {
            branches[i] = branches[i + 1];
        }
        branches[newIndex] = move;
        return newIndex;
    }
"
13974,21224444,7,"            public void drop(DropTargetEvent event) {
                if (event.data == null) {
                    event.detail = DND.DROP_NONE;
                    return;
                }
                ColorItem selectedCanvas2 = getSelectedCanvas();
                if (selectedCanvas2 == null || !isDragging) {
                    return;
                }
                isDragging = false;
                int oldPos = selectedCanvas2.getIndex();
                final int newPos = item.index;
                if ((oldPos < colors.length) && (newPos < colors.length)) {
                    final IProxyColor tmp = colors[oldPos];
                    if (oldPos > newPos) {
                        for (int i = oldPos; i > newPos; i--) {
                            colors[i] = colors[i - 1];
                        }
                        colors[newPos] = tmp;
                    } else {
                        for (int i = oldPos; i < newPos; i++) {
                            colors[i] = colors[i + 1];
                        }
                        colors[newPos] = tmp;
                    }
                    updateColors();
                    isDirty = true;
                }
            }
"
1714,796292,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
11574,17800181,7,"    public String getAdjustedString(String text) {
        String[] tokens = text.toLowerCase().split(""\\s+"");
        for (int i = 0; i < tokens.length - 1; i++) {
            if (tokens[i + 1].equals(""$"")) {
                try {
                    Double.parseDouble(tokens[i]);
                    String num = tokens[i];
                    tokens[i] = tokens[i + 1];
                    tokens[i + 1] = num;
                    i++;
                } catch (NumberFormatException e) {
                }
            }
        }
        List<String> splitTokens = new ArrayList<String>(tokens.length * 2);
        for (String token : tokens) {
            String[] tokenSplits = token.replace(""-"", "" - "").split(""[_ ]"");
            for (String s : tokenSplits) splitTokens.add(s);
        }
        StringBuffer retval = new StringBuffer();
        for (int i = 0; i < splitTokens.size() - 1; i++) {
            retval.append(splitTokens.get(i));
            retval.append(' ');
        }
        retval.append(splitTokens.get(splitTokens.size() - 1));
        return retval.toString();
    }
"
1984,941989,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
"
11957,18476888,7,"    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException(""You can't remove an item until you've done at least one next()"");
        }
        if (list[position - 1] != null) {
            for (int i = position - 1; i < (list.length - 1); i++) {
                list[i] = list[i + 1];
            }
            list[list.length - 1] = null;
        }
    }
"
2498,1800281,7,"    public void randomize(Individual<T> c, int min, int max) {
        IntegerChromosome chrom = (IntegerChromosome) c.getChromosome();
        int len = max - min + 1;
        int[] base = new int[len];
        for (int i = 0; i < len; i++) base[i] = chrom.getValue(min + i);
        int i = 0;
        while (len != 0) {
            int pos = Random.getInstance().nextInt(0, len);
            chrom.setValue(min + i, base[pos]);
            for (int j = pos; j < (len - 1); j++) {
                base[j] = base[j + 1];
            }
            len--;
            i++;
        }
    }
"
9320,14062089,7,"    private static GeneralPathX parseOracleStruct(STRUCT s) throws SQLException {
        GeneralPathX resp = new GeneralPathX();
        ARRAY infoARRAY = null;
        ARRAY ordsARRAY = null;
        Datum[] info_array = null;
        Datum[] ords_array = null;
        int info_array_size = 0;
        int[] start_ind;
        int[] end_ind;
        int dims = 0;
        boolean next_must_do_first = true;
        Datum[] aux = s.getOracleAttributes();
        infoARRAY = (ARRAY) aux[3];
        ordsARRAY = (ARRAY) aux[4];
        dims = ((NUMBER) aux[0]).intValue() / 1000;
        if (dims == 0) {
            dims = 2;
        }
        info_array = (Datum[]) infoARRAY.getOracleArray();
        ords_array = (Datum[]) ordsARRAY.getOracleArray();
        info_array_size = info_array.length / 3;
        int last_index = ords_array.length - dims + 1;
        start_ind = new int[info_array_size];
        end_ind = new int[info_array_size];
        for (int i = 0; i < info_array_size; i++) start_ind[i] = ((NUMBER) info_array[3 * i]).intValue();
        for (int i = 0; i < (info_array_size - 1); i++) end_ind[i] = start_ind[i + 1] - 1;
        end_ind[info_array_size - 1] = last_index;
        int lineType = PathIterator.SEG_LINETO;
        if (end_ind[0] == 0) {
            for (int i = 1; i < info_array_size; i++) {
                lineType = getLineToType(info_array, i);
                next_must_do_first = addOrdsToGPX(resp, start_ind[i] - 1, end_ind[i] - 1, ords_array, dims, lineType, (i == 1), next_must_do_first);
            }
        } else {
            for (int i = 0; i < info_array_size; i++) {
                lineType = getLineToType(info_array, i);
                addOrdsToGPX(resp, start_ind[i] - 1, end_ind[i] - 1, ords_array, dims, lineType, true, true);
            }
        }
        return resp;
    }
"
13738,21047708,7,"    public static H2dRefluxBcManager init(final H2dRefluxSourceInterface _s, final CtuluAnalyze _analyze) {
        final EfFrontierInterface frontieres = _s.getGrid().getFrontiers();
        int ptIdxGlobal;
        final H2dRefluxBcManager r = new H2dRefluxBcManager(_s.getGrid());
        final int n = frontieres.getNbFrontier();
        final RefluxMiddleFrontier[] bordByFrontier = new RefluxMiddleFrontier[n];
        final H2dRefluxBordIndexGeneral[] bordSpecifies = _s.getBords();
        final H2dRefluxBoundaryCondition[] cl3Temp = new H2dRefluxBoundaryCondition[3];
        for (int i = 0; i < n; i++) {
            final int nbPt = frontieres.getNbPt(i);
            final H2dRefluxBoundaryCondition[] cls = new H2dRefluxBoundaryCondition[nbPt];
            for (int j = 1; j < nbPt; j += 2) {
                ptIdxGlobal = frontieres.getIdxGlobal(i, j - 1);
                H2dRefluxBoundaryCondition cl = _s.getConditionLimite(ptIdxGlobal);
                if (cl == null) {
                    if (_analyze != null) {
                        _analyze.addError(H2dResource.getS(""Pas de cl pour le point de bord {0}"", CtuluLibString.getString(ptIdxGlobal)));
                    }
                    final H2dRefluxBoundaryCondition clN = new H2dRefluxBoundaryCondition();
                    clN.setIndexPt(ptIdxGlobal);
                    cls[j - 1] = clN;
                } else {
                    cl.initUsedEvol();
                    cls[j - 1] = cl;
                }
                cl3Temp[0] = cls[j - 1];
                if (j < (nbPt - 1)) {
                    ptIdxGlobal = frontieres.getIdxGlobal(i, j + 1);
                    cl = _s.getConditionLimite(ptIdxGlobal);
                    if (cl == null) {
                        if (_analyze != null) {
                            _analyze.addError(H2dResource.getS(""Pas de cl pour le point de bord {0}"", CtuluLibString.getString(ptIdxGlobal)));
                        }
                        final H2dRefluxBoundaryConditionMutable clN = new H2dRefluxBoundaryConditionMutable();
                        clN.setIndexPt(ptIdxGlobal);
                        cls[j + 1] = clN;
                    } else {
                        cl.initUsedEvol();
                        cls[j + 1] = cl;
                    }
                    cl3Temp[2] = cls[j + 1];
                }
                ptIdxGlobal = frontieres.getIdxGlobal(i, j);
                final H2dRefluxBordIndexGeneral bord = bordSpecifies == null ? null : H2dRefluxBordIndexGeneral.findBordWithIndex(ptIdxGlobal, bordSpecifies);
                H2dBoundaryType bordType = H2dRefluxBoundaryType.SOLIDE;
                cl = _s.getConditionLimite(ptIdxGlobal);
                if (cl == null) {
                    if (_analyze != null) {
                        _analyze.addFatalError(H2dResource.getS(""Pas de cl pour le point de bord {0}"", CtuluLibString.getString(ptIdxGlobal)));
                    }
                    return null;
                }
                if (bord == null) {
                    cl3Temp[1] = cl;
                    if (isOuvert(cl3Temp)) {
                        bordType = H2dRefluxBoundaryType.LIQUIDE;
                    }
                } else {
                    bordType = bord.getBordType();
                }
                if (bord != null && bordType == H2dRefluxBoundaryType.SOLIDE_FROTTEMENT) {
                    cl = new H2dRefluxBoundaryConditionMiddleFriction(cl);
                    cl.setValue(H2dVariableType.RUGOSITE, bord.getRugositeType(), bord.getRugosite(), bord.getRugositeTransitoireCourbe());
                } else {
                    cl = new H2dRefluxBoundaryConditionMiddle(cl, bordType);
                    if (bordType == H2dRefluxBoundaryType.LIQUIDE && cl.getHType() == H2dBcType.LIBRE && cl3Temp[0].getHType() != H2dBcType.LIBRE && cl3Temp[2].getHType() != H2dBcType.LIBRE) {
                        if (cl3Temp[0].getHType() == H2dBcType.PERMANENT && cl3Temp[2].getHType() == H2dBcType.PERMANENT) {
                            cl.setHTypePermanent((cl3Temp[0].getH() + cl3Temp[2].getH()) / 2);
                        } else {
                            if (cl3Temp[0].getHType() == H2dBcType.PERMANENT) {
                                cl.setH(cl3Temp[0].getH());
                            } else {
                                cl.setHTransitoire(cl3Temp[0].getHTransitoireCourbe());
                            }
                        }
                    }
                }
                cl.initUsedEvol();
                cl.setIndexPt(ptIdxGlobal);
                cls[j] = cl;
            }
            bordByFrontier[i] = r.createRefluxMiddleFrontier(i, cls);
        }
        r.bcFrontier_ = bordByFrontier;
        return r;
    }
"
12474,19358127,7,"    private float[] oddOddFiltering(float[] src, int WTTypes) throws ErrorException {
        int subbandSize = src.length;
        int half = subbandSize / 2;
        float dst[] = new float[subbandSize];
        for (int k = 0; k < half; k++) {
            dst[2 * k] = src[k];
            dst[2 * k + 1] = src[half + k + 1];
        }
        dst[subbandSize - 1] = src[half];
        switch(WTTypes) {
            case 1:
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - (float) (Math.floor(((dst[k - 1] + dst[k + 1] + 2) / 4)));
                }
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] + (float) (Math.floor(((dst[k - 1] + dst[k + 1]) / 2)));
                }
                dst[0] = dst[0] + (float) (Math.floor(((dst[1] + dst[1]) / 2)));
                dst[subbandSize - 1] = dst[subbandSize - 1] + (float) (Math.floor(((dst[subbandSize - 2] + dst[subbandSize - 2]) / 2)));
                break;
            case 2:
            case 3:
                final float alfa_97 = -1.586134342059924F;
                final float beta_97 = -0.052980118572961F;
                final float gamma_97 = 0.882911075530934F;
                final float delta_97 = 0.443506852043971F;
                final float nh_97, nl_97;
                if (WTTypes == 2) {
                    nh_97 = 1.230174104914001F;
                    nl_97 = 1F / nh_97;
                } else {
                    nl_97 = 1.14960430535816F;
                    nh_97 = -1F / nl_97;
                }
                for (int k = 0; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] / nh_97;
                    dst[k + 1] = dst[k + 1] / nl_97;
                }
                dst[subbandSize - 1] = dst[subbandSize - 1] / nh_97;
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - delta_97 * (dst[k - 1] + dst[k + 1]);
                }
                dst[subbandSize - 1] = dst[subbandSize - 1] - gamma_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
                dst[0] = dst[0] - gamma_97 * (dst[1] + dst[1]);
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - gamma_97 * (dst[k - 1] + dst[k + 1]);
                }
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - beta_97 * (dst[k - 1] + dst[k + 1]);
                }
                dst[subbandSize - 1] = dst[subbandSize - 1] - alfa_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
                dst[0] = dst[0] - alfa_97 * (dst[1] + dst[1]);
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - alfa_97 * (dst[k - 1] + dst[k + 1]);
                }
                break;
            case 4:
                if (subbandSize >= 6) {
                    final float alfa1 = (9F / 16F);
                    final float alfa2 = (1F / 16F);
                    final float beta = (1F / 4F);
                    for (int k = 1; k < subbandSize; k += 2) {
                        dst[k] = dst[k] + (float) (Math.floor(-beta * (dst[k - 1] + dst[k + 1]) + 0.5));
                    }
                    dst[0] = dst[0] + (float) (Math.floor(alfa1 * (dst[1] + dst[1]) - alfa2 * (dst[3] + dst[3]) + 0.5));
                    dst[2] = dst[2] + (float) (Math.floor(alfa1 * (dst[1] + dst[3]) - alfa2 * (dst[1] + dst[5]) + 0.5));
                    for (int k = 4; k < subbandSize - 3; k += 2) {
                        dst[k] = dst[k] + (float) (Math.floor(alfa1 * (dst[k - 1] + dst[k + 1]) - alfa2 * (dst[k - 3] + dst[k + 3]) + 0.5));
                    }
                    dst[subbandSize - 3] = dst[subbandSize - 3] + (float) (Math.floor(alfa1 * (dst[subbandSize - 4] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 6] + dst[subbandSize - 2]) + 0.5));
                    dst[subbandSize - 1] = dst[subbandSize - 1] + (float) (Math.floor(alfa1 * (dst[subbandSize - 2] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 4] + dst[subbandSize - 4]) + 0.5));
                } else {
                    throw new ErrorException(""Size should be greater or equal than 6 in order to perform 9/7M"");
                }
                break;
            case 7:
                float sample1 = 0, sample2 = 0;
                float normFactor = (float) (Math.sqrt(2));
                for (int k = 0; k < subbandSize - 1; k += 2) {
                    sample1 = dst[k] + dst[k + 1];
                    sample2 = dst[k] - dst[k + 1];
                    dst[k] = sample1 * normFactor;
                    dst[k + 1] = sample2 * normFactor;
                }
                dst[subbandSize - 1] = dst[subbandSize - 1];
                break;
            case 8:
                float s = 0;
                for (int k = 0; k < subbandSize - 1; k += 2) {
                    s = dst[k] - (float) Math.floor(dst[k + 1] / 2);
                    dst[k] = dst[k + 1] + s;
                    dst[k + 1] = s;
                }
                dst[subbandSize - 1] = dst[subbandSize - 1];
                break;
            default:
                throw new ErrorException(""Unrecognized wavelet transform type."");
        }
        return (dst);
    }
"
4919,5629980,7,"    private void processGetContext(final String[] part) {
        if (part.length < GET_CONTEXT_PARTS) {
            usage(GET_CONTEXT);
            return;
        }
        int separator;
        for (separator = 1; separator < part.length; separator++) {
            if (part[separator].equals(""/"")) {
                break;
            }
        }
        if (separator == part.length || separator <= 0) {
            usage(GET_CONTEXT);
            return;
        }
        String[] agents = new String[separator - 1];
        String[] contexts = new String[part.length - 1 - separator];
        for (int i = 0; i < agents.length; i++) {
            agents[i] = part[i + 1];
        }
        int offset = separator + 1;
        for (int i = 0; i < contexts.length; i++) {
            contexts[i] = part[i + offset];
        }
        String reply;
        try {
            reply = cp.getContext(agents, contexts);
        } catch (UnknownContextException e) {
            sendError(e.getMessage());
            return;
        } catch (AgentNotFoundException e) {
            sendError(e.getMessage());
            return;
        }
        send(reply);
    }
"
12624,19635101,7,"    private String[] splitUrl(String url) {
        String[] parts = url.split(""/"");
        if (parts.length == 0) return null;
        if (!parts[0].equalsIgnoreCase("""")) return parts;
        if (parts.length <= 1) return null;
        String[] retParts = new String[parts.length - 1];
        for (int i = 0; i < retParts.length; i++) {
            retParts[i] = parts[i + 1];
        }
        return retParts;
    }
"
4110,4442345,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
"
10451,15924651,7,"    public void removeCharAt(int index) {
        if (index < 0 || index > used) {
            throw new IndexOutOfBoundsException("""" + index);
        }
        used--;
        for (int i = index; i < used; i++) {
            array[i] = array[i + 1];
        }
    }
"
10905,16655474,7,"    private void pushTogether(int hole) {
        for (int i = hole; i < (nKeys - 1); i++) {
            keys[i] = keys[i + 1];
            vals[i] = vals[i + 1];
        }
        nKeys--;
    }
"
14365,22053890,7,"        public void rendezvousFunction(Object[] objects) {
            int lastIdx = objects.length - 1;
            Object first = objects[0];
            for (int i = 0; i < lastIdx; ++i) objects[i] = objects[i + 1];
            objects[lastIdx] = first;
        }
"
8778,13335722,7,"        public E poll() {
            if (isEmpty()) {
                return null;
            }
            E e = (E) elements[0];
            for (int i = 0; i < size - 1; i++) {
                elements[i] = elements[i + 1];
            }
            size--;
            return e;
        }
"
8661,13135770,7,"        public int currentSegment(double[] coords) {
            int retval;
            if (Double.isNaN(points[i])) {
                coords[0] = points[i + 1];
                coords[1] = points[i + 2];
                retval = SEG_MOVETO;
            } else {
                coords[0] = points[i];
                coords[1] = points[i + 1];
                retval = SEG_LINETO;
            }
            if (transform != null) transform.transform(coords, 0, coords, 0, 1);
            return retval;
        }
"
12451,19358125,7,"    private float[] evenOddFiltering(float[] src, int WTTypes) throws ErrorException {
        int subbandSize = src.length;
        int half = subbandSize / 2;
        float dst[] = new float[subbandSize];
        for (int k = 0; k < half; k++) {
            dst[2 * k] = src[k];
            dst[2 * k + 1] = src[half + k];
        }
        switch(WTTypes) {
            case 1:
                dst[subbandSize - 1] = dst[subbandSize - 1] - (float) (Math.floor((dst[subbandSize - 2] + dst[subbandSize - 2] + 2) / 4));
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - (float) (Math.floor(((dst[k - 1] + dst[k + 1] + 2) / 4)));
                }
                dst[0] = dst[0] + (float) (Math.floor(((dst[1] + dst[1]) / 2)));
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] + (float) (Math.floor(((dst[k - 1] + dst[k + 1]) / 2)));
                }
                break;
            case 2:
            case 3:
                final float alfa_97 = -1.586134342059924F;
                final float beta_97 = -0.052980118572961F;
                final float gamma_97 = 0.882911075530934F;
                final float delta_97 = 0.443506852043971F;
                final float nh_97, nl_97;
                if (WTTypes == 2) {
                    nh_97 = 1.230174104914001F;
                    nl_97 = 1F / nh_97;
                } else {
                    nl_97 = 1.14960430535816F;
                    nh_97 = -1F / nl_97;
                }
                for (int k = 0; k < subbandSize; k += 2) {
                    dst[k] = dst[k] / nh_97;
                    dst[k + 1] = dst[k + 1] / nl_97;
                }
                dst[subbandSize - 1] = dst[subbandSize - 1] - delta_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - delta_97 * (dst[k - 1] + dst[k + 1]);
                }
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - gamma_97 * (dst[k - 1] + dst[k + 1]);
                }
                dst[0] = dst[0] - gamma_97 * (dst[1] + dst[1]);
                dst[subbandSize - 1] = dst[subbandSize - 1] - beta_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - beta_97 * (dst[k - 1] + dst[k + 1]);
                }
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - alfa_97 * (dst[k - 1] + dst[k + 1]);
                }
                dst[0] = dst[0] - alfa_97 * (dst[1] + dst[1]);
                break;
            case 4:
                if (subbandSize >= 6) {
                    final float alfa1 = (9F / 16F);
                    final float alfa2 = (1F / 16F);
                    final float beta = (1F / 4F);
                    dst[0] = dst[0] + (float) (Math.floor(-beta * (dst[1] + dst[1]) + 0.5F));
                    for (int k = 2; k < subbandSize; k += 2) {
                        dst[k] = dst[k] + (float) (Math.floor(-beta * (dst[k - 1] + dst[k + 1]) + 0.5F));
                    }
                    dst[1] = dst[1] + (float) (Math.floor(alfa1 * (dst[0] + dst[2]) - alfa2 * (dst[2] + dst[4]) + 0.5F));
                    for (int k = 3; k < subbandSize - 3; k += 2) {
                        dst[k] = dst[k] + (float) (Math.floor(alfa1 * (dst[k - 1] + dst[k + 1]) - alfa2 * (dst[k - 3] + dst[k + 3]) + 0.5F));
                    }
                    dst[subbandSize - 3] = dst[subbandSize - 3] + (float) (Math.floor(alfa1 * (dst[subbandSize - 4] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 6] + dst[subbandSize - 2]) + 0.5F));
                    dst[subbandSize - 1] = dst[subbandSize - 1] + (float) (Math.floor(alfa1 * (dst[subbandSize - 2] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 4] + dst[subbandSize - 4]) + 0.5F));
                } else {
                    throw new ErrorException(""Size should be greater or equal than 6 in order to perform 9/7M"");
                }
                break;
            case 7:
                float sample1 = 0, sample2 = 0;
                float normFactor = (float) (Math.sqrt(2));
                for (int k = 0; k < subbandSize; k += 2) {
                    sample1 = dst[k] + dst[k + 1];
                    sample2 = dst[k] - dst[k + 1];
                    dst[k] = sample1 * normFactor;
                    dst[k + 1] = sample2 * normFactor;
                }
                break;
            case 8:
                float s = 0;
                for (int k = 0; k < subbandSize; k += 2) {
                    s = dst[k] - (float) Math.floor(dst[k + 1] / 2);
                    dst[k] = dst[k + 1] + s;
                    dst[k + 1] = s;
                }
                break;
            default:
                throw new ErrorException(""Unrecognized wavelet transform type."");
        }
        return (dst);
    }
"
6634,8513087,7,"    public Spline(float[] xx, float[] yy) {
        int N = xx.length;
        if (N <= 0) {
            return;
        }
        if ((u == null) || (u.length < N + 1)) {
            x = new float[N + 1];
            y = new float[N + 1];
            u = new float[N + 1];
            d = new float[N + 1];
            p = new float[N + 1];
            w = new float[N + 1];
        }
        x[0] = xx[0];
        y[0] = yy[0];
        for (int i = 0; i < xx.length; i++) {
            x[i + 1] = xx[i];
            y[i + 1] = yy[i];
        }
        for (int i = 2; i < N; i++) {
            d[i] = 2 * (x[i + 1] - x[i - 1]);
        }
        for (int i = 1; i < N; i++) {
            u[i] = x[i + 1] - x[i];
        }
        for (int i = 2; i < N; i++) {
            w[i] = 6 * ((y[i + 1] - y[i]) / u[i] - (y[i] - y[i - 1]) / u[i - 1]);
        }
        p[1] = 0;
        p[N] = 0;
        for (int i = 2; i < N - 1; i++) {
            w[i + 1] -= w[i] * u[i] / d[i];
            d[i + 1] -= u[i] * u[i] / d[i];
        }
        for (int i = N - 1; i > 1; i--) {
            p[i] = (w[i] - u[i] * p[i + 1]) / d[i];
        }
    }
"
14927,23347509,7,"    private int[] decaleMiniListe(int[] liste) {
        if (liste.length != 9) System.exit(45);
        int temp;
        for (int i = 0; i < 8; i++) {
            temp = liste[i];
            liste[i] = liste[i + 1];
            liste[i + 1] = temp;
        }
        return liste;
    }
"
379,155474,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
14984,23365205,7,"        @Override
        public void paint(Graphics g) {
            g2 = (Graphics2D) g;
            g2.drawImage(backgroundBufferImage, 0, 0, null);
            debugDraw.setGraphics(g2);
            Pig launchPig = null;
            if (state != LauncherState.UNAVAILABLE) launchPig = pigs[launch_pig]; else {
                if (launch_pig + 1 < PIG_TOTAL_COUNT) {
                    launchPig = pigs[launch_pig + 1];
                    final int x = ORIBALLPOSTION.x - launchPig.getSprite().getCenterX();
                    final int y = ORIBALLPOSTION.y - launchPig.getSprite().getCenterY();
                    final int z = (int) Math.sqrt(x * x + y * y);
                    launchPig.getSprite().setCenterX(launchPig.getSprite().getCenterX() + 5 * x / z);
                    launchPig.getSprite().setCenterY(launchPig.getSprite().getCenterY() + 5 * y / z);
                    if (launchPig.getSprite().getCenterX() >= ORIBALLPOSTION.x || launchPig.getSprite().getCenterY() <= ORIBALLPOSTION.y) {
                        state = LauncherState.READY;
                        launchPig.getSprite().setCenterX(ORIBALLPOSTION.x);
                        launchPig.getSprite().setCenterY(ORIBALLPOSTION.y);
                        ++launch_pig;
                    }
                }
            }
            if (launchPig != null && (state == LauncherState.BEFORE_LAUNCH || state == LauncherState.READY)) {
                g2.setStroke(new BasicStroke(3f));
                g2.setColor(Color.BLACK);
                g2.drawLine(ROPEPOINT1.x, ROPEPOINT1.y, launchPig.getSprite().getCenterX(), launchPig.getSprite().getCenterY());
            }
            for (Pig pig : pigs) {
                pig.draw(g2);
            }
            for (final Bird bird : birds) {
                bird.draw(g2);
            }
            RectWood1.draw(g2);
            CircleWood2.draw(g2);
            BattenWood3.draw(g2);
            BattenWood4.draw(g2);
            BattenWood5.draw(g2);
            RectWood6.draw(g2);
            CircleWood7.draw(g2);
            synchronized (lock) {
                int size = smears.size();
                for (int i = 0; i < size; i++) {
                    for (Pig pig : pigs) {
                        if (pig.isBinding()) Sprite.draw(g2, movingCloudSprite.getCurFrame(), (int) smears.get(i).x, (int) smears.get(i).y);
                    }
                }
            }
            if (launchPig != null && (state == LauncherState.BEFORE_LAUNCH || state == LauncherState.READY)) {
                g2.drawLine(ROPEPOINT2.x, ROPEPOINT2.y, launchPig.getSprite().getCenterX(), launchPig.getSprite().getCenterY());
            }
            for (int i = 0; i < fpsAverageCount - 1; ++i) {
                nanos[i] = nanos[i + 1];
            }
            nanos[fpsAverageCount - 1] = System.nanoTime();
            float averagedFPS = (float) ((fpsAverageCount - 1) * 1000000000.0 / (nanos[fpsAverageCount - 1] - nanos[0]));
            ++frameCount;
            float totalFPS = (float) (frameCount * 1000000000 / (1.0 * (System.nanoTime() - nanoStart)));
            g2.drawString(""100 Average FPS is "" + averagedFPS, 15, 15);
            g2.drawString(""Entire FPS is "" + totalFPS, 15, 25);
            g2.drawString(""Score: "" + score, 15, 35);
            g2.drawImage(foregroundBufferImage, 0, 0, null);
            if (state == LauncherState.UNAVAILABLE || state == LauncherState.READY) {
                if (state == LauncherState.UNAVAILABLE && elementCount[BIRD_COUNT_OFFSET] > 0 && elementCount[PIG_COUNT_OFFSET] == 0) {
                    gameFail();
                } else if (elementCount[BIRD_COUNT_OFFSET] == 0) {
                    gameWin();
                }
            } else if (state == LauncherState.GAMEOVER_VICTORY || state == LauncherState.GAMEOVER_FAIL) {
                final int OUTER_WIDTH = 640, OUTER_HEIGHT = 480;
                final int INNER_WIDTH = 600, INNER_HEIGHT = 440;
                g2.setColor(new Color(255, 189, 49));
                g2.fillRoundRect((getWidth() - OUTER_WIDTH) / 2, (getHeight() - OUTER_HEIGHT) / 2, OUTER_WIDTH, OUTER_HEIGHT, 30, 30);
                g2.setColor(new Color(100, 209, 184));
                g2.fillRoundRect((getWidth() - INNER_WIDTH) / 2, (getHeight() - INNER_HEIGHT) / 2, INNER_WIDTH, INNER_HEIGHT, 30, 30);
                g2.setColor(Color.WHITE);
                g2.setFont(new Font(""Century Schoolbook L"", Font.ITALIC, 50));
                final FontMetrics fm = g.getFontMetrics();
                final String VictoryText = ""VICTORY!"";
                final String ScoreText = ""Score: "" + score;
                final String FailText = ""GG!"";
                int height, width;
                BufferedImage image;
                if (state == LauncherState.GAMEOVER_VICTORY) {
                    height = fm.getHeight();
                    width = fm.stringWidth(VictoryText);
                    g2.drawString(VictoryText, (getWidth() - width) / 2, (getHeight() - height) / 2 - height);
                    width = fm.stringWidth(ScoreText);
                    g2.drawString(ScoreText, (getWidth() - width) / 2, (getHeight() - height) / 2 + height);
                    image = ResourceManager.getPigVictoryImage();
                } else {
                    height = fm.getHeight();
                    width = fm.stringWidth(FailText);
                    g2.drawString(FailText, (getWidth() - width) / 2, (getHeight() - height) / 2);
                    image = ResourceManager.getPigFailedImage();
                }
                g2.drawImage(image, (getWidth() - image.getWidth()) / 2, (getHeight() - height) / 2 + height + height, null);
            }
            g2.dispose();
        }
"
10780,16571028,7,"    public static void testClassicPerformance(int size) {
        A.syso(""Beginning performance test for size "" + size + ""."");
        long start = System.currentTimeMillis();
        int[] first = new int[size];
        for (int i = 0; i < first.length; ++i) {
            first[i] = (i + 2) * (i + 2);
        }
        while (first.length != 1) {
            int[] second = new int[first.length - 1];
            for (int i = 0; i < second.length; ++i) {
                second[i] = first[i + 1] - first[i];
            }
            first = second;
        }
        int result = first[0];
        long stop = System.currentTimeMillis();
        A.syso(""Time: "" + (stop - start) + "" ms. Result: "" + result + ""."");
    }
"
13282,20383563,7,"    public void updateGeometry(Line shape, List<Vector3f> points, int segments, boolean closed, Vector3f up) {
        int np = points.size();
        if (closed) {
            np = np + 3;
        }
        float d[][] = new float[3][np];
        float x[] = new float[np];
        List<Vector3f> path = new ArrayList<Vector3f>();
        for (int i = 0; i < np; i++) {
            Vector3f p;
            if (!closed) {
                p = points.get(i);
            } else {
                if (i == 0) {
                    p = points.get(points.size() - 1);
                } else if (i >= np - 2) {
                    p = points.get(i - np + 2);
                } else {
                    p = points.get(i - 1);
                }
            }
            x[i] = i;
            d[0][i] = p.x;
            d[1][i] = p.y;
            d[2][i] = p.z;
        }
        if (np > 1) {
            float[][] a = new float[3][np];
            float h[] = new float[np];
            for (int i = 1; i <= np - 1; i++) {
                h[i] = x[i] - x[i - 1];
            }
            if (np > 2) {
                float sub[] = new float[np - 1];
                float diag[] = new float[np - 1];
                float sup[] = new float[np - 1];
                for (int i = 1; i <= np - 2; i++) {
                    diag[i] = (h[i] + h[i + 1]) / 3;
                    sup[i] = h[i + 1] / 6;
                    sub[i] = h[i] / 6;
                    for (int dim = 0; dim < 3; dim++) {
                        a[dim][i] = (d[dim][i + 1] - d[dim][i]) / h[i + 1] - (d[dim][i] - d[dim][i - 1]) / h[i];
                    }
                }
                for (int dim = 0; dim < 3; dim++) {
                    solveTridiag(sub.clone(), diag.clone(), sup.clone(), a[dim], np - 2);
                }
            }
            if (!closed) {
                path.add(new Vector3f(d[0][0], d[1][0], d[2][0]));
            }
            float[] point = new float[3];
            for (int i = closed ? 2 : 1; i <= np - 2; i++) {
                for (int j = 1; j <= segments; j++) {
                    for (int dim = 0; dim < 3; dim++) {
                        float t1 = (h[i] * j) / segments;
                        float t2 = h[i] - t1;
                        float v = ((-a[dim][i - 1] / 6 * (t2 + h[i]) * t1 + d[dim][i - 1]) * t2 + (-a[dim][i] / 6 * (t1 + h[i]) * t2 + d[dim][i]) * t1) / h[i];
                        point[dim] = v;
                    }
                    path.add(new Vector3f(point[0], point[1], point[2]));
                }
            }
        }
        this.updateGeometry(shape, path, closed, up);
    }
"
4127,4488837,7,"    private static int[] createWeights(int length, int base) {
        int[] weights = new int[length];
        weights[length - 1] = 1;
        for (int i = length - 2; i >= 0; i--) weights[i] = weights[i + 1] * base;
        return weights;
    }
"
8371,12595197,7,"    public FixedColumnsParser setFixedColumnsParser(Reader in, String delim) throws IOException {
        BufferedReader reader = new LineNumberReader(in);
        String line;
        line = readFirstRecord(reader);
        reader.close();
        int[] columnOffsets;
        int[] columnWidths;
        int col = 0;
        String[] ss = line.split(delim);
        columnOffsets = new int[ss.length];
        columnWidths = new int[ss.length - 1];
        fieldCount = ss.length;
        fieldParsers = new FieldParser[ss.length - 1];
        boolean rightJustified = false;
        if (ss[0].trim().length() == 0) {
            rightJustified = true;
            for (int i = 0; i < ss.length - 1; i++) {
                ss[i] = ss[i + 1];
            }
        }
        columnOffsets[0] = 0;
        if (rightJustified) {
            for (int i = 1; i < ss.length; i++) {
                col = line.indexOf(ss[i - 1], columnOffsets[i - 1]);
                columnOffsets[i] = col + ss[i - 1].length();
                columnWidths[i - 1] = columnOffsets[i] - columnOffsets[i - 1];
            }
        } else {
            for (int i = 1; i < ss.length; i++) {
                col = line.indexOf(ss[i], col + ss[i - 1].length());
                columnOffsets[i] = col;
                columnWidths[i - 1] = columnOffsets[i] - columnOffsets[i - 1];
            }
        }
        fieldNames = new String[fieldCount];
        for (int i = 1; i < ss.length; i++) {
            fieldParsers[i - 1] = DOUBLE_PARSER;
            fieldNames[i - 1] = ""field"" + (i - 1);
        }
        int[] co = new int[columnWidths.length];
        System.arraycopy(columnOffsets, 0, co, 0, columnWidths.length);
        this.units = new Units[fieldCount];
        for (int i = 0; i < fieldCount; i++) {
            units[i] = Units.dimensionless;
        }
        FixedColumnsParser p = new FixedColumnsParser(co, columnWidths);
        this.recordParser = p;
        this.propertyPattern = null;
        return p;
    }
"
10664,16275150,7,"    public void onDraw(Canvas canvas) {
        Paint myPaint = new Paint();
        myPaint.setColor(0xFFDDDDDD);
        Bitmap bmp = ((AndroidDebugDraw) g).mBitmap;
        bmp.eraseColor(0);
        Vec2.creationCount = 0;
        if (currentTest == null) {
            currentTestIndex = 0;
            currentTest = tests.get(currentTestIndex);
            nanoStart = System.nanoTime();
            frameCount = 0;
        }
        if (currentTest.needsReset) {
            TestSettings s = currentTest.settings;
            currentTest.initialize();
            if (s != null) currentTest.settings = s;
            nanoStart = System.nanoTime();
            frameCount = 0;
        }
        currentTest.m_textLine = AbstractExample.textLineHeight;
        g.drawString(5, currentTest.m_textLine, currentTest.getName(), AbstractExample.white);
        currentTest.m_textLine += 2 * AbstractExample.textLineHeight;
        currentTest.step();
        if (currentTest.settings.drawStats) {
            g.drawString(5, currentTest.m_textLine, ""Vec2 creations/frame: "" + Vec2.creationCount, AbstractExample.white);
            currentTest.m_textLine += AbstractExample.textLineHeight;
        }
        for (int i = 0; i < fpsAverageCount - 1; ++i) {
            nanos[i] = nanos[i + 1];
        }
        nanos[fpsAverageCount - 1] = System.nanoTime();
        float averagedFPS = (float) ((fpsAverageCount - 1) * 1000000000.0 / (nanos[fpsAverageCount - 1] - nanos[0]));
        ++frameCount;
        float totalFPS = (float) (frameCount * 1000000000 / (1.0 * (System.nanoTime() - nanoStart)));
        if (currentTest.settings.drawStats) {
            g.drawString(5, currentTest.m_textLine, ""Average FPS ("" + fpsAverageCount + "" frames): "" + averagedFPS, AbstractExample.white);
            currentTest.m_textLine += AbstractExample.textLineHeight;
            g.drawString(5, currentTest.m_textLine, ""Average FPS (entire test): "" + totalFPS, AbstractExample.white);
            currentTest.m_textLine += AbstractExample.textLineHeight;
        }
        canvas.drawBitmap(bmp, 0, 0, myPaint);
        this.invalidate();
    }
"
735,344390,7,"    private static void shiftleft(int array[], int size) {
        if (size < 1) return;
        int zeroth = array[0];
        for (int i = 0; i < size - 1; ++i) array[i] = array[i + 1];
        array[size - 1] = zeroth;
    }
"
10104,15142980,7,"    public void removePoint() {
        Integer index = datapanel.getPointChosenIndex();
        if (index != null) {
            int newsize = sdata.length - 1;
            int iindex = index.intValue();
            double[] oldsdata = sdata;
            double[] olddata = data;
            double[] tempsdata = new double[newsize];
            double[] tempdata = new double[newsize];
            for (int i = 0; i < newsize; i++) {
                if (i < iindex) {
                    tempsdata[i] = oldsdata[i];
                    tempdata[i] = olddata[i];
                } else {
                    tempsdata[i] = oldsdata[i + 1];
                    tempdata[i] = olddata[i + 1];
                }
            }
            sdata = tempsdata;
            data = tempdata;
            plotData();
        }
    }
"
2201,1243836,7,"    public String[] getFieldList() {
        String[] fieldList = new String[fields.length - 1];
        for (int i = 0; i < fieldList.length; i++) {
            fieldList[i] = fields[i + 1];
        }
        return fieldList;
    }
"
8524,12934517,7,"    public static Object3D extrudeCurve(Curve profile, Curve path, CoordinateSystem profCoords, CoordinateSystem pathCoords, double angle, boolean orient) {
        MeshVertex profVert[] = profile.getVertices(), pathVert[] = path.getVertices();
        Vec3 profv[] = new Vec3[profVert.length], pathv[] = new Vec3[pathVert.length];
        Vec3 subdiv[], center = new Vec3(), zdir[], updir[], t[], v[][];
        float usmooth[] = new float[pathVert.length], vsmooth[] = new float[profVert.length];
        float profSmooth[] = profile.getSmoothness(), pathSmooth[] = path.getSmoothness();
        CoordinateSystem localCoords = new CoordinateSystem(new Vec3(), Vec3.vz(), Vec3.vy());
        Mat4 rotate;
        int i, j;
        for (i = 0; i < profVert.length; i++) profv[i] = profCoords.fromLocal().timesDirection(profVert[i].r);
        for (i = 0; i < pathVert.length; i++) pathv[i] = pathCoords.fromLocal().timesDirection(pathVert[i].r);
        subdiv = new Curve(pathv, pathSmooth, path.getSmoothingMethod(), path.isClosed()).subdivideCurve().getVertexPositions();
        t = new Vec3[subdiv.length];
        zdir = new Vec3[subdiv.length];
        updir = new Vec3[subdiv.length];
        t[0] = subdiv[1].minus(subdiv[0]);
        t[0].normalize();
        zdir[0] = Vec3.vz();
        updir[0] = Vec3.vy();
        Vec3 dir1, dir2;
        double zfrac1, zfrac2, upfrac1, upfrac2;
        zfrac1 = t[0].dot(zdir[0]);
        zfrac2 = Math.sqrt(1.0 - zfrac1 * zfrac1);
        dir1 = zdir[0].minus(t[0].times(zfrac1));
        dir1.normalize();
        upfrac1 = t[0].dot(updir[0]);
        upfrac2 = Math.sqrt(1.0 - upfrac1 * upfrac1);
        dir2 = updir[0].minus(t[0].times(upfrac1));
        dir2.normalize();
        for (i = 1; i < subdiv.length; i++) {
            if (i == subdiv.length - 1) {
                if (path.isClosed()) t[i] = subdiv[0].minus(subdiv[subdiv.length - 2]); else t[i] = subdiv[subdiv.length - 1].minus(subdiv[subdiv.length - 2]);
            } else t[i] = subdiv[i + 1].minus(subdiv[i - 1]);
            t[i].normalize();
            if (orient) {
                dir1 = dir1.minus(t[i].times(t[i].dot(dir1)));
                dir1.normalize();
                dir2 = dir2.minus(t[i].times(t[i].dot(dir2)));
                dir2.normalize();
                zdir[i] = t[i].times(zfrac1).plus(dir1.times(zfrac2));
                updir[i] = t[i].times(upfrac1).plus(dir2.times(upfrac2));
            } else {
                zdir[i] = zdir[i - 1];
                updir[i] = updir[i - 1];
            }
        }
        if (path.getSmoothingMethod() != Mesh.NO_SMOOTHING) for (i = 0; i < usmooth.length; i++) usmooth[i] = pathSmooth[i];
        if (profile.getSmoothingMethod() != Mesh.NO_SMOOTHING) for (i = 0; i < vsmooth.length; i++) vsmooth[i] = profSmooth[i];
        if (profile.getSmoothingMethod() == Mesh.APPROXIMATING && path.getSmoothingMethod() == Mesh.INTERPOLATING) {
            pathv = subdiv;
            usmooth = new float[pathv.length];
            for (i = 0; i < usmooth.length; i++) {
                if (i % 2 == 0) usmooth[i] = Math.min(pathSmooth[i / 2] * 2.0f, 1.0f); else usmooth[i] = 1.0f;
            }
        }
        if (profile.getSmoothingMethod() == Mesh.INTERPOLATING && path.getSmoothingMethod() == Mesh.APPROXIMATING) {
            profv = new Curve(profv, profSmooth, profile.getSmoothingMethod(), profile.isClosed()).subdivideCurve().getVertexPositions();
            vsmooth = new float[profv.length];
            for (i = 0; i < vsmooth.length; i++) {
                if (i % 2 == 0) vsmooth[i] = Math.min(profSmooth[i / 2] * 2.0f, 1.0f); else vsmooth[i] = 1.0f;
            }
        }
        v = new Vec3[pathv.length][profv.length];
        for (i = 0; i < pathv.length; i++) {
            localCoords.setOrigin(pathv[i]);
            int k = (pathv.length == subdiv.length ? i : 2 * i);
            localCoords.setOrientation(zdir[k], updir[k]);
            if (angle != 0.0) {
                rotate = Mat4.axisRotation(t[k], i * angle / (pathv.length - 1));
                localCoords.transformAxes(rotate);
            }
            for (j = 0; j < profv.length; j++) {
                v[i][j] = localCoords.fromLocal().times(profv[j]);
                center.add(v[i][j]);
            }
        }
        center.scale(1.0 / (profv.length * pathv.length));
        for (i = 0; i < pathv.length; i++) for (j = 0; j < profv.length; j++) v[i][j].subtract(center);
        SplineMesh mesh = new SplineMesh(v, usmooth, vsmooth, Math.max(profile.getSmoothingMethod(), path.getSmoothingMethod()), path.isClosed(), profile.isClosed());
        mesh.makeRightSideOut();
        return mesh;
    }
"
2323,1426400,7,"        private boolean set(int o, int m, Object[] ret, int r) throws E {
            if (entriesSet[m]) return ret[r] != null;
            if (oIdxAdj[o] > r && oIdxAdj[o] - r <= 10) {
                int o2;
                for (o2 = o - 1; o2 >= 0; o2--) if (oMappings[o2] > m) set(o2, oMappings[o2], ret, r + oMappings[o2] - m);
            }
            entriesSet[m] = true;
            T1 item = dl.set(original[o], o, oIdxAdj[o], modifier[m], m, r);
            if (isNullElement) {
                item = (T1) NULL;
                isNullElement = false;
            }
            if (item != null) {
                ret[r] = item;
                int oAdj = oIdxAdj[o];
                if (r > oAdj) {
                    for (int i = 0; i < oIdxAdj.length; i++) if (oIdxAdj[i] >= oAdj && oIdxAdj[i] <= r) oIdxAdj[i]--;
                } else if (r < oAdj) {
                    for (int i = 0; i < oIdxAdj.length; i++) if (oIdxAdj[i] >= r && oIdxAdj[i] < oAdj) oIdxAdj[i]++;
                }
            } else {
                oIdxAdj[o] = -1;
                for (int i = 0; i < oIdxAdj.length; i++) if (oIdxAdj[i] > r) oIdxAdj[i]--;
                for (; r < ret.length - 1; r++) ret[r] = ret[r + 1];
            }
            return item != null;
        }
"
2325,1470511,7,"    private static double[] maketable(double[] x, double[] y, int n) {
        double[] a = new double[n];
        double[] h = new double[n];
        double[] d = new double[n];
        int n_1 = n - 1;
        int n_2 = n - 2;
        a[0] = 0;
        a[n_1] = 0;
        for (int i = 0; i < n_1; i++) {
            h[i] = x[i + 1] - x[i];
            d[i + 1] = (y[i + 1] - y[i]) / h[i];
        }
        a[1] = d[2] - d[1] - h[0] * a[0];
        d[1] = 2 * (x[2] - x[0]);
        for (int i = 1; i < n_2; i++) {
            double t = h[i] / d[i];
            a[i + 1] = d[i + 2] - d[i + 1] - a[i] * t;
            d[i + 1] = 2 * (x[i + 2] - x[i]) - h[i] * t;
        }
        a[n_2] -= h[n_2] * a[n_1];
        for (int i = n_2; i > 0; i--) {
            a[i] = (a[i] - h[i] * a[i + 1]) / d[i];
        }
        return a;
    }
"
1454,683955,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
7191,9397761,7,"    public void setup(double[] init_xyz, double[] final_xyz, int n) {
        clear();
        double[] xyz1 = new double[12];
        double[] xyz2 = new double[12];
        int i;
        int j;
        if (n != 0) {
            for (i = 0; i < 3; i++) {
                xyz1[i] = init_xyz[i];
                xyz2[i] = final_xyz[i];
            }
        } else {
            return;
        }
        if (n > 1) {
            double dist;
            double maxdist;
            int id = 1;
            maxdist = 0.0;
            for (i = 1; i < n; i++) {
                for (dist = 0.0, j = 0; j < 3; j++) {
                    dist += ((xyz1[j] - init_xyz[(3 * i) + j]) * (xyz1[j] - init_xyz[(3 * i) + j]));
                }
                dist = Math.sqrt(dist);
                if (dist > maxdist) {
                    maxdist = dist;
                    id = i;
                }
            }
            for (i = 0; i < 3; i++) {
                xyz1[3 + i] = init_xyz[(3 * id) + i];
                xyz2[3 + i] = final_xyz[(3 * id) + i];
            }
        } else {
            double[] euler = new double[3];
            double[] trans = new double[3];
            for (i = 0; i < 3; i++) {
                euler[i] = 0.0f;
                trans[i] = xyz2[i] - xyz1[i];
            }
            setupEulerTranslation(euler, trans);
            return;
        }
        if (n > 2) {
            double mag;
            double maxcross;
            double[] xx = new double[3];
            double[] yy = new double[3];
            double[] cr = new double[3];
            int ic = 1;
            for (j = 0; j < 3; j++) {
                xx[j] = xyz1[3 + j] - xyz1[j];
            }
            maxcross = 0.0f;
            for (i = 1; i < n; i++) {
                for (j = 0; j < 3; j++) {
                    yy[j] = init_xyz[(3 * i) + j] - xyz1[j];
                }
                cr[0] = (xx[1] * yy[2]) - (xx[2] * yy[1]);
                cr[1] = (-xx[0] * yy[2]) + (xx[2] * yy[0]);
                cr[2] = (xx[0] * yy[1]) - (xx[1] * yy[0]);
                mag = Math.sqrt((cr[0] * cr[0]) + (cr[1] * cr[1]) + (cr[2] * cr[2]));
                if (mag > maxcross) {
                    maxcross = mag;
                    ic = i;
                }
            }
            for (i = 0; i < 3; i++) {
                xyz1[6 + i] = init_xyz[(3 * ic) + i];
                xyz2[6 + i] = final_xyz[(3 * ic) + i];
            }
        } else {
            double[] xx = new double[3];
            double[] yy = new double[3];
            xx[0] = xyz1[3 + 0] - xyz1[0];
            xx[1] = xyz1[3 + 1] - xyz1[1];
            xx[2] = xyz1[3 + 2] - xyz1[2];
            yy[0] = xx[2];
            yy[1] = xx[0];
            yy[2] = xx[1];
            xyz1[6 + 0] = yy[0] + xyz1[0];
            xyz1[6 + 1] = yy[1] + xyz1[1];
            xyz1[6 + 2] = yy[2] + xyz1[2];
            xx[0] = xyz2[3 + 0] - xyz2[0];
            xx[1] = xyz2[3 + 1] - xyz2[1];
            xx[2] = xyz2[3 + 2] - xyz2[2];
            yy[0] = xx[2];
            yy[1] = xx[0];
            yy[2] = xx[1];
            xyz2[6 + 0] = yy[0] + xyz2[0];
            xyz2[6 + 1] = yy[1] + xyz2[1];
            xyz2[6 + 2] = yy[2] + xyz2[2];
        }
        double mag;
        double dot;
        double[] xx1 = new double[3];
        double[] yy1 = new double[3];
        double[] zz1 = new double[3];
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            xx1[i] = xyz1[3 + i] - xyz1[i];
        }
        for (i = 0; i < 3; i++) {
            mag += (xx1[i] * xx1[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            xx1[i] /= mag;
            xyz1[3 + i] = xx1[i] + xyz1[i];
        }
        dot = 0.0f;
        for (i = 0; i < 3; i++) {
            yy1[i] = xyz1[6 + i] - xyz1[i];
        }
        for (i = 0; i < 3; i++) {
            dot += (xx1[i] * yy1[i]);
        }
        for (i = 0; i < 3; i++) {
            yy1[i] -= (xx1[i] * dot);
        }
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            mag += (yy1[i] * yy1[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            yy1[i] /= mag;
            xyz1[6 + i] = yy1[i] + xyz1[i];
        }
        zz1[0] = (xx1[1] * yy1[2]) - (xx1[2] * yy1[1]);
        zz1[1] = (-xx1[0] * yy1[2]) + (xx1[2] * yy1[0]);
        zz1[2] = (xx1[0] * yy1[1]) - (xx1[1] * yy1[0]);
        for (i = 0; i < 3; i++) {
            xyz1[9 + i] = zz1[i] + xyz1[i];
        }
        double[] xx2 = new double[3];
        double[] yy2 = new double[3];
        double[] zz2 = new double[3];
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            xx2[i] = xyz2[3 + i] - xyz2[i];
        }
        for (i = 0; i < 3; i++) {
            mag += (xx2[i] * xx2[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            xx2[i] /= mag;
            xyz2[3 + i] = xx2[i] + xyz2[i];
        }
        dot = 0.0f;
        for (i = 0; i < 3; i++) {
            yy2[i] = xyz2[6 + i] - xyz2[i];
        }
        for (i = 0; i < 3; i++) {
            dot += (xx2[i] * yy2[i]);
        }
        for (i = 0; i < 3; i++) {
            yy2[i] -= (xx2[i] * dot);
        }
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            mag += (yy2[i] * yy2[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            yy2[i] /= mag;
            xyz2[6 + i] = yy2[i] + xyz2[i];
        }
        zz2[0] = (xx2[1] * yy2[2]) - (xx2[2] * yy2[1]);
        zz2[1] = (-xx2[0] * yy2[2]) + (xx2[2] * yy2[0]);
        zz2[2] = (xx2[0] * yy2[1]) - (xx2[1] * yy2[0]);
        for (i = 0; i < 3; i++) {
            xyz2[9 + i] = zz2[i] + xyz2[i];
        }
        JOECoordTrans cti = new JOECoordTrans();
        JOECoordTrans ctf = new JOECoordTrans();
        cti.setup(xyz1);
        ctf.setup(xyz2);
        cti.invert();
        this.set(cti.add(ctf));
    }
"
10405,15891729,7,"    public void setPalette(IPalette palette) {
        if (m_src_index_color_raster == null) {
            throw new IllegalStateException(""this image is not support index color model !"");
        }
        if (palette != null) {
            try {
                byte[] colors = palette.getIndexColors();
                int color_count = palette.getIndexColorCount();
                int transparent_color_index = palette.getTransparentColorIndex();
                byte[] ra = new byte[color_count];
                byte[] ga = new byte[color_count];
                byte[] ba = new byte[color_count];
                byte[] ralpha = new byte[color_count];
                for (int i = 0, j = 0; (i < colors.length) && (j < color_count); i += 3, ++j) {
                    ra[j] = colors[i];
                    ga[j] = colors[i + 1];
                    ba[j] = colors[i + 2];
                    ralpha[j] = (byte) ((j == transparent_color_index) ? 0 : 255);
                }
                IndexColorModel icm = new IndexColorModel(8, color_count, ra, ga, ba, ralpha);
                BufferedImage new_image = new BufferedImage(icm, m_src_index_color_raster, icm.isAlphaPremultiplied(), null);
                m_image = createBuffer(new_image);
            } catch (Exception exp) {
                exp.printStackTrace();
            }
        }
    }
"
8719,13258283,7,"    private static BinParameter[] getNewParameters(BinParameter[] old, int idx) {
        if ((old == null) || (old.length < 2) || (idx < 0) || (idx > old.length - 1)) {
            return new BinParameter[0];
        }
        BinParameter[] newParams = new BinParameter[old.length - 1];
        for (int i = 0; i < idx; i++) {
            newParams[i] = old[i];
        }
        for (int i = idx; i < old.length - 1; i++) {
            newParams[i] = old[i + 1];
        }
        return newParams;
    }
"
3651,3595778,7,"    public void remove(int idx) {
        int i;
        size--;
        for (i = idx; i < size; i++) {
            data[i] = data[i + 1];
        }
    }
"
9132,13734686,7,"        public MyPolygon(double[] xpoints, double[] ypoints, int n) {
            x = xpoints;
            y = ypoints;
            npoints = n;
            x_normal = new double[x.length];
            y_normal = new double[y.length];
            for (int i = 0; i < n - 1; i++) {
                x_normal[i] = x[i + 1] - x[i];
                y_normal[i] = y[i + 1] - y[i];
            }
            x_normal[n - 1] = x[0] - x[n - 1];
            y_normal[n - 1] = y[0] - y[n - 1];
        }
"
6902,8940133,7,"    @SuppressWarnings(""unchecked"")
    public Comparable<?> getResult(Comparable<?>... comparables) throws ParseException {
        String returnColumnName = null;
        returnColumnName = comparables[0].toString().toLowerCase();
        Map<String, Object> result = null;
        Comparable<?>[] parameters = new Comparable<?>[comparables.length - 1];
        if (isThreadLocalCache()) {
            int threadLocalKey = this.hashCode();
            if (parameterSize > 1) {
                int hash = this.hashCode();
                for (int i = 0; i < parameters.length; i++) {
                    parameters[i] = comparables[i + 1];
                    hash ^= parameters[i].hashCode() << (i + 1);
                }
                threadLocalKey = threadLocalKey ^ hash;
            }
            result = (Map<String, Object>) ThreadLocalMap.get(threadLocalKey);
            if (result == null) {
                if (!ThreadLocalMap.containsKey(threadLocalKey)) {
                    result = query(parameters);
                    ThreadLocalMap.put(threadLocalKey, result);
                }
            }
        } else {
            result = query(parameters);
        }
        if (result == null) {
            return (null);
        } else {
            return ((Comparable<?>) result.get(returnColumnName));
        }
    }
"
6725,8741065,7,"    private void getNextChangingElement(int a0, boolean isWhite, int[] ret) {
        int[] pce = this.prevChangingElems;
        int ces = this.changingElemSize;
        int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
        if (isWhite) {
            start &= ~0x1;
        } else {
            start |= 0x1;
        }
        int i = start;
        for (; i < ces; i += 2) {
            int temp = pce[i];
            if (temp > a0) {
                lastChangingElement = i;
                ret[0] = temp;
                break;
            }
        }
        if (i + 1 < ces) {
            ret[1] = pce[i + 1];
        }
    }
"
10885,16653081,7,"    public void moveEvent(ScrEvent event, int newTime) {
        int index = indexOf(event);
        int newIndex = getIndexAfter(newTime);
        if (newIndex == NO_SUCH_EVENT) newIndex = events_fill_p - 1; else if (event.getTime() <= newTime) newIndex -= 1;
        if (index == NO_SUCH_EVENT) {
            System.err.println(""no such event error"");
            for (int i = 0; i < length(); i++) {
                System.err.println(""#"" + i + "" t "" + getEventAt(i).getTime() + "" p "" + getEventAt(i).getPitch());
            }
            return;
        }
        if (index == EMPTY_COLLECTION) index = 0;
        event.setTime(newTime);
        args.clear();
        args.addInt(index);
        args.addInt(event.getTime());
        try {
            send(FtsSymbol.get(""change_time""), args);
        } catch (IOException e) {
            System.err.println(""FtsObjectWithEditor: I/O Error sending change_time Message!"");
            e.printStackTrace();
        }
        if (index < newIndex) {
            for (int i = index; i < newIndex; i++) {
                events[i] = events[i + 1];
            }
        } else {
            for (int i = index; i > newIndex; i--) {
                events[i] = events[i - 1];
            }
            events[newIndex] = event;
        }
        events[newIndex] = event;
        notifyObjectMoved(event, index, newIndex);
    }
"
7301,9650837,7,"    public void remove(Ko ko) {
        for (int i = 0; i < db; i++) if (kovek[i] == ko) {
            db--;
            for (int j = i; j < db; j++) kovek[j] = kovek[j + 1];
            break;
        }
    }
"
7512,10131417,7,"    public void learnNetwork(Song song) {
        Track.AbsoluteNote[] notes = new Track.AbsoluteNote[8];
        for (int a = 0; a < song.getNumberOfTracks(); a++) {
            if (song.getInstrument(a) < 100) {
                Iterator iterator = song.getTrack(a).getAbsoluteIterator();
                while (iterator.hasNext()) {
                    notes[7] = (Track.AbsoluteNote) iterator.next();
                    double[] input = new double[8];
                    if (notes[0] != null) {
                        for (int b = 0; b < 7; b++) input[b] = (notes[b].getHeight() - notes[b + 1].getHeight()) / 16.0d;
                        neuralNetwork.learn(input, new double[] { 1.0d });
                    }
                    for (int c = 0; c < 3; c++) {
                        for (int b = 0; b < 7; b++) input[b] = Math.random() * 2.0d - 1.0d;
                        neuralNetwork.learn(input, new double[] { -1.0d });
                    }
                    for (int b = 0; b < 7; b++) notes[b] = notes[b + 1];
                }
            }
        }
    }
"
14192,21781242,7,"    public Object add(Object objNew) {
        Object objOld = objary[0];
        for (int i = 0; i < (intLength - 1); i++) {
            objary[i] = objary[i + 1];
        }
        objary[intLength - 1] = objNew;
        return objOld;
    }
"
14319,21950639,7,"        void convertFromABGRToRGBA() {
            int i;
            if (imageDataType == ImageComponentRetained.ImageDataType.TYPE_BYTE_ARRAY) {
                byte[] srcBuffer, dstBuffer;
                srcBuffer = getAsByteArray();
                if (dataIsByRef) {
                    dstBuffer = new byte[length];
                    for (i = 0; i < length; i += 4) {
                        dstBuffer[i] = srcBuffer[i + 3];
                        dstBuffer[i + 1] = srcBuffer[i + 2];
                        dstBuffer[i + 2] = srcBuffer[i + 1];
                        dstBuffer[i + 3] = srcBuffer[i];
                    }
                    data = dstBuffer;
                    dataIsByRef = false;
                } else {
                    byte a, b;
                    for (i = 0; i < length; i += 4) {
                        a = srcBuffer[i];
                        b = srcBuffer[i + 1];
                        srcBuffer[i] = srcBuffer[i + 3];
                        srcBuffer[i + 1] = srcBuffer[i + 2];
                        srcBuffer[i + 2] = b;
                        srcBuffer[i + 3] = a;
                    }
                }
            } else if (imageDataType == ImageComponentRetained.ImageDataType.TYPE_BYTE_BUFFER) {
                assert dataIsByRef;
                ByteBuffer srcBuffer, dstBuffer;
                srcBuffer = getAsByteBuffer();
                srcBuffer.rewind();
                ByteOrder order = ByteOrder.nativeOrder();
                dstBuffer = ByteBuffer.allocateDirect(length).order(order);
                dstBuffer.rewind();
                for (i = 0; i < length; i += 4) {
                    dstBuffer.put(i, srcBuffer.get(i + 3));
                    dstBuffer.put(i + 1, srcBuffer.get(i + 2));
                    dstBuffer.put(i + 2, srcBuffer.get(i + 1));
                    dstBuffer.put(i + 3, srcBuffer.get(i));
                }
                dataIsByRef = false;
            }
        }
"
9245,13986291,7,"    public String[] sortAlpha(Collection collection) {
        String[] retur = new String[collection.size()];
        Iterator it = collection.iterator();
        int k = 0;
        while (it.hasNext()) {
            String temp = (String) it.next();
            retur[k] = temp;
            k++;
        }
        for (int i = 0; i + 1 < retur.length; i++) {
            if (retur[i].compareTo(retur[i + 1]) > 0) {
                String temp = retur[i];
                retur[i] = retur[i + 1];
                retur[i + 1] = temp;
                int j = i;
                boolean done = false;
                while (j != 0 && !done) {
                    if (retur[j].compareTo(retur[j - 1]) < 0) {
                        temp = retur[j];
                        retur[j] = retur[j - 1];
                        retur[j - 1] = temp;
                    } else done = true;
                    j--;
                }
            }
        }
        return retur;
    }
"
4978,5695068,7,"    public boolean remPart(int i) {
        try {
            for (int j = i; j < parts; j++) {
                part[j] = part[j + 1];
            }
            parts--;
            return true;
        } catch (Exception e) {
            System.out.println(e);
            return false;
        }
    }
"
12703,19658643,7,"    private static void dualPivotQuicksort(byte[] a, int left, int right) {
        int sixth = (right - left + 1) / 6;
        int e1 = left + sixth;
        int e5 = right - sixth;
        int e3 = (left + right) >>> 1;
        int e4 = e3 + sixth;
        int e2 = e3 - sixth;
        byte ae1 = a[e1], ae2 = a[e2], ae3 = a[e3], ae4 = a[e4], ae5 = a[e5];
        if (ae1 > ae2) {
            byte t = ae1;
            ae1 = ae2;
            ae2 = t;
        }
        if (ae4 > ae5) {
            byte t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        if (ae1 > ae3) {
            byte t = ae1;
            ae1 = ae3;
            ae3 = t;
        }
        if (ae2 > ae3) {
            byte t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae1 > ae4) {
            byte t = ae1;
            ae1 = ae4;
            ae4 = t;
        }
        if (ae3 > ae4) {
            byte t = ae3;
            ae3 = ae4;
            ae4 = t;
        }
        if (ae2 > ae5) {
            byte t = ae2;
            ae2 = ae5;
            ae5 = t;
        }
        if (ae2 > ae3) {
            byte t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae4 > ae5) {
            byte t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        a[e1] = ae1;
        a[e3] = ae3;
        a[e5] = ae5;
        byte pivot1 = ae2;
        a[e2] = a[left];
        byte pivot2 = ae4;
        a[e4] = a[right];
        int less = left + 1;
        int great = right - 1;
        boolean pivotsDiffer = (pivot1 != pivot2);
        if (pivotsDiffer) {
            outer: for (int k = less; k <= great; k++) {
                byte ak = a[k];
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = a[great];
                        a[great--] = ak;
                    }
                }
            }
        } else {
            for (int k = less; k <= great; k++) {
                byte ak = a[k];
                if (ak == pivot1) {
                    continue;
                }
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = pivot1;
                        a[great--] = ak;
                    }
                }
            }
        }
        a[left] = a[less - 1];
        a[less - 1] = pivot1;
        a[right] = a[great + 1];
        a[great + 1] = pivot2;
        doSort(a, left, less - 2);
        doSort(a, great + 2, right);
        if (!pivotsDiffer) {
            return;
        }
        if (less < e1 && great > e5) {
            while (a[less] == pivot1) {
                less++;
            }
            while (a[great] == pivot2) {
                great--;
            }
            outer: for (int k = less; k <= great; k++) {
                byte ak = a[k];
                if (ak == pivot2) {
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) {
                        a[k] = a[less];
                        a[less++] = pivot1;
                    } else {
                        a[k] = a[great];
                    }
                    a[great--] = pivot2;
                } else if (ak == pivot1) {
                    a[k] = a[less];
                    a[less++] = pivot1;
                }
            }
        }
        doSort(a, less, great);
    }
"
12939,19883631,7,"    public boolean offer(E elt) {
        if (mSize == mElts.length) {
            int c = mComparator.compare(mElts[mElts.length - 1], elt);
            if (c >= 0) return false;
            mElts[mElts.length - 1] = elt;
        }
        if (mSize < mElts.length) {
            mElts[mSize] = elt;
            ++mSize;
        }
        for (int i = mSize - 1; --i >= 0 && mComparator.compare(mElts[i], mElts[i + 1]) < 0; ) {
            E temp = mElts[i];
            mElts[i] = mElts[i + 1];
            mElts[i + 1] = temp;
        }
        return true;
    }
"
13896,21175287,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
"
13558,20707231,7,"    public FrequencyNode(ProbabilityFunction func) {
        DiscreteVariable[] vars = func.get_variables();
        id = vars[0].get_index();
        int maxK = vars[0].number_values();
        if (vars.length > 1) {
            parents = new int[vars.length - 1];
            int maxJ = 1;
            for (int p = 0; p < parents.length; ++p) {
                parents[p] = vars[p + 1].get_index();
                maxJ *= vars[p + 1].number_values();
            }
            parentMult = new int[vars.length - 1];
            nJ = new int[maxJ];
            nJK = new int[maxJ][maxK];
            for (int p = 0; p < parentMult.length; ++p) {
                maxJ /= vars[p + 1].number_values();
                parentMult[p] = maxJ;
            }
        } else {
            parents = null;
            parentMult = null;
            nJ = new int[1];
            nJK = new int[1][maxK];
        }
    }
"
2626,1874798,7,"    private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandPronunciation(edu.cmu.sphinx.decoder.linguist.PronunciationState state) {
        Pronunciation pronunciation = state.getPronunciation();
        Unit[] units = pronunciation.getUnits();
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState combineState = new CombineState(state.getParent(), state.getWhich());
        combineState.setColor(Color.RED);
        for (int a = 0; a < acousticModels.length; a++) {
            AcousticModel model = acousticModels[a];
            edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = state;
            for (int i = 0; i < units.length; i++) {
                ParallelUnitState unitState = null;
                if (i == 0 || i == (units.length - 1)) {
                    unitState = new ParallelUnitState(state, model.getName(), i, units[i], tokenStackCapacity);
                } else {
                    Unit[] leftContext = new Unit[1];
                    Unit[] rightContext = new Unit[1];
                    leftContext[0] = units[i - 1];
                    rightContext[0] = units[i + 1];
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    Unit unit = new Unit(units[i].getName(), units[i].isFiller(), context);
                    unitState = new ParallelUnitState(state, model.getName(), i, unit, tokenStackCapacity);
                }
                unitState.setColor(Color.GREEN);
                attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), unitInsertionProbability);
                lastState = expandUnit(unitState, model);
                if (unitState.getUnit().isSilence()) {
                    attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), logMath.getLogOne());
                }
            }
            Unit lastUnit = units[units.length - 1];
            if (addSelfLoopWordEndSilence && !lastUnit.isSilence()) {
                addLoopSilence(lastState, state, model);
            }
            attachState(lastState, combineState, logMath.getLogOne(), logMath.getLogOne(), logMath.getLogOne());
        }
        return combineState;
    }
"
14952,23365039,7,"    public void calcCurve() throws JuggleExceptionInternal {
        this.n = numpoints - 1;
        if (n < 1) throw new JuggleExceptionInternal(""lineCurve error 1"");
        this.a = new double[n][3];
        this.b = new double[n][3];
        this.durations = new double[n];
        for (int i = 0; i < n; i++) {
            durations[i] = times[i + 1] - times[i];
            if (durations[i] < 0.0) throw new JuggleExceptionInternal(""lineCurve error 2"");
        }
        double[] x = new double[n + 1];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < (n + 1); j++) x[j] = positions[j].getIndex(i);
            for (int j = 0; j < n; j++) {
                a[j][i] = x[j];
                b[j][i] = (x[j + 1] - x[j]) / durations[j];
            }
        }
    }
"
1921,919554,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
8079,11833651,7,"    @Override
    protected void addOption(StringBuffer sb, String label, String value, boolean matched) {
        try {
            if (label.startsWith(""$"")) {
                String optionBundle = bundle;
                int colonIndex = label.indexOf("":"");
                if (colonIndex != -1) {
                    optionBundle = label.substring(1, colonIndex);
                    label = label.substring(colonIndex);
                }
                String[] args = label.split(""\\|"");
                if (args.length > 1) {
                    String[] args2 = new String[args.length - 1];
                    for (int i = 0; i < args2.length; ++i) {
                        args2[i] = args[i + 1].replaceAll(""\\\\\\|"", ""\\|"");
                    }
                    label = TagUtils.getInstance().message(pageContext, optionBundle, locale, args[0].substring(1), args2);
                } else {
                    label = TagUtils.getInstance().message(pageContext, optionBundle, locale, label.substring(1));
                }
            }
        } catch (JspException x) {
        }
        if (getParent() == null || !(getParent() instanceof de.iritgo.aktera.struts.tags.html.SelectTag) || !((SelectTag) getParent()).getReadOnly()) {
            options.add(new Option(label, value, matched));
        } else if (matched) {
            try {
                TagUtils.getInstance().write(pageContext, label);
            } catch (JspException x) {
            }
        }
    }
"
4410,5121681,7,"    private void ProcessSystem(slinkeRawMsg m) {
        Byte[] msg = m.getMsgData();
        switch(msg[0].intValue()) {
            case 4:
                samplePeriod = ((msg[2].intValue() & 0xff) + ((msg[1].intValue() & 0xff) * 256)) / 5;
                sampleRateRead = true;
                break;
            case 6:
                carrierFreq = 1000 / (((1 << (msg[1].intValue() & 0xff)) * ((msg[2].intValue() & 0xff) + 1)) / 5);
                carrierFreqRead = true;
                break;
            case 11:
                version = msg[1];
                versionRead = true;
                ;
                break;
            case 12:
                int i;
                serialNumber = new Byte[8];
                for (i = 0; i < 8; i++) {
                    serialNumber[i] = msg[i + 1];
                }
                serialRead = true;
                break;
            default:
                break;
        }
    }
"
14922,23284625,7,"    @Override
    public void setColumn(int i, Vector column) {
        if (i >= columns || i < 0) throw new IndexOutOfBoundsException();
        for (int ii = 0; ii < column.length(); ii++) {
            int position = rowPointers[ii], limit = rowPointers[ii + 1];
            while (position < limit && columnIndices[position] < i) position++;
            if (Math.abs(column.get(ii)) > EPS) {
                if (columnIndices[position] != i) {
                    if (values.length < nonzero + 1) {
                        growup();
                    }
                    for (int k = nonzero; k > position; k--) {
                        values[k] = values[k - 1];
                        columnIndices[k] = columnIndices[k - 1];
                    }
                }
                for (int k = ii + 1; k < rows + 1; k++) {
                    rowPointers[k]++;
                }
                values[position] = column.get(ii);
                columnIndices[position] = i;
                nonzero++;
            } else if (columnIndices[position] == i && position < limit) {
                for (int k = position; k < nonzero - 1; k++) {
                    values[k] = values[k + 1];
                    columnIndices[k] = columnIndices[k + 1];
                }
                for (int k = ii + 1; k < rows + 1; k++) {
                    rowPointers[k]--;
                }
                nonzero--;
            }
        }
    }
"
1989,944603,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
764,352574,7,"    public void moveToEnd(int loc) {
        card temp = new card();
        temp.m_type = m_data[loc].m_type;
        temp.m_color = m_data[loc].m_color;
        for (int r = loc; r < m_length - 1; ++r) {
            m_data[r] = m_data[r + 1];
        }
        m_data[m_data.length - 1].m_type = temp.m_type;
        m_data[m_data.length - 1].m_color = temp.m_color;
        m_data[m_data.length - 1].m_quantity = 0;
    }
"
7524,10170678,7,"    public void endUpdate() {
        int i = 0;
        int total = 0;
        for (; i < counts.length - 1; i++) {
            counts[i] = counts[i + 1];
        }
        counts[i] = updateCount;
        updateCount = 0;
        int num = rects.size();
        for (i = counts.length - 1; i >= 0; i--) {
            if (counts[i] > num) {
                counts[i] = num;
            }
            num -= counts[i];
        }
        counts[0] += num;
    }
"
9159,13780282,7,"    public void sortOnColumn(boolean sort_ascending, int col_idx) {
        boolean made_change = true;
        while (made_change) {
            made_change = false;
            for (int i = 0; i < data_grid.length - 1; i++) {
                boolean flip = false;
                if (data_grid[i][col_idx].equals("""") || data_grid[i + 1][col_idx].equals("""")) {
                    if (data_grid[i][col_idx].equals("""") && data_grid[i + 1][col_idx].equals("""")) {
                    } else {
                        if ((sort_ascending && !data_grid[i][col_idx].equals("""") && data_grid[i + 1][col_idx].equals("""")) || (!sort_ascending && data_grid[i][col_idx].equals("""") && !data_grid[i + 1][col_idx].equals(""""))) {
                            flip = true;
                        }
                    }
                } else {
                    if ((sort_ascending && (Float.parseFloat(data_grid[i][col_idx]) > Float.parseFloat(data_grid[i + 1][col_idx]))) || (!sort_ascending && (Float.parseFloat(data_grid[i][col_idx]) < Float.parseFloat(data_grid[i + 1][col_idx])))) {
                        flip = true;
                    } else {
                    }
                }
                if (flip) {
                    String[] temp = data_grid[i];
                    data_grid[i] = data_grid[i + 1];
                    data_grid[i + 1] = temp;
                    String[] stemp = vert[i];
                    vert[i] = vert[i + 1];
                    vert[i + 1] = stemp;
                    made_change = true;
                }
            }
        }
    }
"
14268,21914511,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < max_size - 2; i++) items[i] = items[i + 1];
            items[max_size - 1] = false;
        } else items[0] = false;
        current_item--;
    }
"
12856,19786510,7,"    protected void renderMergedOutputModel(Map model, HttpServletRequest request, HttpServletResponse response) throws Exception {
        UtilsManager utilsManager = (UtilsManager) this.getApplicationContext().getBean(""utilsManager"");
        response.setContentType(""text/html"");
        if (request.isSecure()) {
            response.setHeader(""Pragma"", ""private"");
            response.setHeader(""Cache-Control"", ""private, must-revalidate"");
        } else {
            response.setHeader(""Cache-Control"", ""no-cache"");
        }
        PrintWriter out = response.getWriter();
        MessageSourceAccessor text = getMessageSourceAccessor();
        String mdl = (String) model.get(""mdl"");
        if (mdl.equals(""10"")) {
            Long number = (Long) model.get(""instancesNotMonitored"");
            out.println(text.getMessage(""instancesNotMonitored"", request.getLocale()) + "" "" + number);
        } else if (mdl.equals(""11"")) {
            response.setContentType(""text/html"");
            List data = (List) model.get(""data"");
            DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
            DateTime prevDet = null;
            Vector vData = new Vector();
            for (int i = 0; i < data.size(); i++) {
                OsmHistSysmark osmHistSysmark = (OsmHistSysmark) data.get(i);
                vData.add(osmHistSysmark.getId().getNumMark());
            }
            OsmSysmark osmSysmark = (OsmSysmark) model.get(""activeData"");
            if (osmSysmark != null) {
                vData.add(osmSysmark.getId().getNumMark());
                vData.add(osmSysmark.getId().getNumMark());
            }
            StringBuffer strTmp = new StringBuffer(""["");
            for (int i = 0; i < vData.size(); i++) {
                Object o = vData.elementAt(i);
                if (i > 0) strTmp.append("","").append(o); else strTmp.append(o);
            }
            strTmp.append(""]"");
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            String test = strTmp.toString();
            GlobalNote miNote = new GlobalNote(test);
            JSONObject json = JSONObject.fromObject(miNote);
            out.print(json);
        } else if (mdl.equals(""12"")) {
            response.setContentType(""text/plain"");
            Integer days = (Integer) model.get(""days"");
            List data = (List) model.get(""data"");
            String filter = (String) model.get(""filterSrv"");
            if (data.size() == 0) {
                DateTime dateIni = new DateTime(utilsManager.getActualTimestamp().getTime()).minusDays(days);
                Date dateFin = new Date(utilsManager.getActualTimestamp().getTime());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(dateIni)).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime now = new DateTime(utilsManager.getActualTimestamp().getTime());
                for (int i = 0; i < data.size(); i++) {
                    if (i == 0) {
                        Date date = ((Date) ((Object[]) data.get(i))[1]);
                        if (filter.equals(""1"")) {
                            DateMidnight todayMidnight = new DateMidnight(utilsManager.getActualTimestamp().getTime());
                            if (date.getTime() < todayMidnight.getMillis()) {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(todayMidnight.getMillis()))).append(((Object[]) data.get(i))[2]).toString());
                            } else {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(date.getTime()))).append(((Object[]) data.get(i))[2]).toString());
                            }
                        } else if (filter.equals(""7"")) {
                            DateMidnight todayMidnight = new DateMidnight(utilsManager.getActualTimestamp().getTime());
                            DateMidnight firstDayWeek = todayMidnight.minusDays(now.dayOfWeek().get() - 1);
                            if (date.getTime() < firstDayWeek.getMillis()) {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(firstDayWeek.getMillis()))).append(((Object[]) data.get(i))[2]).toString());
                            } else {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(date.getTime()))).append(((Object[]) data.get(i))[2]).toString());
                            }
                        } else if (filter.equals(""30"")) {
                            DateMidnight todayMidnight = new DateMidnight(utilsManager.getActualTimestamp().getTime());
                            DateMidnight firstDayMonth = todayMidnight.minusDays(now.dayOfMonth().get() - 1);
                            if (date.getTime() < firstDayMonth.getMillis()) {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(firstDayMonth.getMillis()))).append(((Object[]) data.get(i))[2]).toString());
                            } else {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(date.getTime()))).append(((Object[]) data.get(i))[2]).toString());
                            }
                        }
                        continue;
                    }
                    if (i > 0) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(((Date) ((Object[]) data.get(i))[1]).getTime()).minusMillis(1))).append(((Object[]) data.get(i - 1))[2]).toString());
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(((Date) ((Object[]) data.get(i))[1]).getTime()))).append(((Object[]) data.get(i))[2]).toString());
                    }
                }
                if (data.size() > 0) {
                    Date date = ((Date) ((Object[]) data.get(data.size() - 1))[3]);
                    if (date.getTime() > now.getMillis()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(utilsManager.getActualTimestamp().getTime()))).append(((Object[]) data.get(data.size() - 1))[2]).toString());
                    }
                }
            }
        } else if (mdl.equals(""15"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                for (int i = 0; i < data.size(); i++) {
                    OsmHistSysmark osmHistSysmark = (OsmHistSysmark) data.get(i);
                    dt = new DateTime(osmHistSysmark.getId().getDtiInimark().getTime());
                    if (i > 0) {
                        OsmHistSysmark prevOsmHistSysmark = (OsmHistSysmark) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevOsmHistSysmark.getId().getNumMark()).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(osmHistSysmark.getId().getNumMark()).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSysmark.getId().getNumMark()).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSysmark.getId().getNumMark()).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    OsmHistSysmark lastHistSysmark = (OsmHistSysmark) data.get(data.size() - 1);
                    OsmSysmark osmSysmark = (OsmSysmark) model.get(""activeData"");
                    String month = (String) model.get(""month"");
                    if (osmSysmark != null) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(osmSysmark.getId().getDtiMark().getTime()).minusMillis(1))).append(lastHistSysmark.getId().getNumMark()).toString());
                        if (osmSysmark.getId().getDtiMark().getTime() > dateFin.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(osmSysmark.getId().getNumMark()).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(osmSysmark.getId().getDtiMark()))).append(osmSysmark.getId().getNumMark()).toString());
                        }
                    }
                }
            }
        } else if (mdl.equals(""16"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                for (int i = 0; i < data.size(); i++) {
                    OsmHistSlamarks osmHistSlamark = (OsmHistSlamarks) data.get(i);
                    dt = new DateTime(osmHistSlamark.getId().getDtiInimark().getTime());
                    if (i > 0) {
                        OsmHistSlamarks prevOsmHistSlamark = (OsmHistSlamarks) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevOsmHistSlamark.getId().getNumMark()).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(osmHistSlamark.getId().getNumMark()).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSlamark.getId().getNumMark()).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSlamark.getId().getNumMark()).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    OsmHistSlamarks lastHistSlamark = (OsmHistSlamarks) data.get(data.size() - 1);
                    if (lastHistSlamark.getId().getDtiFinmark().getTime() > dateFin.getTime()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(lastHistSlamark.getId().getNumMark()).toString());
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(lastHistSlamark.getId().getDtiFinmark().getTime()))).append(lastHistSlamark.getId().getNumMark()).toString());
                    }
                }
            }
        } else if (mdl.equals(""17"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                long time, prevTime;
                Integer value = null, prevValue = null;
                for (int i = 0; i < data.size(); i++) {
                    time = ((DatesValue) data.get(i)).getDateIni().getTime();
                    value = ((DatesValue) data.get(i)).getValue();
                    dt = new DateTime(time);
                    if (i > 0) {
                        prevValue = ((DatesValue) data.get(i - 1)).getValue();
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(time).minusMillis(1))).append(prevValue));
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(value).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    DatesValue lastDatesValue = (DatesValue) data.get(data.size() - 1);
                    if (lastDatesValue.getDateIni().getTime() > dateFin.getTime()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(lastDatesValue.getValue()).toString());
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(lastDatesValue.getDateFin().getTime()))).append(lastDatesValue.getValue()).toString());
                    }
                }
            }
        } else if (mdl.equals(""18"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                for (int i = 0; i < data.size(); i++) {
                    EventValue value = (EventValue) data.get(i);
                    dt = new DateTime(value.dtiInievent.getTime());
                    if (i > 0) {
                        EventValue prevEventValue = (EventValue) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevEventValue.numValue).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(value.numValue).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    Date now = new Date(utilsManager.getActualTimestamp().getTime());
                    EventValue lastEventValue = (EventValue) data.get(data.size() - 1);
                    if (dateFin.getTime() > now.getTime()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(now.getTime()))).append(lastEventValue.numValue).toString());
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(lastEventValue.numValue).toString());
                    }
                }
            }
        } else if (mdl.equals(""19"")) {
            response.setContentType(""text/plain"");
            Integer days = (Integer) model.get(""days"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                DateTime dateIni = new DateTime().minusDays(days);
                Date dateFin = new Date(utilsManager.getActualTimestamp().getTime());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(dateIni)).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = new Date(new DateTime().minusDays(days).getMillis());
                for (int i = 0; i < data.size(); i++) {
                    EventValue value = (EventValue) data.get(i);
                    dt = new DateTime(value.dtiInievent.getTime());
                    if (i > 0) {
                        EventValue prevEventValue = (EventValue) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevEventValue.numValue).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(value.numValue).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date now = new Date(utilsManager.getActualTimestamp().getTime());
                    EventValue lastEventValue = (EventValue) data.get(data.size() - 1);
                    out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(now.getTime()))).append(lastEventValue.numValue).toString());
                }
            }
        } else if (mdl.equals(""20"")) {
            String id = request.getParameter(""id"");
            List data = (List) model.get(""data"");
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th ></th><th></th><th></th></tr>"");
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            for (int i = 0; i < data.size(); i++) {
                long prcValue = (Long) ((Object[]) data.get(i))[0];
                StringBuffer tmp = new StringBuffer();
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(typCri.getPthLogocriticity()).append(""\""></td><td>"").append(decodeCriticity(data, i)).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcCriSrv', "" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""21"")) {
            String id = request.getParameter(""id"");
            Integer[] data = (Integer[]) model.get(""dataPrc"");
            int total = 0;
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th ></th><th></th><th></th></tr>"");
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            for (int i = 0; i < data.length; i++) {
                int value = data[i];
                long prcValue = Math.round(100 * value / total);
                StringBuffer tmp = new StringBuffer();
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(i == 0 ? ""/images/logoalmalr.png"" : ""/images/logoalminfo.png"").append(""\""/></td><td>"").append(i == 0 ? text.getMessage(""graphs.NotAvailable"") : text.getMessage(""graphs.Available"")).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcAvaIns',"" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""22"")) {
            String id = request.getParameter(""id"");
            List data = (List) model.get(""data"");
            double total = 0;
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th></th><th></th><th></th></tr>"");
            for (int i = 0; i < data.size(); i++) {
                total += (Long) ((Object[]) data.get(i))[0];
            }
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            for (int i = 0; i < data.size(); i++) {
                Long value = (Long) ((Object[]) data.get(i))[0];
                long prcValue = Math.round(100 * value / total);
                StringBuffer tmp = new StringBuffer();
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(typCri.getPthLogocriticity()).append(""\""/></td><td>"").append(decodeCriticity(data, i)).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcCriIns', "" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""23"")) {
            out.println(""<select name=\""users\"" id=\""users\"" class=\""form OsmMediumCbo\"">"");
            List users = (List) model.get(""users"");
            if (users.size() > 0) {
                out.println(""<option value='ALL'>ALL</option>"");
            }
            for (int i = 0; i < users.size(); i++) {
                OsmUser osmUser = (OsmUser) users.get(i);
                out.println(new StringBuilder().append(""<option value=\'"").append(osmUser.getIdnUser()).append(""'>"").append(osmUser.getIdnUser()).append(""</option>"").toString());
            }
            out.println(""</select>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""testUsers();"");
            out.print(""</script>"");
        } else if (mdl.equals(""24"")) {
            TypInstancesInfo[] info = (TypInstancesInfo[]) model.get(""info"");
            out.println(""<table border=\""1\"">"");
            out.print(""<tr>"");
            out.println(""<th>"");
            out.print(""Type"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""#"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""OK"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""WR"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""CR"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""ER"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""UP"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""DOWN"");
            out.println(""</th>"");
            out.println(""</tr>"");
            for (int i = 0; i < info.length; i++) {
                out.println(""<tr>"");
                TypInstancesInfo typInstancesInfo = info[i];
                out.print(""<td>"");
                out.print(typInstancesInfo.getTypInstance());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getTotal());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getOK());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getWR());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getCR());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getER());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getAva());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getNotAva());
                out.print(""</td>"");
                out.println(""</tr>"");
            }
            out.println(""</table>"");
        } else if (mdl.equals(""28"")) {
            String id = request.getParameter(""id"");
            Integer[] data = (Integer[]) model.get(""dataPrc"");
            int total = 0;
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th ></th><th></th><th></th></tr>"");
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            for (int i = 0; i < data.length; i++) {
                int value = data[i];
                long prcValue = Math.round(100 * value / total);
                StringBuffer tmp = new StringBuffer();
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(i == 0 ? ""/images/logoalmalr.png"" : ""/images/logoalminfo.png"").append(""\""/></td><td>"").append(i == 0 ? text.getMessage(""graphs.NotAvailable"") : text.getMessage(""graphs.Available"")).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcAvaSrv',"" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""100"")) {
            StringBuilder json = new StringBuilder(""[{data:["");
            List data = (List) model.get(""data"");
            for (int i = 0; i < data.size(); i++) {
                EventValue value = (EventValue) data.get(i);
                if (i > 1) {
                    json.append(""["").append(((EventValue) data.get(i - 1)).dtiInievent.getTime()).append("","").append(value.numValue).append(""],"");
                }
                json.append(""["").append(value.dtiInievent.getTime()).append("","").append(value.numValue).append(""],"");
            }
            List activeData = (List) model.get(""activeData"");
            for (int i = 0; i < activeData.size(); i++) {
                OsmActiveevent osmActiveevent = (OsmActiveevent) activeData.get(i);
                json.append(""["").append(osmActiveevent.getDtiInievent().getTime()).append("","").append(osmActiveevent.getNumValue()).append(""],"");
            }
            json.deleteCharAt(json.length() - 1);
            json.append(""]}]"");
            out.print(json.toString());
        } else if (mdl.equals(""50"")) {
            Float[] data = (Float[]) model.get(""dataPrc"");
            float total = 0;
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            StringBuilder tmp = new StringBuilder();
            double noAva = 100 * data[0] / total;
            noAva = noAva > 0 ? Math.floor(noAva * 100) / 100.0 : Math.ceil(noAva * 100) / 100.0;
            double ava = 100 * data[1] / total;
            ava = ava > 0 ? Math.floor(ava * 100) / 100.0 : Math.ceil(ava * 100) / 100.0;
            if (ava == 100) {
                ava = 99.9;
                noAva = 0.1;
            }
            if (noAva == 100) {
                noAva = 99.9;
                ava = 0.1;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(noAva).append("", color:'#f00'},{ label: \""\"",  data:"").append(ava).append("", color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""51"")) {
            List data = (List) model.get(""data"");
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            double[] values = new double[4];
            for (int i = 0; i < data.size(); i++) {
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                double prcValue = (Double) ((Object[]) data.get(i))[0];
                prcValue = prcValue > 0 ? Math.floor(prcValue * 100) / 100.0 : Math.ceil(prcValue * 100) / 100.0;
                if (typCri.getTypCriticity() == 0) values[0] = prcValue; else if (typCri.getTypCriticity() == 1) values[1] = prcValue; else if (typCri.getTypCriticity() == 2) values[2] = prcValue; else if (typCri.getTypCriticity() == 99) values[3] = prcValue;
            }
            StringBuilder tmp = new StringBuilder();
            if (values[0] == 100) {
                values[0] = 99.9;
                values[1] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[1] == 100) {
                values[1] = 99.9;
                values[0] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[2] == 100) {
                values[2] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[3] = 0;
            }
            if (values[3] == 100) {
                values[3] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[2] = 0;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(values[0]).append("", color:'#0f0'},{ label: \""\"",  data:"").append(values[1]).append("", color:'#fd0'},{ label: \""\"",  data:"").append(values[2]).append("", color:'#f00'},{ label: \""\"",  data:"").append(values[3]).append("", color:'#00f'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""52"")) {
            String id = request.getParameter(""id"");
            Integer[] data = (Integer[]) model.get(""dataPrc"");
            int total = 0;
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            StringBuilder tmp = new StringBuilder();
            double noAva = 100 * data[0] / total;
            noAva = noAva > 0 ? Math.floor(noAva * 100) / 100.0 : Math.ceil(noAva * 100) / 100.0;
            double ava = 100 * data[1] / total;
            ava = ava > 0 ? Math.floor(ava * 100) / 100.0 : Math.ceil(ava * 100) / 100.0;
            if (ava == 100) {
                ava = 99.9;
                noAva = 0.1;
            }
            if (noAva == 100) {
                noAva = 99.9;
                ava = 0.1;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(noAva).append("", color:'#f00'},{ label: \""\"",  data:"").append(ava).append("", color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""53"")) {
            List data = (List) model.get(""data"");
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            double[] values = new double[4];
            for (int i = 0; i < data.size(); i++) {
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                double prcValue = (Double) ((Object[]) data.get(i))[0];
                prcValue = prcValue > 0 ? Math.floor(prcValue * 100) / 100.0 : Math.ceil(prcValue * 100) / 100.0;
                if (typCri.getTypCriticity() == 0) values[0] = prcValue; else if (typCri.getTypCriticity() == 1) values[1] = prcValue; else if (typCri.getTypCriticity() == 2) values[2] = prcValue; else if (typCri.getTypCriticity() == 99) values[3] = prcValue;
            }
            StringBuilder tmp = new StringBuilder();
            if (values[0] == 100) {
                values[0] = 99.9;
                values[1] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[1] == 100) {
                values[1] = 99.9;
                values[0] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[2] == 100) {
                values[2] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[3] = 0;
            }
            if (values[3] == 100) {
                values[3] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[2] = 0;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(values[0]).append("", color:'#0f0'},{ label: \""\"",  data:"").append(values[1]).append("", color:'#fd0'},{ label: \""\"",  data:"").append(values[2]).append("", color:'#f00'},{ label: \""\"",  data:"").append(values[3]).append("", color:'#00f'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""54"")) {
            List data = (List) model.get(""data"");
            int[] values = new int[4];
            int max = 0;
            int step = 0;
            for (int i = 0; i < data.size(); i++) {
                if (((Criticity) data.get(i)).getCriticty() == 0) {
                    values[0] = ((Criticity) data.get(i)).getValue();
                } else if (((Criticity) data.get(i)).getCriticty() == 1) {
                    values[1] = ((Criticity) data.get(i)).getValue();
                } else if (((Criticity) data.get(i)).getCriticty() == 2) {
                    values[2] = ((Criticity) data.get(i)).getValue();
                } else if (((Criticity) data.get(i)).getCriticty() == 99) {
                    values[3] = ((Criticity) data.get(i)).getValue();
                }
                if (((Criticity) data.get(i)).getValue() > max) {
                    max = ((Criticity) data.get(i)).getValue();
                }
            }
            if (max > 0) {
                step = max / 4;
            }
            int total = (step * 5) > max ? step * 5 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#0f0'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#fc7'},"").append("" {label:'', data:[[3,"").append(values[2]).append(""]], color:'#f00'},"").append("" {label:'', data:[[4,"").append(values[3]).append(""]], color:'#888'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""55"")) {
            List alarms = (List) model.get(""alarms"");
            Integer[] states = (Integer[]) model.get(""states"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            int[] values = new int[4];
            int max = 0;
            int step = 1;
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            OsmTypcriticity osmTypcriticity;
            for (int i = 0; i < states.length; i += 2) {
                osmTypcriticity = (OsmTypcriticity) hashOsmTypalarms.get(states[i]);
                if (osmTypcriticity.getTypCriticity() == 0) {
                    values[0] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 1) {
                    values[1] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 2) {
                    values[2] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 99) {
                    values[3] = states[i + 1];
                }
                if (states[i + 1] > max) {
                    max = states[i + 1];
                }
            }
            if (max > 0) {
                step = max / 4;
            }
            int total = (step * 5) > max ? step * 5 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#0f0'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#fc7'},"").append("" {label:'', data:[[3,"").append(values[2]).append(""]], color:'#f00'},"").append("" {label:'', data:[[4,"").append(values[3]).append(""]], color:'#888'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""56"")) {
            List states = (List) model.get(""states"");
            long[] values = new long[2];
            long max = 0;
            long step = 1;
            for (int i = 0; i < states.size(); i++) {
                long _value = (Long) ((Object[]) states.get(i))[0];
                if (((Integer) ((Object[]) states.get(i))[1]) == 0) {
                    values[0] = _value;
                } else {
                    values[1] = _value;
                }
                if (_value > max) {
                    max = _value;
                }
            }
            if (max > 0) {
                step = max / 2;
            }
            long total = (step * 3) > max ? step * 3 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#f00'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""57"")) {
            List alarms = (List) model.get(""alarms"");
            Integer[] states = (Integer[]) model.get(""states"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            int[] values = new int[4];
            int max = 0;
            int step = 1;
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            OsmTypcriticity osmTypcriticity;
            for (int i = 0; i < states.length; i += 2) {
                osmTypcriticity = (OsmTypcriticity) hashOsmTypalarms.get(states[i]);
                if (osmTypcriticity.getTypCriticity() == 0) {
                    values[0] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 1) {
                    values[1] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 2) {
                    values[2] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 99) {
                    values[3] = states[i + 1];
                }
                if (states[i + 1] > max) {
                    max = states[i + 1];
                }
            }
            if (max > 0) {
                step = max / 4;
            }
            int total = (step * 5) > max ? step * 5 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#0f0'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#fc7'},"").append("" {label:'', data:[[3,"").append(values[2]).append(""]], color:'#f00'},"").append("" {label:'', data:[[4,"").append(values[3]).append(""]], color:'#888'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""58"")) {
            List states = (List) model.get(""states"");
            long[] values = new long[2];
            long max = 0;
            long step = 1;
            for (int i = 0; i < states.size(); i++) {
                long _value = (Long) ((Object[]) states.get(i))[0];
                if (((Integer) ((Object[]) states.get(i))[1]) == 0) {
                    values[0] = _value;
                } else {
                    values[1] = _value;
                }
                if (_value > max) {
                    max = _value;
                }
            }
            if (max > 0) {
                step = max / 2;
            }
            long total = (step * 3) > max ? step * 3 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#f00'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""59"")) {
            String mib = (String) model.get(""mib"");
            out.print(""{\""mib\"":\"""" + (mib == null ? """" : mib) + ""\""}"");
        } else if (mdl.equals(""60"")) {
            List mibs = (List) model.get(""mibs"");
            if (mibs.size() > 0) {
                StringBuilder str = new StringBuilder(""{\""mibs\"":["");
                for (int i = 0; i < mibs.size(); i++) {
                    String data = (String) mibs.get(i);
                    if (i == 0) {
                        str.append(""{\""mib\"":\"""").append(data).append(""\""}"");
                    } else {
                        str.append("",{\""mib\"":\"""").append(data).append(""\""}"");
                    }
                }
                str.append(""]}"");
                out.print(str.toString());
            } else {
                out.print(""{\""mibs\"":[]}"");
            }
        } else if (mdl.equals(""61"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            Boolean ok = (Boolean) model.get(""ok"");
            String error = (String) model.get(""error"");
            TestGenericErrors test = new TestGenericErrors(ok, new String[] { error });
            JSONObject json = JSONObject.fromObject(test);
            out.print(json);
        } else if (mdl.equals(""62"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            Boolean exists = (Boolean) model.get(""exists"");
            TestGeneric test = new TestGeneric(exists);
            JSONObject json = JSONObject.fromObject(test);
            out.print(json);
        } else if (mdl.equals(""63"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            Boolean isHoliday = (Boolean) model.get(""isHoliday"");
            TestGeneric test = new TestGeneric(isHoliday);
            JSONObject json = JSONObject.fromObject(test);
            out.print(json);
        } else if (mdl.equals(""64"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List typInstances = (List) model.get(""typInstances"");
            List[] instances = (List[]) model.get(""instances"");
            String id = (String) model.get(""id"");
            StringBuilder str = new StringBuilder();
            str.append(""{\""id\"":\"""").append(id).append(""_Osmius\"",\""name\"":\""Osmius\"",\""children\"":["");
            for (int i = 0; i < typInstances.size(); i++) {
                OsmTypinstance osmTypinstance = (OsmTypinstance) typInstances.get(i);
                if (i > 0) {
                    str.append("","");
                }
                str.append(""{\""id\"":\"""").append(id).append(""_typ_"").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""name\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""data\"":{"");
                str.append(""\""description\"":\"""").append(osmTypinstance.getDesTypinstance()).append(""\"","");
                str.append(""\""typInst\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""imgIndex\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""img\"":\"""").append(osmTypinstance.getPthLogoinstance()).append(""\"""");
                str.append(""}, \""children\"":["");
                List tmpInst = instances[i];
                for (int j = 0; j < tmpInst.size(); j++) {
                    OsmInstance osmInstance = (OsmInstance) tmpInst.get(j);
                    if (j > 0) {
                        str.append("","");
                    }
                    str.append(""{\""id\"":\"""").append(id).append(""_"").append(osmInstance.getIdnInstance()).append(""\"","");
                    str.append(""\""name\"":\"""").append(osmInstance.getIdnInstance()).append(""\"","");
                    str.append(""\""data\"":{"");
                    str.append(""\""description\"":\"""").append(osmInstance.getDesInstance()).append(""\"","");
                    str.append(""\""severity\"":\"""").append(osmInstance.getOsmTypcriticity().getTypCriticity()).append(""\"","");
                    str.append(""\""availability\"":\"""").append(osmInstance.getIndAvailability()).append(""\"""");
                    str.append(""},\""children\"":[]}"");
                }
                str.append(""]}"");
            }
            str.append(""],\""data\"":\""\""}"");
            out.print(str.toString());
        } else if (mdl.equals(""65"") || mdl.equals(""66"") || mdl.equals(""67"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            String json = (String) model.get(""json"");
            if (json != null) out.print(json);
        } else if (mdl.equals(""70"") || mdl.equals(""74"") || mdl.equals(""75"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            String json = (String) model.get(""JSONInstances"");
            if (json != null) out.print(json);
        } else if (mdl.equals(""71"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List acte = (List) model.get(""activeevents"");
            List trape = (List) model.get(""trapactiveevents"");
            StringBuilder json = new StringBuilder(""{ \""events\"":["");
            for (int i = 0; i < acte.size(); i++) {
                OsmTypevent obj = (OsmTypevent) acte.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj.getId().getTypEvent()).append(""\"",\""desEvent\"":\"""").append(obj.getDesTypevent()).append(""\"",\""defGraph\"":\"""").append(obj.getDefGraph()).append(""\""}"");
            }
            json.append(""],\""traps\"":["");
            for (int i = 0; i < trape.size(); i++) {
                String[] obj = (String[]) trape.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj[0]).append(""\"",\""desEvent\"":\"""").append(obj[1]).append(""\""}"");
            }
            json.append(""]}"");
            out.print(json.toString());
        } else if (mdl.equals(""72"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List typInstances = (List) model.get(""typInstances"");
            StringBuilder json = new StringBuilder();
            json.append(""["");
            for (int i = 0; i < typInstances.size(); i++) {
                OsmTypinstance osmTypinstance = (OsmTypinstance) typInstances.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typInstance\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"",\""desTypinstance\"":\"""").append(osmTypinstance.getDesTypinstance()).append(""\""}"");
            }
            json.append(""]"");
            out.print(json.toString());
        } else if (mdl.equals(""73"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List typEvents = (List) model.get(""typEvents"");
            List trapEvents = (List) model.get(""trapEvents"");
            StringBuilder json = new StringBuilder(""{ \""events\"":["");
            for (int i = 0; i < typEvents.size(); i++) {
                OsmTypevent obj = (OsmTypevent) typEvents.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj.getId().getTypEvent()).append(""\"",\""desEvent\"":\"""").append(obj.getDesTypevent()).append(""\""}"");
            }
            json.append(""],\""traps\"":["");
            for (int i = 0; i < trapEvents.size(); i++) {
                String[] obj = (String[]) trapEvents.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj[0]).append(""\"",\""desEvent\"":\"""").append(obj[1]).append(""\""}"");
            }
            json.append(""]}"");
            out.print(json.toString());
        }
    }
"
9173,13837593,7,"    public Item dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        int random = StdRandom.uniform(N);
        Node n = (Node) array[random];
        Item item = n.item;
        Node prev = n.previous;
        Node next = n.next;
        if (prev == null) {
            if (next == null) {
                first = null;
                last = null;
                N--;
            } else {
                first = next;
                first.previous = null;
                N--;
            }
        } else {
            if (next == null) {
                last = n.previous;
                last.next = null;
                N--;
            } else {
                prev.next = n.next;
                next.previous = prev;
                N--;
            }
        }
        for (int i = random; i < N; i++) {
            array[i] = array[i + 1];
        }
        return item;
    }
"
11294,17323499,7,"    public static PredictionData deserialize(File dbFile) throws IOException, DataFileException {
        if ((dbFile == null) || (!dbFile.exists())) {
            return null;
        }
        FileInputStream fis = new FileInputStream(dbFile);
        CsvReader reader = new CsvReader(fis);
        String[] values = reader.getNextValidLine();
        int peptideCount = Integer.parseInt(values[0]);
        int initialCapacity = 5 * peptideCount / 4;
        int alleleCount = values.length - 1;
        String[] alleles = new String[alleleCount];
        for (int i = 0; i < alleleCount; i++) {
            alleles[i] = values[i + 1];
        }
        PredictionData result = new PredictionData(alleles, initialCapacity);
        while ((values = reader.getNextValidLine()) != null) {
            if (values.length != alleleCount + 1) {
                throw new DataFileException(""Error at line "" + reader.getLineNumber() + "" of file "" + dbFile.getCanonicalPath() + "": incorrect number of values, expected "" + (alleleCount + 1) + "", found "" + values.length);
            }
            String peptide = values[0];
            float[] predValues = new float[alleles.length];
            for (int i = 0; i < alleleCount; i++) {
                predValues[i] = PredictionData.NO_PREDICTION;
                String valueString = values[i + 1];
                if ((valueString != null) && (valueString.length() > 0)) {
                    try {
                        predValues[i] = Float.parseFloat(valueString);
                    } catch (Exception e) {
                        throw new DataFileException(""Error at line "" + reader.getLineNumber() + "" of file "" + dbFile.getCanonicalPath() + "": value for "" + alleles[i] + "" is not a valid number. Value found: "" + valueString);
                    }
                }
            }
            result.setPredictions(peptide, predValues);
        }
        fis.close();
        return result;
    }
"
8011,11703169,7,"    public IBond removeBond(int position) {
        IBond bond = bonds[position];
        bond.removeListener(this);
        for (int i = position; i < bondCount - 1; i++) {
            bonds[i] = bonds[i + 1];
        }
        bonds[bondCount - 1] = null;
        bondCount--;
        notifyChanged();
        return bond;
    }
"
4787,5496245,7,"    public void randomize(IntegerChromosome chrom, int min, int max) {
        int len = max - min + 1;
        int[] base = new int[len];
        for (int i = 0; i < len; i++) base[i] = chrom.getValue(min + i);
        for (int i = 0; len > 0; --len, ++i) {
            int pos = Random.getInstance().nextInt(0, len);
            chrom.setValue(min + i, base[pos]);
            for (int j = pos; j < (len - 1); j++) {
                base[j] = base[j + 1];
            }
        }
    }
"
8137,12248116,7,"    public void deleteItem(int posToDelete) {
        for (int i = posToDelete; i < size - 1; i++) {
            A[i] = A[i + 1];
            B[i] = B[i + 1];
            similarity[i] = similarity[i + 1];
        }
        size--;
    }
"
1533,727155,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
10467,16035291,7,"    private void condenseArray(int start) {
        for (int i = start; i < size; i++) {
            values[i] = values[i + 1];
        }
    }
"
9199,13904321,7,"    public void reComputeFunctionValueAndGradient(double[] weights) {
        double[] weights2 = weights;
        if (shouldComputeGradientForScalingFactor) {
            if (weights.length != numFeatures + 1) {
                System.out.println(""number of weights is not right"");
                System.exit(1);
            }
            scalingFactor = weights[0];
            weights2 = new double[numFeatures];
            for (int i = 0; i < numFeatures; i++) weights2[i] = weights[i + 1];
        }
        for (int i = 0; i < numFeatures; i++) gradientsForTheta[i] = 0;
        if (shouldComputeGradientForScalingFactor) gradientForScalingFactor = 0;
        functionValue = 0;
        redoCorpusInference(weights2, scalingFactor);
        computeCorpusGradient(weights2, gradientsForTheta, temperature, scalingFactor);
        computeCorpusFuncVal(temperature);
    }
"
9593,14370631,7,"    public Object apply(Context context, Object[] args) {
        if (args.length < 1) {
            throw new BadArgument(""Wrong number of arguments to bind()"");
        }
        if (args[0] == null) {
            throw new NullArgument(""Null first argument to bind()"");
        }
        if (!(args[0] instanceof Function)) {
            throw new TypeError(""First argument to bind() not a function"");
        }
        if (args.length == 1) {
            return args[0];
        }
        Object[] objs = new Object[args.length - 1];
        for (int i = 0; i < objs.length; ++i) {
            objs[i] = args[i + 1];
        }
        return new BoundLastFunction((Function) args[0], objs);
    }
"
10730,16405052,7,"    void setSources(int nArgs, FtsAtom[] args) {
        sources = new String[nArgs / 2];
        sourceChannels = new int[nArgs / 2];
        int j = 0;
        for (int i = 0; i < nArgs; i += 2) {
            sources[j] = args[i].symbolValue.toString();
            sourceChannels[j] = args[i + 1].intValue;
            j++;
        }
        if (listener != null) listener.sourcesChanged();
    }
"
339,127080,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
3989,4278492,7,"    public NamedPolicyEvaluator[] deleteEvals(NamedPolicyEvaluator[] orig_npe, NamedPolicyEvaluator[] policy_evaluator_list) {
        boolean present;
        int k, curr_length = orig_npe.length;
        for (int i = 0; i < policy_evaluator_list.length; i++) {
            present = false;
            for (int j = 0; j < curr_length; i++) {
                if (orig_npe[j].evaluator_name.equals(policy_evaluator_list[i].evaluator_name)) {
                    for (k = j; k < curr_length - 1; k++) {
                        orig_npe[k] = orig_npe[k + 1];
                    }
                    curr_length--;
                    present = true;
                }
            }
            if (!present) {
                return null;
            }
        }
        NamedPolicyEvaluator[] npe = new NamedPolicyEvaluator[curr_length];
        for (int i = 0; i < curr_length; i++) {
            npe[i] = orig_npe[i];
        }
        return npe;
    }
"
2444,1637024,7,"    private float[] evenFiltering(float[] src, int z) throws ErrorException {
        int subbandSize = src.length;
        int half = subbandSize / 2;
        float dst[] = new float[subbandSize];
        for (int k = 0; k < half; k++) {
            dst[2 * k] = src[k];
            dst[2 * k + 1] = src[half + k];
        }
        if (WTTypes[z] == 1) {
            dst[0] = dst[0] - (float) (Math.floor(((dst[1] + dst[1] + 2) / 4)));
            for (int k = 2; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - (float) (Math.floor(((dst[k - 1] + dst[k + 1] + 2) / 4)));
            }
            for (int k = 1; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] + (float) (Math.floor(((dst[k - 1] + dst[k + 1]) / 2)));
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] + (float) (Math.floor((dst[subbandSize - 2] + dst[subbandSize - 2]) / 2));
        } else if (WTTypes[z] == 2 || WTTypes[z] == 3) {
            final float alfa_97 = -1.586134342059924F;
            final float beta_97 = -0.052980118572961F;
            final float gamma_97 = 0.882911075530934F;
            final float delta_97 = 0.443506852043971F;
            final float nh_97, nl_97;
            if (WTTypes[z] == 2) {
                nh_97 = 1.230174104914001F;
                nl_97 = 1F / nh_97;
            } else {
                nl_97 = 1.14960430535816F;
                nh_97 = -1F / nl_97;
            }
            for (int k = 0; k < subbandSize; k += 2) {
                dst[k] = dst[k] / nl_97;
                dst[k + 1] = dst[k + 1] / nh_97;
            }
            dst[0] = dst[0] - delta_97 * (dst[1] + dst[1]);
            for (int k = 2; k < subbandSize; k += 2) {
                dst[k] = dst[k] - delta_97 * (dst[k - 1] + dst[k + 1]);
            }
            for (int k = 1; k < subbandSize - 2; k += 2) {
                dst[k] = dst[k] - gamma_97 * (dst[k - 1] + dst[k + 1]);
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] - gamma_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
            dst[0] = dst[0] - beta_97 * (dst[1] + dst[1]);
            for (int k = 2; k < subbandSize; k += 2) {
                dst[k] = dst[k] - beta_97 * (dst[k - 1] + dst[k + 1]);
            }
            for (int k = 1; k < subbandSize - 2; k += 2) {
                dst[k] = dst[k] - alfa_97 * (dst[k - 1] + dst[k + 1]);
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] - alfa_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
        } else if (WTTypes[z] == 4) {
            if (subbandSize >= 6) {
                final float alfa1 = (9F / 16F);
                final float alfa2 = (1F / 16F);
                final float beta = (1F / 4F);
                dst[0] = dst[0] + (float) (Math.floor(-beta * (dst[1] + dst[1]) + 0.5));
                for (int k = 2; k < subbandSize; k += 2) {
                    dst[k] = dst[k] + (float) (Math.floor(-beta * (dst[k - 1] + dst[k + 1]) + 0.5));
                }
                dst[1] = dst[1] + (float) (Math.floor(alfa1 * (dst[0] + dst[2]) - alfa2 * (dst[2] + dst[4]) + 0.5));
                for (int k = 3; k < subbandSize - 3; k += 2) {
                    dst[k] = dst[k] + (float) (Math.floor(alfa1 * (dst[k - 1] + dst[k + 1]) - alfa2 * (dst[k - 3] + dst[k + 3]) + 0.5));
                }
                dst[subbandSize - 3] = dst[subbandSize - 3] + (float) (Math.floor(alfa1 * (dst[subbandSize - 4] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 6] + dst[subbandSize - 2]) + 0.5));
                dst[subbandSize - 1] = dst[subbandSize - 1] + (float) (Math.floor(alfa1 * (dst[subbandSize - 2] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 4] + dst[subbandSize - 4]) + 0.5));
            } else {
                throw new ErrorException(""Size should be greater or equal than 6 in order to perform 9/7M"");
            }
        } else if (WTTypes[z] == 5 || WTTypes[z] == 6) {
            final float alfa, beta, gamma, delta;
            if (WTTypes[z] == 6) {
                alfa = -1.58615986717275F;
                beta = -0.05297864003258F;
                gamma = 0.88293362717904F;
                delta = 0.44350482244527F;
            } else {
                alfa = -0.5F;
                beta = 0.25F;
                gamma = 0.F;
                delta = 0.F;
            }
            if (WTTypes[z] == 6) {
                dst[0] = dst[0] - (float) Math.floor(delta * (dst[1] + dst[1]) + 0.5);
                for (int k = 2; k < subbandSize; k += 2) {
                    dst[k] = dst[k] - (float) Math.floor(delta * (dst[k - 1] + dst[k + 1]) + 0.5);
                }
                for (int k = 1; k < subbandSize - 2; k += 2) {
                    dst[k] = dst[k] - (float) Math.floor(gamma * (dst[k - 1] + dst[k + 1]) + 0.5);
                }
                dst[subbandSize - 1] = dst[subbandSize - 1] - (float) Math.floor(gamma * (dst[subbandSize - 2] + dst[subbandSize - 2]) + 0.5);
            }
            dst[0] = dst[0] - (float) Math.floor(beta * (dst[1] + dst[1]) + 0.5);
            for (int k = 2; k < subbandSize; k += 2) {
                dst[k] = dst[k] - (float) Math.floor(beta * (dst[k - 1] + dst[k + 1]) + 0.5);
            }
            for (int k = 1; k < subbandSize - 2; k += 2) {
                dst[k] = dst[k] - (float) Math.floor(alfa * (dst[k - 1] + dst[k + 1]) + 0.5);
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] - (float) Math.floor(alfa * (dst[subbandSize - 2] + dst[subbandSize - 2]) + 0.5);
        } else if (WTTypes[z] == 7) {
            float sample1 = 0, sample2 = 0;
            float normFactor = (float) (Math.sqrt(2));
            for (int k = 0; k < subbandSize; k += 2) {
                sample1 = dst[k] + dst[k + 1];
                sample2 = dst[k] - dst[k + 1];
                dst[k] = sample1 * normFactor;
                dst[k + 1] = sample2 * normFactor;
            }
        } else if (WTTypes[z] == 8) {
            float s = 0;
            for (int k = 0; k < subbandSize; k += 2) {
                s = dst[k] - (float) Math.floor(dst[k + 1] / 2);
                dst[k] = dst[k + 1] + s;
                dst[k + 1] = s;
            }
        } else {
            throw new ErrorException(""Unrecognized wavelet transform type."");
        }
        return dst;
    }
"
9066,13658392,7,"    public void transpose() {
        int temp;
        if (bounds != null) bounds.transpose();
        for (int i = 0; i < size * 2; i += 2) {
            temp = points[i];
            points[i] = points[i + 1];
            points[i + 1] = temp;
        }
    }
"
11986,18532865,7,"    private static LinkedList delauny(Vertex avertex[]) {
        LinkedList linkedlist = new LinkedList();
        for (int i = 0; i < steps * 3; i++) {
            Vertex avertex1[] = new Vertex[3];
            avertex1[0] = avertex[i];
            avertex1[1] = avertex[i + 1];
            avertex1[2] = delauny_sub(avertex, avertex[i], avertex[i + 1]);
            if ((i <= 0 || !avertex1[2].same_position(avertex[i - 1])) && (i != 0 || !avertex1[2].same_position(avertex[steps * 3 - 1]))) linkedlist.append(avertex1);
        }
        if (linkedlist.size() == 10) return linkedlist;
        Enumeration enumeration = linkedlist.elements();
        Vertex avertex5[] = new Vertex[3];
        while (enumeration.hasMoreElements()) {
            Vertex avertex2[] = (Vertex[]) enumeration.nextElement();
            Vertex vertex = avertex2[2];
            if (get_origin(avertex, vertex) == 1) {
                avertex5[0] = avertex2[0];
                break;
            }
        }
        while (enumeration.hasMoreElements()) {
            Vertex avertex3[] = (Vertex[]) enumeration.nextElement();
            Vertex vertex1 = avertex3[2];
            if (get_origin(avertex, vertex1) == 2) {
                avertex5[1] = avertex3[0];
                break;
            }
        }
        while (enumeration.hasMoreElements()) {
            Vertex avertex4[] = (Vertex[]) enumeration.nextElement();
            Vertex vertex2 = avertex4[2];
            if (get_origin(avertex, vertex2) == 0) {
                avertex5[2] = avertex4[0];
                linkedlist.append(avertex5);
                break;
            }
        }
        return linkedlist;
    }
"
1962,937654,7,"    public void run() {
        VM_Controller.boot();
        VM_ApplicationClassLoader.setPathProperty();
        ClassLoader cl = new VM_ApplicationClassLoader(VM_SystemClassLoader.getVMClassLoader());
        String[] mainArgs = null;
        VM_Class cls = null;
        try {
            cls = (VM_Class) cl.loadClass(args[0], true).getVMType();
        } catch (ClassNotFoundException e) {
            VM.sysWrite(e + ""\n"");
            return;
        }
        mainMethod = cls.findMainMethod();
        if (mainMethod == null) {
            VM.sysWrite(cls.getName() + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
            return;
        }
        mainArgs = new String[args.length - 1];
        for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
        mainMethod.compile();
        VM_Callbacks.notifyStartup();
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainMethod.getCurrentCompiledMethod().getInstructions());
    }
"
1346,626857,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
7635,10484126,7,"    @Override
    public void run() {
        final int[] opponentCards = new int[MonteCarlo.NB_HOLECARDS];
        for (int i = 0; i < m_nbSimulations; ++i) {
            for (int j = 0; j < m_nbMissingTableCards; ++j) {
                m_dynamicTable[m_nbCardsShowedOnTable + j] = m_deck[j];
            }
            final long boardCode = (MonteCarlo.Encode(m_dynamicTable, 0));
            final long myResult = HandEvaluator.hand7Eval(MonteCarlo.Encode(m_playerCards, boardCode));
            boolean lost = false;
            for (int j = m_nbMissingTableCards; j < m_nbCardsToDraw; j += 2) {
                opponentCards[0] = m_deck[j];
                opponentCards[1] = m_deck[j + 1];
                final int opponentResult = HandEvaluator.hand7Eval(MonteCarlo.Encode(opponentCards, boardCode));
                if (opponentResult > myResult) {
                    lost = true;
                    break;
                }
            }
            if (!lost) {
                m_gamesWon++;
            }
            for (int k = 0; k != m_nbCardsToDraw; ++k) {
                final int l = m_myRandom.nextInt(m_deck.length - k) + k;
                final int tmp = m_deck[l];
                m_deck[l] = m_deck[k];
                m_deck[k] = tmp;
            }
        }
    }
"
10923,16693486,7,"    public void eval(double[] p) {
        double t = p[p.length - 1];
        int numPts = gi.getGroupSize();
        if (numPts > a.length) a = new double[2 * numPts];
        a[numPts - 1] = 1;
        double b = 1.0;
        double one_minus_t = 1.0 - t;
        for (int i = numPts - 2; i >= 0; i--) a[i] = a[i + 1] * one_minus_t;
        gi.set(0, 0);
        int i = 0;
        while (i < numPts) {
            double pt = PascalsTriangle.nCr(numPts - 1, i);
            if (Double.isInfinite(pt) || Double.isNaN(pt)) {
            } else {
                double gravity = a[i] * b * pt;
                double[] d = cp.getPoint(gi.next()).getLocation();
                for (int j = 0; j < p.length - 1; j++) p[j] = p[j] + d[j] * gravity;
            }
            b = b * t;
            i++;
        }
    }
"
9224,13952462,7,"    boolean remove(Process process) {
        readyList_.removeElement(process);
        boolean done = false;
        int i = 0;
        while (!done) if (process_[i].getProcessId() == process.getProcessId()) done = true; else i++;
        for (; i < process_.length - 1; i++) process_[i] = process_[i + 1];
        process_[i] = process;
        return readyList_.isEmpty();
    }
"
9469,14253968,7,"    public void dup2Bnth2() {
        assert mutable;
        sp += 2;
        Object tmp1 = stack[sp] = stack[sp + 2];
        Object tmp2 = stack[sp + 1] = stack[sp + 3];
        stack[sp + 2] = stack[sp + 4];
        stack[sp + 3] = stack[sp + 5];
        stack[sp + 4] = tmp1;
        stack[sp + 5] = tmp2;
    }
"
5736,6989890,7,"    protected void computeCoefficients() {
        final int n = degree() + 1;
        coefficients = new double[n];
        for (int i = 0; i < n; i++) {
            coefficients[i] = 0.0;
        }
        final double[] c = new double[n + 1];
        c[0] = 1.0;
        for (int i = 0; i < n; i++) {
            for (int j = i; j > 0; j--) {
                c[j] = c[j - 1] - c[j] * x[i];
            }
            c[0] *= -x[i];
            c[i + 1] = 1;
        }
        final double[] tc = new double[n];
        for (int i = 0; i < n; i++) {
            double d = 1;
            for (int j = 0; j < n; j++) {
                if (i != j) {
                    d *= x[i] - x[j];
                }
            }
            final double t = y[i] / d;
            tc[n - 1] = c[n];
            coefficients[n - 1] += t * tc[n - 1];
            for (int j = n - 2; j >= 0; j--) {
                tc[j] = c[j + 1] + tc[j + 1] * x[i];
                coefficients[j] += t * tc[j];
            }
        }
        coefficientsComputed = true;
    }
"
3589,3475386,7,"    public EventTool(String[] args) throws JiapiException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        String globalInclude = System.getProperty(""include"");
        String globalExclude = System.getProperty(""exclude"");
        String feInclude = System.getProperty(""field:include"");
        String feExclude = System.getProperty(""field:exclude"");
        String meInclude = System.getProperty(""method:include"");
        String meExclude = System.getProperty(""method:exclude"");
        InstrumentationContext ctx = new InstrumentationContext();
        InstrumentationDescriptor fid = new InstrumentationDescriptor();
        InstrumentationDescriptor mid = new InstrumentationDescriptor();
        if (globalInclude != null) {
            StringTokenizer st = new StringTokenizer(globalInclude, "","");
            while (st.hasMoreTokens()) {
                String rule = st.nextToken();
                fid.addInclusionRule(rule);
                mid.addInclusionRule(rule);
            }
        }
        if (globalExclude != null) {
            StringTokenizer st = new StringTokenizer(globalExclude, "","");
            while (st.hasMoreTokens()) {
                String rule = st.nextToken();
                fid.addExclusionRule(rule);
                mid.addExclusionRule(rule);
            }
        }
        if (feInclude != null) {
            StringTokenizer st = new StringTokenizer(feInclude, "","");
            while (st.hasMoreTokens()) {
                String rule = st.nextToken();
                fid.addInclusionRule(rule);
            }
        }
        if (feExclude != null) {
            StringTokenizer st = new StringTokenizer(feExclude, "","");
            while (st.hasMoreTokens()) {
                String rule = st.nextToken();
                fid.addExclusionRule(rule);
            }
        }
        if (meInclude != null) {
            StringTokenizer st = new StringTokenizer(meInclude, "","");
            while (st.hasMoreTokens()) {
                String rule = st.nextToken();
                mid.addInclusionRule(rule);
            }
        }
        if (meExclude != null) {
            StringTokenizer st = new StringTokenizer(meExclude, "","");
            while (st.hasMoreTokens()) {
                String rule = st.nextToken();
                mid.addExclusionRule(rule);
            }
        }
        FieldEventProducer fieldEventProducer = new FieldEventProducer(fid);
        fieldEventProducer.addFieldListener(this);
        MethodEventProducer methodEventProducer = new MethodEventProducer(mid);
        methodEventProducer.addMethodListener(this);
        ctx.addInstrumentationDescriptor(fid);
        ctx.addInstrumentationDescriptor(mid);
        Class<?> c = InstrumentingClassLoader.createClassLoader(ctx).loadClass(args[0]);
        Method method = c.getMethod(""main"", new Class[] { String[].class });
        String[] __args = new String[args.length - 1];
        for (int i = 0; i < __args.length; i++) {
            __args[i] = args[i + 1];
        }
        method.invoke(c, new Object[] { __args });
    }
"
13467,20601111,7,"    public IBond removeBond(int position) {
        IBond bond = bonds[position];
        bond.removeListener(this);
        for (int i = position; i < bondCount - 1; i++) {
            bonds[i] = bonds[i + 1];
        }
        bonds[bondCount - 1] = null;
        bondCount--;
        return bond;
    }
"
5790,7150666,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
"
8979,13562860,7,"    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {
        int index1 = rnd.nextInt(10);
        int index2 = rnd.nextInt(10) + 10;
        int temp = nums[index1];
        jTextArea1.append(""\nIndex1 = "" + index1 + ""("" + nums[index1] + ""), Index2 = "" + index2 + ""("" + nums[index2] + "")\n"");
        for (int i = index1; i < index2; i++) {
            nums[i] = nums[i + 1];
        }
        nums[index2] = temp;
        printNums();
    }
"
5719,6966588,7,"    private void computeCoefficients() {
        int n = data.length;
        if (n <= 2) {
            coeffC = new float[n];
            return;
        }
        int n3 = n - 3;
        float[] h = new float[n];
        for (int i = 0; i < n - 1; i++) {
            h[i] = data[i + 1].x - data[i].x;
        }
        float[] r = new float[n3];
        float[] d = new float[n3 + 1];
        float[] l = new float[n3];
        float[] x = new float[n3 + 1];
        for (int i = 0; i <= n3; i++) {
            d[i] = 2 * (h[i] + h[i + 1]) - ((i == 0) ? 0 : r[i - 1] * l[i - 1]);
            if (i < n3) {
                r[i] = h[i + 1];
                l[i] = h[i + 1] / d[i];
            }
            x[i] = 3 * ((data[i + 2].y - data[i + 1].y) / h[i + 1] - (data[i + 1].y - data[i].y) / h[i]);
        }
        for (int i = 1; i <= n3; i++) {
            x[i] -= x[i - 1] * l[i - 1];
        }
        float[] coeff = new float[n];
        x[n3] /= d[n3];
        coeff[n3 + 1] = x[n3];
        for (int i = n3 - 1; i >= 0; i--) {
            x[i] = (x[i] - r[i] * x[i + 1]) / d[i];
            coeff[i + 1] = x[i];
        }
        coeffC = coeff;
    }
"
5937,7455593,7,"    public IBond removeBond(int position) {
        IBond bond = bonds[position];
        bond.removeListener(this);
        for (int i = position; i < bondCount - 1; i++) {
            bonds[i] = bonds[i + 1];
        }
        bonds[bondCount - 1] = null;
        bondCount--;
        notifyChanged();
        return bond;
    }
"
2816,2168570,7,"    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException(""You can't remove an item until you've done at least one next()"");
        }
        if (list[position - 1] != null) {
            for (int i = position - 1; i < (list.length - 1); i++) {
                list[i] = list[i + 1];
            }
            list[list.length - 1] = null;
        }
    }
"
8128,12247511,7,"    private static String[] parsePattern(final String[] args, final String... commands) {
        final int ptnlen = commands.length;
        final String[] result = new String[ptnlen];
        int ri = 0;
        final int arglen = args.length;
        for (int i = COMMAND.length; i + 1 < arglen; i += 2) {
            final String s = args[i];
            final int pi = ArrayUtils.indexOf(commands, s, ri);
            if (pi == ArrayUtils.INDEX_NOT_FOUND) {
                continue;
            }
            result[pi] = args[i + 1];
            ri = pi + 1;
            if (ri >= ptnlen) {
                break;
            }
        }
        return result;
    }
"
6438,8119045,7,"    public void refresh() {
        if (pins[s] == -1 && pins[r] == -1) {
            pins[numInputs] = 0;
            pins[numInputs + 1] = 1;
            return;
        }
        if (pins[s] == 1 && pins[r] < 1) {
            nextStatePins[numInputs] = 1;
            nextStatePins[numInputs + 1] = 0;
            return;
        }
        if (pins[s] < 1 && pins[r] == 1) {
            nextStatePins[numInputs] = 0;
            nextStatePins[numInputs + 1] = 1;
            return;
        }
        if (pins[s] == 1 && pins[r] == 1 && timesRefreshed % 3 == 0) {
            nextStatePins[numInputs] = pins[numInputs + 1];
            nextStatePins[numInputs + 1] = pins[numInputs];
        }
        timesRefreshed++;
    }
"
3328,3123622,7,"        private void remove(int index) {
            Scan removed = scans[index];
            for (int i = index; i < length - 1; i++) {
                scans[i] = scans[i + 1];
            }
            scans[length - 1] = removed;
            length--;
        }
"
2069,1054727,7,"    private CommandLine parseCommandLine(TclObject argv[]) throws ParseException {
        String[] args = new String[argv.length - 1];
        for (int i = 0; i < argv.length - 1; i++) args[i] = argv[i + 1].toString();
        CommandLine cl = (new PosixParser()).parse(this.opts, args);
        return cl;
    }
"
2519,1807394,7,"        public void perform(Argument args[], Context context) throws ExtensionException, LogoException {
            try {
                String rname = args[0].getString();
                Object[] input = new Object[args.length - 1];
                LinkedHashMap<String, Object> hm = new LinkedHashMap<String, Object>();
                hm.put(rname, null);
                hm.put(""putnamedvector"", null);
                for (int i = 0; i < args.length - 1; i++) {
                    String varname = ((Integer) i).toString();
                    input[i] = args[i + 1].get();
                    hm.put(varname, input[i]);
                }
                rConn.storeObject(hm);
            } catch (Exception ex) {
                throw new ExtensionException(""Error in PutVector: \n"" + ex);
            }
        }
"
14282,21920836,7,"    protected short z_call() {
        int nlocals;
        int i;
        if (operands[0] == 0) {
            if (isstore()) zm.set_variable(storevar, ZFALSE);
        } else {
            zm.zstack.push(new ZFrameBound(isstore()));
            if (isstore()) zm.zstack.push(new Integer(storevar));
            zm.zstack.push(new Integer(opnum));
            zm.zstack.push(new Integer(zm.pc));
            zm.zstack.push(new Integer(((ZMachine5) zm).argcount));
            zm.zstack.push(zm.locals);
            zm.pc = zm.routine_address(operands[0]);
            nlocals = zm.get_code_byte();
            ((ZMachine5) zm).argcount = (short) (count - 1);
            zm.locals = new short[nlocals];
            for (i = 0; i < nlocals; i++) {
                if (i < (count - 1)) {
                    zm.locals[i] = operands[i + 1];
                } else {
                    zm.locals[i] = 0;
                }
            }
        }
        return ZFALSE;
    }
"
3909,4178103,7,"    public static void novo_dia(double p, double dias[]) {
        int tam = dias.length;
        for (int i = 0; i < tam - 1; i++) dias[i] = dias[i + 1];
        dias[tam - 1] = p;
    }
"
6839,8832284,7,"    public byte[] evaluateEvidence(byte[] peerEvidence) throws SaslException {
        byte[] key = K.getEncoded();
        int t = key[0];
        for (int i = 0; i < key.length - 1; i++) key[i] = key[i + 1];
        key[key.length - 1] = (byte) t;
        K = new SRPSecretKey(key);
        return ((SRPContext) getSaslSecurityContext()).getSignature();
    }
"
6173,7785429,7,"    void swapInt() {
        byte i = event[index];
        sevent[index] = event[index + 3];
        sevent[index + 3] = i;
        i = event[index + 1];
        sevent[index + 1] = event[index + 2];
        sevent[index + 2] = i;
        index += 4;
    }
"
14859,23114872,7,"    private static <E> void movesort(final E[] values, final E[] buffer, final int start, final int bound, final Comparator<? super E> comparator) {
        int t = start;
        E v1, v2;
        for (; t < bound; t++) {
            if (comparator.compare(v1 = values[t], v2 = values[t + 1]) <= 0) {
                buffer[t] = values[t];
            } else {
                buffer[t] = values[t + 1];
                values[t + 1] = values[t];
            }
        }
        buffer[t] = values[t];
    }
"
5996,7561967,7,"    public static String upperEnglish(String source) {
        if (source == null) return """";
        source = source.trim();
        byte[] chars = source.getBytes();
        StringBuffer sb = new StringBuffer(chars.length);
        byte[] chinese = new byte[2];
        int count = 0;
        int line = 0;
        int i = 0;
        for (; i < chars.length; i++) {
            if (chars[i] < 0) {
                chinese[0] = chars[i];
                chinese[1] = chars[i + 1];
                sb.append(new String(chinese));
                i++;
            } else {
                String tmpstr = (char) chars[i] + """";
                tmpstr = tmpstr.toUpperCase();
                sb.append(tmpstr);
            }
        }
        return sb.toString();
    }
"
12147,18685528,7,"    public int moveTimepoint(int which, double t) {
        Keyframe tempv;
        Smoothness temps;
        int newpos;
        for (newpos = 0; newpos < time.length && time[newpos] < t; newpos++) ;
        tempv = value[which];
        temps = smoothness[which];
        if (newpos > which) {
            newpos--;
            for (int i = which; i < newpos; i++) {
                value[i] = value[i + 1];
                time[i] = time[i + 1];
                smoothness[i] = smoothness[i + 1];
            }
        } else for (int i = which; i > newpos; i--) {
            value[i] = value[i - 1];
            time[i] = time[i - 1];
            smoothness[i] = smoothness[i - 1];
        }
        value[newpos] = tempv;
        time[newpos] = t;
        smoothness[newpos] = temps;
        return newpos;
    }
"
12551,19539601,7,"    public static int[] rotar(int[] numeros) {
        int primero = numeros[0];
        int x;
        for (x = 0; x < numeros.length - 1; x++) numeros[x] = numeros[x + 1];
        numeros[x] = primero;
        return numeros;
    }
"
9118,13731773,7,"    private void sort(int jc) {
        TaskResult taux;
        int length = taur.length;
        for (int i = jc; i < length; i++) {
            if (taur[i] == null) {
                int i2;
                for (i2 = i; i2 < length - 1; i2++) {
                    taur[i2] = taur[i2 + 1];
                    taur[i2 + 1] = null;
                }
                length--;
            } else {
                for (int j = i + 1; j < length; j++) {
                    if (taur[j] != null) {
                        if (taur[i].getT1() > taur[j].getT1()) {
                            taux = taur[i];
                            taur[i] = taur[j];
                            taur[j] = taux;
                        } else {
                            if (taur[i].getT1() == taur[j].getT1()) {
                                if (taur[i].p < taur[j].p) {
                                    taux = taur[i];
                                    taur[i] = taur[j];
                                    taur[j] = taux;
                                } else {
                                    if (taur[i].p == taur[j].p) {
                                        if (taur[i].getInst() > taur[j].getInst()) {
                                            taux = taur[i];
                                            taur[i] = taur[j];
                                            taur[j] = taux;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
"
5453,6230158,7,"    boolean toggleSelection(TreeItem item, boolean isCtrlKeyHold, boolean isShiftKeyHold) {
        if (item == null) {
            return false;
        }
        if ((style & SWT.MULTI) != 0 && (isCtrlKeyHold || isShiftKeyHold)) {
            if (isCtrlKeyHold) {
                for (int i = 0; i < selections.length; i++) {
                    if (item == selections[i]) {
                        TreeItem[] newSelections = new TreeItem[selections.length];
                        for (int j = 0; j < i; j++) {
                            newSelections[j] = selections[j];
                        }
                        for (int j = i; j < selections.length - 1; j++) {
                            newSelections[j] = selections[j + 1];
                        }
                        selections = newSelections;
                        item.showSelection(false);
                        lastSelection = item;
                        return false;
                    }
                }
                selections[selections.length] = item;
                lastSelection = item;
                item.showSelection(true);
            } else {
                for (int i = 0; i < selections.length; i++) {
                    if (selections[i] != null) {
                        selections[i].showSelection(false);
                    }
                }
                if (lastSelection != null) {
                    int idx1 = Math.min(lastSelection.index, item.index);
                    int idx2 = Math.max(lastSelection.index, item.index);
                    selections = new TreeItem[0];
                    for (int i = idx1; i <= idx2; i++) {
                        TreeItem ti = items[i];
                        if (ti.handle.style.display != ""none"") {
                            selections[selections.length] = ti;
                            ti.showSelection(true);
                        }
                    }
                    return true;
                } else {
                    if (selections.length != 1) {
                        selections = new TreeItem[1];
                    }
                    selections[0] = item;
                }
            }
        } else {
            item.showSelection(true);
            for (int i = 0; i < selections.length; i++) {
                if (selections[i] != null && selections[i] != item) {
                    selections[i].showSelection(false);
                }
            }
            if (selections.length != 1) {
                selections = new TreeItem[1];
            }
            selections[0] = item;
        }
        lastSelection = item;
        return true;
    }
"
149,45973,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
1022,468621,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
12294,19095601,7,"    public static void novo_dia(double p, double dias[]) {
        for (int i = 0; i < LONG_PERIOD - 1; i++) dias[i] = dias[i + 1];
        dias[LONG_PERIOD - 1] = p;
    }
"
6377,8040799,7,"    public boolean remove(int index) {
        if (index >= 0 && index < anzahl) {
            for (int i = index; i < anzahl - 1; i++) {
                speicher[i] = speicher[i + 1];
            }
            anzahl--;
            return true;
        } else return false;
    }
"
15115,23596004,7,"    public static float[] vertFlipQuadTexCoords(float[] tc) {
        float swap = 0;
        for (int i = 1; i < tc.length - 2; i += 4) {
            swap = tc[i];
            tc[i] = tc[i + 2];
            tc[i + 2] = swap;
        }
        return tc;
    }
"
9617,14371287,7,"    void deleteBond(int i) {
        int newLength = bonds.length - 1;
        if (newLength == 0) {
            bonds = null;
            return;
        }
        Bond[] bondsNew = new Bond[newLength];
        int j = 0;
        for (; j < i; ++j) bondsNew[j] = bonds[j];
        for (; j < newLength; ++j) bondsNew[j] = bonds[j + 1];
        bonds = bondsNew;
    }
"
11226,17210037,7,"    public void drawFPS(Graphics2D g2) {
        for (int i = 0; i < fpsAverageCount - 1; ++i) {
            nanos[i] = nanos[i + 1];
        }
        nanos[fpsAverageCount - 1] = System.nanoTime();
        float averagedFPS = (float) ((fpsAverageCount - 1) * 1000000000.0 / (nanos[fpsAverageCount - 1] - nanos[0]));
        ++frameCount;
        float totalFPS = (float) (frameCount * 1000000000 / (1.0 * (System.nanoTime() - nanoStart)));
        g2.drawString(""100 Average FPS is "" + averagedFPS, 15, 15);
        g2.drawString(""Entire FPS is "" + totalFPS, 15, 25);
    }
"
5883,7388462,7,"    void updateHashtable(int to, int from) {
        byte[] data = new byte[3];
        int hash;
        Link temp;
        for (int i = to; i < from; i++) {
            if (i + MIN_LENGTH > inLength) {
                break;
            }
            data[0] = in[i];
            data[1] = in[i + 1];
            data[2] = in[i + 2];
            hash = hash(data);
            if (window[nextWindow].previous != null) {
                window[nextWindow].previous.next = null;
            } else if (window[nextWindow].hash != 0) {
                hashtable[window[nextWindow].hash].next = null;
            }
            window[nextWindow].hash = hash;
            window[nextWindow].value = i;
            window[nextWindow].previous = null;
            temp = window[nextWindow].next = hashtable[hash].next;
            hashtable[hash].next = window[nextWindow];
            if (temp != null) {
                temp.previous = window[nextWindow];
            }
            nextWindow = nextWindow + 1;
            if (nextWindow == WINDOW) {
                nextWindow = 0;
            }
        }
    }
"
6826,8829372,7,"    public void removeContact(Contact kontakt) {
        int i = getRecordNr(kontakt.getBuddyMail());
        for (int g = i; g < (list.length - 1); g++) {
            list[g] = list[g + 1];
        }
    }
"
476,209396,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
884,412881,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
169,52273,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
14482,22310637,7,"    public static Area getAreaForThreshold(double[][] data, double threshold) {
        Vector vec = new Vector(500000);
        System.out.println(""getAreaForThreshold("" + threshold + "")"");
        Area retarea = null;
        Area tmparea = null;
        Triangle[] triangles = null;
        Point2D.Float[] vert_xys = new Point2D.Float[4];
        double[] vert_values = new double[4];
        for (int a = 0; a < 4; a++) {
            vert_xys[a] = new Point2D.Float();
        }
        GeneralPath tmppath = new GeneralPath();
        for (int y = 0; y < data[0].length - 1; y++) {
            for (int x = 0; x < data.length - 1; x++) {
                vert_values[0] = data[x][y];
                vert_values[0] = data[x + 1][y];
                vert_values[0] = data[x + 1][y + 1];
                vert_values[0] = data[x][y + 1];
                vert_xys[0].x = (float) x;
                vert_xys[0].y = (float) y;
                vert_xys[1].x = (float) (x + 1);
                vert_xys[1].y = (float) y;
                vert_xys[2].x = (float) (x + 1);
                vert_xys[2].y = (float) (y + 1);
                vert_xys[3].x = (float) x;
                vert_xys[3].y = (float) (y + 1);
                triangles = SquareMarcher.marchSquare(vert_xys, vert_values, threshold);
                if (triangles != null) {
                    for (int a = 0; a < triangles.length; a++) vec.add(triangles[a]);
                }
            }
        }
        Triangle[] tris = new Triangle[vec.size()];
        vec.copyInto(tris);
        return getAreaForTriangles(tris);
    }
"
1261,593253,7,"    public static void main(String args[]) {
        int numberCommandStrings = 10000;
        GnubertProperties propertyList = new GnubertProperties();
        GnubertStatus currentStatus = new GnubertStatus();
        String commandStrings[] = new String[numberCommandStrings];
        double fitnessArray[] = new double[numberCommandStrings];
        int counter, index, bucket, tournamentSize, chance;
        int tournamentIndexes[] = null;
        boolean accepted = false;
        Random rand = new Random();
        double temp;
        int sizeImmigrantQueue = 10;
        LinkedList immigrantQueue = new LinkedList();
        initializeStrings(commandStrings, numberCommandStrings);
        int countX, countY;
        FileInputStream filein = null;
        BufferedReader reader = null;
        try {
            filein = new FileInputStream(""maze"");
        } catch (Exception e) {
            System.out.println(""Something is wrong with your maze file!!!"");
            System.out.println(e);
            System.exit(1);
        }
        reader = new BufferedReader(new InputStreamReader(filein));
        try {
            try {
                xSize = Integer.valueOf(reader.readLine()).intValue();
                ySize = Integer.valueOf(reader.readLine()).intValue();
                maze = new int[xSize][ySize];
                for (countY = 0; countY < ySize; countY++) for (countX = 0; countX < xSize; countX++) maze[countX][countY] = Integer.valueOf(reader.readLine()).intValue();
            } catch (NumberFormatException e) {
                System.out.println(""Something is wrong with your maze file!!!"");
                System.out.println(e);
                System.exit(1);
            }
        } catch (IOException e) {
            System.out.println(""Your maze file is too short or the dimensions are wrong!"");
            System.out.println(e);
            System.exit(1);
        }
        worstCase = Math.sqrt(Math.pow(xSize - 1, 2) + Math.pow(ySize - 1, 2));
        for (countX = 0; countX < xSize + 2; countX++) System.out.print(""#"");
        System.out.println();
        for (countY = 0; countY < ySize; countY++) {
            System.out.print(""|"");
            for (countX = 0; countX < xSize; countX++) if (maze[countX][countY] == 1) {
                System.out.print(""#"");
            } else System.out.print("" "");
            System.out.println(""|"");
        }
        for (countX = 0; countX < xSize + 2; countX++) System.out.print(""#"");
        System.out.println();
        HostCatcher hostCatcher = new HostCatcher(propertyList, currentStatus);
        hostCatcher.start();
        System.out.println(""HostCatcher started!"");
        clientThread = new GnubertClient(hostCatcher, propertyList, currentStatus);
        clientThread.start();
        System.out.println(""Client Started!"");
        GnubertServer serverThread = new GnubertServer(commandStrings, numberCommandStrings, propertyList, hostCatcher, currentStatus);
        serverThread.start();
        System.out.println(""Server Started!"");
        for (counter = 0; counter < numberCommandStrings; counter++) {
            fitnessArray[counter] = fitness(commandStrings[counter]);
            if (fitnessArray[counter] == 0) isSolutionInside = true;
        }
        if (isSolutionInside) {
            System.out.println(""Solution Inside"");
            for (counter = 0; counter < numberCommandStrings; counter++) System.out.println(fitnessArray[counter]);
        } else System.out.println(""Fitness level is equal to the percentage of the distance from the starting point (upper Left) to the ending point (Lower Right) that the string reaches."");
        int generationCounter = 0;
        while (!isSolutionInside) {
            tournamentSize = (int) (rand.nextDouble() * (numberCommandStrings - 2)) + 2;
            tournamentIndexes = new int[tournamentSize];
            for (counter = 0; counter < tournamentSize; counter++) {
                while (!accepted) {
                    accepted = true;
                    tournamentIndexes[counter] = (int) (rand.nextDouble() * numberCommandStrings);
                    for (index = 0; index < counter; index++) {
                        if (tournamentIndexes[counter] == tournamentIndexes[index]) accepted = false;
                        break;
                    }
                }
                accepted = false;
            }
            accepted = false;
            index = tournamentSize;
            while (!accepted) {
                accepted = true;
                index--;
                for (counter = 0; counter < index; counter++) {
                    if (fitnessArray[tournamentIndexes[counter]] > fitnessArray[tournamentIndexes[counter + 1]]) {
                        bucket = tournamentIndexes[counter];
                        tournamentIndexes[counter] = tournamentIndexes[counter + 1];
                        tournamentIndexes[counter + 1] = bucket;
                        accepted = false;
                    }
                }
            }
            for (counter = tournamentSize / 2; counter < tournamentSize; counter++) {
                chance = (int) (rand.nextDouble() * 100);
                if (chance < 10) {
                    index = (int) (rand.nextDouble() * tournamentSize / 2);
                    commandStrings[tournamentIndexes[counter]] = duplicateSubstring(commandStrings[tournamentIndexes[index]]);
                    fitnessArray[tournamentIndexes[counter]] = fitness(commandStrings[tournamentIndexes[counter]]);
                    if (fitnessArray[tournamentIndexes[counter]] == 0) isSolutionInside = true;
                } else if (chance < 20) {
                    index = (int) (rand.nextDouble() * tournamentSize / 2);
                    commandStrings[tournamentIndexes[counter]] = deleteSubstring(commandStrings[tournamentIndexes[index]]);
                    fitnessArray[tournamentIndexes[counter]] = fitness(commandStrings[tournamentIndexes[counter]]);
                    if (fitnessArray[tournamentIndexes[counter]] == 0) isSolutionInside = true;
                } else if (chance < 70) {
                    index = (int) (rand.nextDouble() * tournamentSize / 2);
                    commandStrings[tournamentIndexes[counter]] = mutate(commandStrings[tournamentIndexes[index]]);
                    fitnessArray[tournamentIndexes[counter]] = fitness(commandStrings[tournamentIndexes[counter]]);
                    if (fitnessArray[tournamentIndexes[counter]] == 0) isSolutionInside = true;
                } else if (chance < 90) {
                    index = (int) (rand.nextDouble() * tournamentSize / 2);
                    commandStrings[tournamentIndexes[counter]] = recombination(commandStrings[tournamentIndexes[counter]], commandStrings[tournamentIndexes[index]]);
                    fitnessArray[tournamentIndexes[counter]] = fitness(commandStrings[tournamentIndexes[counter]]);
                    if (fitnessArray[tournamentIndexes[counter]] == 0) isSolutionInside = true;
                } else if (chance < 95) {
                    String immigrant = null;
                    immigrant = clientThread.getImmigrant();
                    if (immigrant != null) {
                        commandStrings[tournamentIndexes[counter]] = immigrant;
                        fitnessArray[tournamentIndexes[counter]] = fitness(commandStrings[tournamentIndexes[counter]]);
                        if (fitnessArray[tournamentIndexes[counter]] == 0) isSolutionInside = true;
                    }
                } else if (chance < 100) {
                    index = (int) (rand.nextDouble() * tournamentSize / 2);
                    commandStrings[tournamentIndexes[counter]] = commandStrings[tournamentIndexes[index]];
                    fitnessArray[tournamentIndexes[counter]] = fitness(commandStrings[tournamentIndexes[counter]]);
                }
            }
            if (isSolutionInside) {
                System.out.println(""\nOne or more solutions found in generation number "" + generationCounter + ""!"");
                for (counter = 0; counter < numberCommandStrings; counter++) {
                    if (fitnessArray[counter] == 0) {
                        System.out.println(""Solution:"");
                        System.out.println(commandStrings[counter]);
                    }
                }
            } else {
                temp = 0;
                for (counter = 0; counter < numberCommandStrings; counter++) temp += fitnessArray[counter];
                System.out.print(""\rAverage fitness level from generation "" + generationCounter + "" was "" + (1 - temp / numberCommandStrings) * 100 + ""% "");
                generationCounter++;
            }
        }
    }
"
8119,12121968,7,"    public void setrideniPolozek(String[] pol) {
        int i[] = new int[11];
        int j[] = new int[3];
        int n;
        for (n = 0; n <= 2; n++) {
            if (pol[n].equals(""a"")) {
                i[n] = 1;
                j[n] = 1;
            } else if (pol[n].equals(""b"")) {
                i[n] = 1;
                j[n] = 2;
            } else if (pol[n].equals(""c"")) {
                i[n] = 1;
                j[n] = 3;
            } else if (pol[n].equals(""alfa"")) {
                i[n] = 2;
                j[n] = 1;
            } else if (pol[n].equals(""beta"")) {
                i[n] = 2;
                j[n] = 2;
            } else if (pol[n].equals(""gama"")) {
                i[n] = 2;
                j[n] = 3;
            } else if (pol[n].equals(""va"")) {
                i[n] = 3;
                j[n] = 1;
            } else if (pol[n].equals(""vb"")) {
                i[n] = 3;
                j[n] = 2;
            } else if (pol[n].equals(""vc"")) {
                i[n] = 3;
                j[n] = 3;
            } else if (pol[n].equals(""ta"")) {
                i[n] = 4;
                j[n] = 1;
            } else if (pol[n].equals(""tb"")) {
                i[n] = 4;
                j[n] = 2;
            } else if (pol[n].equals(""tc"")) {
                i[n] = 4;
                j[n] = 3;
            } else if (pol[n].equals(""ua"")) {
                i[n] = 5;
                j[n] = 1;
            } else if (pol[n].equals(""ub"")) {
                i[n] = 5;
                j[n] = 2;
            } else if (pol[n].equals(""uc"")) {
                i[n] = 5;
                j[n] = 3;
            } else if (pol[n].equals(""p"")) i[n] = 6; else if (pol[n].equals(""r"")) i[n] = 7; else if (pol[n].equals(""ro"")) i[n] = 8; else if (pol[n].equals(""ab"")) i[n] = 9; else if (pol[n].equals(""ob"")) i[n] = 10; else if (pol[n].equals(""z"")) i[n] = 11;
        }
        int d = 0;
        if (i[2] == 9 || i[1] == 9 || i[0] > 5 || i[2] == 11) d = 0; else {
            if (i[0] == i[1]) {
                if (j[0] == 1) {
                    if (j[1] == 2) d = 0; else if (j[1] == 3) d = 2;
                } else d = 1;
            } else d = j[0] - 1;
        }
        if (i[0] < 6 && d > 0) {
            zadaniHlaseni(""CHANGE"");
        }
        for (n = 0; n <= 2; n++) {
            if (i[n] > 5) continue;
            j[n] = j[n] - d;
            if (j[n] < 1) j[n] = j[n] + 3;
        }
        for (n = 0; n <= 1; n++) {
            if (i[n] == i[n + 1]) {
                if (j[n] > j[n + 1]) {
                    int m = j[n];
                    j[n] = j[n + 1];
                    j[n + 1] = m;
                }
            }
        }
        for (n = 0; n <= 2; n++) {
            if (i[n] == 1 && j[n] == 1) pol[n] = ""a""; else if (i[n] == 1 && j[n] == 2) pol[n] = ""b""; else if (i[n] == 1 && j[n] == 3) pol[n] = ""c""; else if (i[n] == 2 && j[n] == 1) pol[n] = ""alfa""; else if (i[n] == 2 && j[n] == 2) pol[n] = ""beta""; else if (i[n] == 2 && j[n] == 3) pol[n] = ""gama""; else if (i[n] == 3 && j[n] == 1) pol[n] = ""va""; else if (i[n] == 3 && j[n] == 2) pol[n] = ""vb""; else if (i[n] == 3 && j[n] == 3) pol[n] = ""vc""; else if (i[n] == 4 && j[n] == 1) pol[n] = ""ta""; else if (i[n] == 4 && j[n] == 2) pol[n] = ""tb""; else if (i[n] == 4 && j[n] == 3) pol[n] = ""tc""; else if (i[n] == 5 && j[n] == 1) pol[n] = ""ua""; else if (i[n] == 5 && j[n] == 2) pol[n] = ""ub""; else if (i[n] == 5 && j[n] == 3) pol[n] = ""uc""; else if (i[n] == 6) pol[n] = ""p""; else if (i[n] == 7) pol[n] = ""r""; else if (i[n] == 8) pol[n] = ""ro""; else if (i[n] == 9) pol[n] = ""ab""; else if (i[n] == 10) pol[n] = ""ob""; else if (i[n] == 11) pol[n] = ""z"";
        }
    }
"
1411,661927,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
9264,13986721,7,"    private void calculateCoefficients() {
        int N = pos1D.length;
        a = new double[N];
        b = new double[N];
        c = new double[N];
        d = new double[N];
        if (N == 2) {
            a[0] = pos1D[0];
            b[0] = pos1D[1] - pos1D[0];
            return;
        }
        double[] h = new double[N - 1];
        for (int i = 0; i < N - 1; i++) {
            a[i] = pos1D[i];
            h[i] = len[i + 1] - len[i];
            if (h[i] == 0.0) {
                h[i] = 0.01;
            }
        }
        a[N - 1] = pos1D[N - 1];
        double[][] A = new double[N - 2][N - 2];
        double[] y = new double[N - 2];
        for (int i = 0; i < N - 2; i++) {
            y[i] = 3 * ((pos1D[i + 2] - pos1D[i + 1]) / h[i + 1] - (pos1D[i + 1] - pos1D[i]) / h[i]);
            A[i][i] = 2 * (h[i] + h[i + 1]);
            if (i > 0) {
                A[i][i - 1] = h[i];
            }
            if (i < N - 3) {
                A[i][i + 1] = h[i + 1];
            }
        }
        solve(A, y);
        for (int i = 0; i < N - 2; i++) {
            c[i + 1] = y[i];
            b[i] = (a[i + 1] - a[i]) / h[i] - (2 * c[i] + c[i + 1]) / 3 * h[i];
            d[i] = (c[i + 1] - c[i]) / (3 * h[i]);
        }
        b[N - 2] = (a[N - 1] - a[N - 2]) / h[N - 2] - (2 * c[N - 2] + c[N - 1]) / 3 * h[N - 2];
        d[N - 2] = (c[N - 1] - c[N - 2]) / (3 * h[N - 2]);
    }
"
1805,862981,7,"    public void usunElement(int nr) {
        boolean zmien = false;
        for (int i = 0; i < inArt; i++) {
            if (i == nr) {
                zmien = true;
            }
            if (zmien) {
                art[i] = art[i + 1];
            }
        }
        if (zmien) {
            inArt--;
        }
    }
"
6348,8006704,7,"    protected void build() {
        if (isPopupMenuVisible() || valid_) return;
        FuLog.debug(""BMT: build menu internal frames"");
        valid_ = true;
        removeAll();
        if (desktop_ == null) {
            number_ = 0;
            return;
        }
        JInternalFrame[] frames = desktop_.getAllFrames();
        number_ = frames.length;
        for (int i = 0; i < frames.length - 1; i++) {
            String t0 = frames[i].getTitle();
            String t1 = frames[i + 1].getTitle();
            if (t0 == null) System.err.println(""No title for "" + frames[i].getName());
            if ((t0 != null) && (t1 != null) && (t1.compareTo(t0) < 0)) {
                JInternalFrame tmp = frames[i];
                frames[i] = frames[i + 1];
                frames[i + 1] = tmp;
                i -= 2;
                if (i < 0) i = -1;
            }
        }
        for (int i = 0; i < frames.length; i++) {
            JInternalFrame f = frames[i];
            String n = f.getName();
            if ((n != null) && (f.getClientProperty(""JInternalFrame.isPalette"") != Boolean.TRUE)) {
                if (n.startsWith(""if"")) n = n.substring(2);
                BuMenuItem mi = addMenuItem(f.getTitle(), ""FILLE_ACTIVER("" + n + "")"", true, BuInternalFrame.getShortcut(f));
                Icon icon = f.getFrameIcon();
                if (icon instanceof BuIcon) mi.setIcon(BuResource.BU.reduceMenuIcon((BuIcon) icon)); else mi.setIcon(icon);
            }
        }
        computeMnemonics();
    }
"
14512,22389985,7,"    private void popCommand() {
        numberCommands--;
        int i = 0;
        for (i = 0; i < numberCommands; i++) {
            commands[i] = commands[i + 1];
        }
        commands[++i] = null;
    }
"
9418,14136877,7,"    private void getNextChangingElement(int a0, boolean isWhite, int[] ret) throws IIOException {
        int[] pce = this.prevChangingElems;
        int ces = this.changingElemSize;
        int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
        if (isWhite) {
            start &= ~0x1;
        } else {
            start |= 0x1;
        }
        int i = start;
        for (; i < ces; i += 2) {
            int temp = pce[i];
            if (temp > a0) {
                lastChangingElement = i;
                ret[0] = temp;
                break;
            }
        }
        if (i + 1 < ces) {
            ret[1] = pce[i + 1];
        }
    }
"
4903,5626270,7,"    private int getPhrases(HashMap hash, String str) {
        String[] buffer = new String[m_MaxPhraseLength];
        StringTokenizer tok = new StringTokenizer(str, ""\n"");
        int pos = 1;
        while (tok.hasMoreTokens()) {
            String phrase = tok.nextToken();
            int numSeen = 0;
            StringTokenizer wordTok = new StringTokenizer(phrase, "" "");
            while (wordTok.hasMoreTokens()) {
                String word = wordTok.nextToken();
                for (int i = 0; i < m_MaxPhraseLength - 1; i++) {
                    buffer[i] = buffer[i + 1];
                }
                buffer[m_MaxPhraseLength - 1] = word;
                numSeen++;
                if (numSeen > m_MaxPhraseLength) {
                    numSeen = m_MaxPhraseLength;
                }
                if (m_Stopwords.isStopword(buffer[m_MaxPhraseLength - 1])) {
                    pos++;
                    continue;
                }
                StringBuffer phraseBuffer = new StringBuffer();
                for (int i = 1; i <= numSeen; i++) {
                    if (i > 1) {
                        phraseBuffer.insert(0, ' ');
                    }
                    phraseBuffer.insert(0, buffer[m_MaxPhraseLength - i]);
                    if ((i > 1) && (m_Stopwords.isStopword(buffer[m_MaxPhraseLength - i]))) {
                        continue;
                    }
                    if (i >= m_MinPhraseLength) {
                        String phrStr = phraseBuffer.toString();
                        String internal = internalFormat(phrStr);
                        FastVector vec = (FastVector) hash.get(internal);
                        if (vec == null) {
                            vec = new FastVector(3);
                            HashMap secHash = new HashMap();
                            secHash.put(phrStr, new Counter());
                            vec.addElement(new Counter(pos + 1 - i));
                            vec.addElement(new Counter());
                            vec.addElement(secHash);
                            hash.put(internal, vec);
                        } else {
                            ((Counter) ((FastVector) vec).elementAt(1)).increment();
                            HashMap secHash = (HashMap) vec.elementAt(2);
                            Counter count = (Counter) secHash.get(phrStr);
                            if (count == null) {
                                secHash.put(phrStr, new Counter());
                            } else {
                                count.increment();
                            }
                        }
                    }
                }
                pos++;
            }
        }
        Iterator phrases = hash.keySet().iterator();
        while (phrases.hasNext()) {
            String phrase = (String) phrases.next();
            FastVector info = (FastVector) hash.get(phrase);
            if (((Counter) ((FastVector) info).elementAt(1)).value() < m_MinNumOccur) {
                phrases.remove();
                continue;
            }
            String canForm = canonicalForm((HashMap) info.elementAt(2));
            if (canForm == null) {
                phrases.remove();
            } else {
                info.setElementAt(canForm, 2);
            }
        }
        return pos;
    }
"
5914,7435662,7,"        public void removeNode(Node oldNode, double[] oldPos, int depth) {
            if (oldNode.weight == 0.0) return;
            if (weight <= oldNode.weight) {
                weight = 0.0;
                node = null;
                for (int i = 0; i < children.length; i++) children[i] = null;
                childCount = 0;
                return;
            }
            for (int d = 0; d < 3; d++) {
                position[d] = (weight * position[d] - oldNode.weight * oldPos[d]) / (weight - oldNode.weight);
            }
            weight -= oldNode.weight;
            if (depth == MAX_DEPTH) {
                int childIndex = 0;
                while (children[childIndex].node != oldNode) childIndex++;
                childCount--;
                for (int i = childIndex; i < childCount; i++) {
                    children[i] = children[i + 1];
                }
                children[childCount] = null;
            } else {
                int childIndex = 0;
                for (int d = 0; d < 3; d++) {
                    if (oldPos[d] > (minPos[d] + maxPos[d]) / 2) {
                        childIndex += 1 << d;
                    }
                }
                children[childIndex].removeNode(oldNode, oldPos, depth + 1);
                if (children[childIndex].weight == 0.0) {
                    children[childIndex] = null;
                    childCount--;
                }
            }
        }
"
14001,21285350,7,"        public void relocate(int oldIndex, int newIndex) {
            if (oldIndex < 0 || oldIndex > tests.length - 1) {
                throw new java.lang.IllegalArgumentException();
            }
            if (newIndex < 0 || newIndex > tests.length - 1) {
                throw new java.lang.IllegalArgumentException();
            } else {
                if (newIndex > oldIndex) {
                    Test temp = tests[oldIndex];
                    for (int i = oldIndex; i < newIndex; i++) tests[i] = tests[i + 1];
                    tests[newIndex] = temp;
                } else if (oldIndex > newIndex) {
                    Test temp = tests[oldIndex];
                    for (int j = oldIndex; j > newIndex; j--) tests[j] = tests[j - 1];
                    tests[newIndex] = temp;
                }
            }
        }
"
7784,10621645,7,"    public static void bsw32(byte[] ary, int offset) {
        byte t = ary[offset];
        ary[offset] = ary[offset + 3];
        ary[offset + 3] = t;
        t = ary[offset + 1];
        ary[offset + 1] = ary[offset + 2];
        ary[offset + 2] = t;
    }
"
5549,6352528,7,"    private String[] xLiner(int number) {
        if (number <= 2) {
            number = 2;
        } else {
            number = 3;
        }
        String[] result = new String[number];
        String[] lastSegs = new String[number - 1];
        String lastWord = """";
        String tempWord = """";
        int[] tempSyls = new int[number];
        int tempSyl = 0;
        boolean match;
        bcWordList lst = null;
        bcWord current = null;
        for (int l = 0; l <= number - 2; l++) {
            do {
                match = true;
                if (l == 0) {
                    currentSyllables = 0;
                    result[0] = fill(parseGrammar(GRAMMAR_START));
                    lastWord = getLastWord(result[0]);
                    tempSyls[0] = currentSyllables;
                    currentSyllables = 0;
                } else {
                    lastWord = getLastWord(result[1]);
                }
                result[l + 1] = parseGrammar(GRAMMAR_START);
                if (result[l + 1].indexOf(""@"") == -1) {
                    lastSegs[l] = result[l + 1];
                    result[l + 1] = """";
                    tempSyls[l + 1] = currentSyllables = 0;
                } else {
                    for (int j = result[l + 1].length() - 1; j >= 0; j--) {
                        if (result[l + 1].charAt(j) == '@') {
                            lastSegs[l] = result[l + 1].substring(j + 1);
                            result[l + 1] = fill(result[l + 1].substring(0, j));
                            tempSyls[l + 1] = currentSyllables;
                            currentSyllables = 0;
                            break;
                        }
                    }
                }
                if (lastSegs[l].startsWith(""'"") && lastSegs[l].endsWith(""'"")) {
                    tempWord = lastSegs[l].substring(1, lastSegs[l].length() - 1);
                    tempSyl = getWordFromLists(tempWord).getSyllables();
                    if ((rhyming(tempWord, lastWord) < 1) || !(tempSyl + tempSyls[l + 1] <= tempSyls[0] + module.getSyllableTolerance()) || !(tempSyl + tempSyls[l + 1] >= tempSyls[0] - module.getSyllableTolerance())) {
                        match = false;
                    } else {
                        result[l + 1] += "" "" + tempWord;
                        tempSyls[l + 1] += tempSyl;
                    }
                } else {
                    lst = module.getWordList(lastSegs[l]);
                    List possibleMatches = new LinkedList();
                    for (int j = 0; j < lst.getNumberOfWords(); j++) {
                        current = lst.getItem(j);
                        tempWord = current.getWord();
                        if ((rhyming(tempWord, lastWord) == 1) && (current.getSyllables() + tempSyls[l + 1] <= tempSyls[0] + module.getSyllableTolerance()) && (current.getSyllables() + tempSyls[l + 1] >= tempSyls[0] - module.getSyllableTolerance())) {
                            possibleMatches.add(current);
                        }
                    }
                    if (possibleMatches.size() == 0) {
                        match = false;
                    } else {
                        current = (bcWord) possibleMatches.get(r.nextInt(possibleMatches.size()));
                        tempWord = current.getWord();
                        result[l + 1] += "" "" + tempWord;
                        tempSyls[l + 1] += current.getSyllables();
                    }
                }
                if ((module.getSyllableTolerance() == 0) && (!result[l + 1].equals("""")) && (!metricMatch(result[0], result[l + 1]))) {
                    match = false;
                }
            } while (!match);
        }
        return result;
    }
"
14943,23357894,7,"    private CommandLine parseCommandLine(TclObject argv[]) throws ParseException {
        String[] args = new String[argv.length - 1];
        for (int i = 0; i < argv.length - 1; i++) args[i] = argv[i + 1].toString();
        CommandLine cl = (new PosixParser()).parse(this.opts, args);
        return cl;
    }
"
3948,4254073,7,"    public static void toggleIntEndian(byte[] b, int off, int len) {
        if (b == null || len == 0) return;
        int end = off + len;
        if (off < 0 || len < 0 || end > b.length) throw new IndexOutOfBoundsException(""b.length = "" + b.length + "", off = "" + off + "", len = "" + len);
        if ((len & 3) != 0) throw new IllegalArgumentException(""len = "" + len);
        byte tmp;
        for (int i = off; i < end; i++, i++, i++, i++) {
            tmp = b[i];
            b[i] = b[i + 3];
            b[i + 3] = tmp;
            tmp = b[i + 1];
            b[i + 1] = b[i + 2];
            b[i + 2] = tmp;
        }
    }
"
11021,16871895,7,"    public UnivariateRealFunction interpolate(double x[], double y[]) {
        if (x.length != y.length) {
            throw new IllegalArgumentException(""Dataset arrays must have same length."");
        }
        if (x.length < 3) {
            throw new IllegalArgumentException(""At least 3 datapoints are required to compute a spline interpolant"");
        }
        int n = x.length - 1;
        for (int i = 0; i < n; i++) {
            if (x[i] >= x[i + 1]) {
                throw new IllegalArgumentException(""Dataset x values must be strictly increasing."");
            }
        }
        double h[] = new double[n];
        for (int i = 0; i < n; i++) {
            h[i] = x[i + 1] - x[i];
        }
        double mu[] = new double[n];
        double z[] = new double[n + 1];
        mu[0] = 0d;
        z[0] = 0d;
        double g = 0;
        for (int i = 1; i < n; i++) {
            g = 2d * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
            mu[i] = h[i] / g;
            z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1]) + y[i - 1] * h[i]) / (h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;
        }
        double b[] = new double[n];
        double c[] = new double[n + 1];
        double d[] = new double[n];
        z[n] = 0d;
        c[n] = 0d;
        for (int j = n - 1; j >= 0; j--) {
            c[j] = z[j] - mu[j] * c[j + 1];
            b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;
            d[j] = (c[j + 1] - c[j]) / (3d * h[j]);
        }
        PolynomialFunction polynomials[] = new PolynomialFunction[n];
        double coefficients[] = new double[4];
        for (int i = 0; i < n; i++) {
            coefficients[0] = y[i];
            coefficients[1] = b[i];
            coefficients[2] = c[i];
            coefficients[3] = d[i];
            polynomials[i] = new PolynomialFunction(coefficients);
        }
        return new PolynomialSplineFunction(x, polynomials);
    }
"
5202,5939463,7,"    static void getByteSwapped(byte[] b, int off, int len) {
        byte tempByte;
        for (int i = off; i < (off + len); i += 2) {
            tempByte = b[i];
            b[i] = b[i + 1];
            b[i + 1] = tempByte;
        }
    }
"
3355,3126012,7,"    public void leave() {
        for (int i = 1; i < Config.NUMAKKUS - 1; ++i) accu[i] = accu[i + 1];
    }
"
14973,23365203,7,"    public MainTest() {
        worldAABB = new AABB();
        worldAABB.lowerBound.set(-100, -100);
        worldAABB.upperBound.set(1500, 1000);
        debugDraw = new AngryPigDebugDraw(WIDTH, HEIGHT, 1.0f);
        mWorld = new World(worldAABB, new Vec2(0f, 40f), true);
        mWorld.setContactListener(new ConcreteContactListener());
        pigs = new Pig[PIG_TOTAL_COUNT];
        movingCloudSprite = new Sprite(ResourceManager.getMovingCloudImage());
        for (int i = 0; i < pigs.length; ++i) {
            pigs[i] = new Pig();
            pigs[i].setScore(5000);
        }
        pigs[0].getSprite().setCenterX(ORIBALLPOSTION.x);
        pigs[0].getSprite().setCenterY(ORIBALLPOSTION.y);
        pigs[1].getSprite().setCenterX(150);
        pigs[1].getSprite().setCenterY(590);
        pigs[2].getSprite().setCenterX(100);
        pigs[2].getSprite().setCenterY(590);
        birds = new Bird[BIRD_TOTAL_COUNT];
        birds[0] = new Bird();
        birds[0].createBird(mWorld, 770, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[1] = new Bird();
        birds[1].createBird(mWorld, 800, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[2] = new Bird();
        birds[2].createBird(mWorld, 830, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[3] = new Bird();
        birds[3].createBird(mWorld, 860, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[4] = new Bird();
        birds[4].createBird(mWorld, 890, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        RectWood1 = new RectBaseElement(ResourceManager.getLargeWoodRectangleImages());
        RectWood1.create(mWorld, 700, 580);
        RectWood1.setScore(500);
        CircleWood2 = new CircleBaseElement(ResourceManager.getMiddleWoodBallImages());
        CircleWood2.create(mWorld, 720, 570, 2f, 0.8f, 0.2f, 10f);
        CircleWood2.setScore(300);
        BattenWood3 = new RectBaseElement(ResourceManager.getShortWoodBattenImages());
        BattenWood3.create(mWorld, 900, 575, MathUtils.PI / 2);
        BattenWood3.setScore(100);
        BattenWood4 = new RectBaseElement(ResourceManager.getShortWoodBattenImages());
        BattenWood4.create(mWorld, 930, 575, MathUtils.PI / 2);
        BattenWood4.setScore(100);
        BattenWood5 = new RectBaseElement(ResourceManager.getShortWoodBattenImages());
        BattenWood5.create(mWorld, 915, 550);
        BattenWood5.setScore(100);
        RectWood6 = new RectBaseElement(ResourceManager.getMiddleWoodRectangleImages());
        RectWood6.create(mWorld, 925, 540);
        RectWood6.setScore(300);
        CircleWood7 = new CircleBaseElement(ResourceManager.getLargeWoodBallImages());
        CircleWood7.create(mWorld, 935, 520, 2.0f, 0.8f, 0.2f, 18f);
        CircleWood7.setScore(500);
        new Ground(mWorld, 0, GROUND_HEIGHT, WIDTH, HEIGHT);
        nanos = new long[fpsAverageCount];
        long nanosPerFrameGuess = (long) (1000000000.0 / targetFPS);
        nanos[fpsAverageCount - 1] = System.nanoTime();
        for (int i = fpsAverageCount - 2; i >= 0; --i) {
            nanos[i] = nanos[i + 1] - nanosPerFrameGuess;
        }
        nanoStart = System.nanoTime();
        frameRatePeriod = (long) (1000000000.0 / targetFPS);
        add(panel);
    }
"
1163,549749,7,"        private float[] makeKernel(double radius) {
            radius += 1;
            int size = (int) radius * 2 + 1;
            float[] kernel = new float[size];
            double v;
            for (int i = 0; i < size; i++) kernel[i] = (float) Math.exp(-0.5 * (sqr((i - radius) / (radius * 2))) / sqr(0.2));
            float[] kernel2 = new float[size - 2];
            for (int i = 0; i < size - 2; i++) kernel2[i] = kernel[i + 1];
            if (kernel2.length == 1) kernel2[0] = 1f;
            return kernel2;
        }
"
13197,20279241,7,"    public Bitmap getNextImage() {
        Log.w(""Debug main"", Long.toString(Thread.currentThread().getId()));
        if (list.getPosition() != list.toNext()) {
            if (images[0] != null) {
                garbage.add(images[0]);
                images[0] = null;
            }
            for (int i = 0; i < imageCount - 1; i++) images[i] = images[i + 1];
            images[imageCount - 1] = null;
            new LoadImageTask().execute(new Integer[] { LOAD_LAST_IMAGE });
        }
        return images[startPosition];
    }
"
7046,9125152,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = new Rectangle();
        } else items[0] = new Rectangle();
        current_item--;
    }
"
9451,14253967,7,"    public void dup2Bnth1() {
        assert mutable;
        sp -= 2;
        Object tmp1 = stack[sp] = stack[sp + 2];
        Object tmp2 = stack[sp + 1] = stack[sp + 3];
        stack[sp + 2] = stack[sp + 4];
        stack[sp + 3] = tmp1;
        stack[sp + 4] = tmp2;
    }
"
11562,17778165,7,"    private void setBytes(byte[] bytes, int nbBytes) {
        nbUnusedBits = bytes[0] & 0x07;
        nbBits = (nbBytes * 8) - nbUnusedBits;
        for (int i = 0; i < nbBytes; i++) {
            this.bytes[i] = bytes[i + 1];
        }
    }
"
2019,950505,7,"    void deletePFrame() {
        if (npframes > 1) {
            for (int i = upba.currentFrameIndex; i < npframes - 1; i++) {
                pframes[i] = pframes[i + 1];
            }
            pframes[npframes - 1] = null;
            if (upba.currentFrameIndex > 0) {
                upba.currentFrameIndex--;
            }
            npframes--;
            this.resethist();
        }
    }
"
14200,21807010,7,"    public void collectInternalCommand() {
        Database localDb = this.getFatherPanel().getLocalDb();
        try {
            String query = ""SELECT ID_SH2, IMAGE_NAME_SH2, ID_SH1, IMAGE_NAME_SH1, LINE_NUMBER, LINK_ACTION "" + ""FROM LINK_SHAPES "" + ""WHERE ID_SH1="" + getElemId() + "" AND IMAGE_NAME_SH1='"" + getImgName() + ""' AND "" + ""IMAGE_NAME_SH1=IMAGE_NAME_SH2 ORDER BY LINE_NUMBER"";
            Statement sp = localDb.createStatement();
            ResultSet rp = sp.executeQuery(query);
            Text command = Text.EMPTY;
            while (rp.next()) {
                command = Text.valueOf(rp.getString(""LINK_ACTION""));
                Text token[] = ParserUtils.split(command, "" "");
                if (token[0].toUpperCase().contentEquals(Text.valueOf(""ASSIGNVALUETO""))) {
                    variablesHashTable.put(token[1], new Integer(rp.getInt(""ID_SH2"")));
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""ASSIGNVALUE""))) {
                    this.setAssignExpression(token[1]);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""FASTASSIGN""))) {
                    this.setFastAssignExpression(token[1]);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""ABSDIFF""))) {
                    Text[] expr = new Text[token.length - 1];
                    System.arraycopy(token, 1, expr, 0, expr.length);
                    setAbsDiffExpression(expr);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""ASSIGNCOLORTO""))) {
                    colorVariablesHashTable.put(token[1], new Integer(rp.getInt(""ID_SH2"")));
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""CHANGEFONTCOLORIF""))) {
                    for (int i = 1; i < token.length - 2; i++) {
                        setFontColorExpression(0, getFontColorExpression()[0].concat(BLANK).concat(token[i]));
                    }
                    setFontColorExpression(1, getFontColorExpression()[1].concat(BLANK).concat(token[token.length - 2]));
                    setFontColorExpression(2, getFontColorExpression()[2].concat(BLANK).concat(token[token.length - 1]));
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""CHANGECOLORSIF""))) {
                    for (int i = 1; i < token.length - 2; i++) {
                        setColorExpression(0, getColorExpression()[0].concat(BLANK).concat(token[i]));
                    }
                    setColorExpression(1, getColorExpression()[1].concat(BLANK).concat(token[token.length - 2]));
                    setColorExpression(2, getColorExpression()[2].concat(BLANK).concat(token[token.length - 1]));
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""ORCHECKCOLORS""))) {
                    Text[] colExpr = new Text[token.length];
                    colExpr[0] = OR;
                    int j = 1;
                    for (int i = 0; i < token.length - 1; i++) {
                        if (!token[i + 1].contentEquals(Text.EMPTY)) {
                            colExpr[j] = token[i + 1];
                            j++;
                        }
                    }
                    Text[] res = new Text[j];
                    setFastCheckColorExpression(res);
                    System.arraycopy(colExpr, 0, res, 0, res.length);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""ANDCHECKCOLORS""))) {
                    Text[] colExpr = new Text[token.length];
                    colExpr[0] = AND;
                    int j = 1;
                    for (int i = 0; i < token.length - 1; i++) {
                        if (!token[i + 1].contentEquals(Text.EMPTY)) {
                            colExpr[j] = token[i + 1];
                            j++;
                        }
                    }
                    Text[] res = new Text[j];
                    setFastCheckColorExpression(res);
                    System.arraycopy(colExpr, 0, res, 0, res.length);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""ORCHECKFONTCOLORS""))) {
                    Text[] colExpr = new Text[token.length];
                    colExpr[0] = OR;
                    int j = 1;
                    for (int i = 0; i < token.length - 1; i++) {
                        if (!token[i + 1].contentEquals(Text.EMPTY)) {
                            colExpr[j] = token[i + 1];
                            j++;
                        }
                    }
                    Text[] res = new Text[j];
                    setFastCheckFontColorExpression(res);
                    System.arraycopy(colExpr, 0, res, 0, res.length);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""ANDCHECKFONTCOLORS""))) {
                    Text[] colExpr = new Text[token.length];
                    colExpr[0] = AND;
                    int j = 1;
                    for (int i = 0; i < token.length - 1; i++) {
                        if (!token[i + 1].contentEquals(Text.EMPTY)) {
                            colExpr[j] = token[i + 1];
                            j++;
                        }
                    }
                    Text[] res = new Text[j];
                    setFastCheckFontColorExpression(res);
                    System.arraycopy(colExpr, 0, res, 0, res.length);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""VISIBLEIF""))) {
                    Text visExpr = Text.EMPTY;
                    for (int i = 1; i < token.length; i++) {
                        visExpr = visExpr.concat(token[i]);
                    }
                    setVisualizationExpression(visExpr);
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""CHANGEBORDERCOLORIF""))) {
                    for (int i = 1; i < token.length - 2; i++) {
                        setBorderColorExpression(0, getBorderColorExpression()[0].concat(BLANK).concat(token[i]));
                    }
                    setBorderColorExpression(1, getBorderColorExpression()[1].concat(BLANK).concat(token[token.length - 2]));
                    setBorderColorExpression(2, getBorderColorExpression()[2].concat(BLANK).concat(token[token.length - 1]));
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""CHANGEFILLCOLORIF""))) {
                    for (int i = 1; i < token.length - 2; i++) {
                        setFillColorExpression(0, getFillColorExpression()[0].concat(BLANK).concat(token[i]));
                    }
                    setFillColorExpression(1, getFillColorExpression()[1].concat(BLANK).concat(token[token.length - 2]));
                    setFillColorExpression(2, getFillColorExpression()[2].concat(BLANK).concat(token[token.length - 1]));
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""CHANGEVALUEIF""))) {
                    for (int i = 1; i < token.length - 2; i++) {
                        setChangeValueExpression(0, getFillColorExpression()[0].concat(BLANK).concat(token[i]));
                    }
                    setChangeValueExpression(1, getFillColorExpression()[1].concat(BLANK).concat(token[token.length - 2]));
                    setChangeValueExpression(2, getFillColorExpression()[2].concat(BLANK).concat(token[token.length - 1]));
                } else if (token[0].toUpperCase().contentEquals(Text.valueOf(""EXECUTE""))) {
                    enableThreadCreation = true;
                    String path = command.toString().substring(token[0].length() + 1, command.length());
                    if (path.startsWith(""%CURDIR/"")) {
                        path = getFatherPanel().getCurDir() + ""/"" + path.replaceAll(""%CURDIR/"", """");
                    } else if (path.startsWith(""%CURDIR\\"")) {
                        path = getFatherPanel().getCurDir() + path.replaceAll(""%CURDIR"", """");
                    }
                    path = path.replaceAll(""//"", ""\\"");
                    byte buff[] = new byte[2048];
                    try {
                        InputStream fileIn = new FileInputStream(path);
                        int i = fileIn.read(buff);
                        associatedScript = new String(buff);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
"
3059,2483705,7,"    public byte[] decode(int b[]) {
        int intCount = b.length;
        byte outb[] = new byte[intCount * 4];
        int tmp[] = new int[2];
        int i, j;
        for (j = 0, i = 0; i < intCount; i += 2, j += 8) {
            tmp[0] = b[i];
            tmp[1] = b[i + 1];
            decipher(tmp);
            outb[j] = (byte) (tmp[0] >>> 24);
            outb[j + 1] = (byte) (tmp[0] >>> 16);
            outb[j + 2] = (byte) (tmp[0] >>> 8);
            outb[j + 3] = (byte) (tmp[0]);
            outb[j + 4] = (byte) (tmp[1] >>> 24);
            outb[j + 5] = (byte) (tmp[1] >>> 16);
            outb[j + 6] = (byte) (tmp[1] >>> 8);
            outb[j + 7] = (byte) (tmp[1]);
        }
        return outb;
    }
"
3941,4254071,7,"    public static void toggleShortEndian(byte[] b, int off, int len) {
        if (b == null || len == 0) return;
        int end = off + len;
        if (off < 0 || len < 0 || end > b.length) throw new IndexOutOfBoundsException(""b.length = "" + b.length + "", off = "" + off + "", len = "" + len);
        if ((len & 1) != 0) throw new IllegalArgumentException(""len = "" + len);
        byte tmp;
        for (int i = off; i < end; i++, i++) {
            tmp = b[i];
            b[i] = b[i + 1];
            b[i + 1] = tmp;
        }
    }
"
7030,9105957,7,"    public double[] runWithoutAnnealing(boolean tuneScalingFactor, double startScale, double temperature) {
        double[] weights = runLBFGSSolver(tuneScalingFactor, startScale, temperature);
        if (tuneScalingFactor) {
            System.out.println(""optimal scaling factor is "" + weights[0]);
            double[] res = new double[numParameters];
            for (int i = 0; i < numParameters; i++) res[i] = weights[i + 1];
            return res;
        } else {
            return weights;
        }
    }
"
2996,2416844,7,"    public static void novo_dia(double p, int volume, double dias[]) {
        p = obv(p, volume);
        for (int i = 0; i < PERIODO - 1; i++) dias[i] = dias[i + 1];
        dias[PERIODO - 1] = p;
    }
"
1123,534543,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
12423,19348945,7,"    public void step5() {
        int len = k - l + 1;
        boolean repeated = true;
        for (int i = l; i < k; i++) {
            if (b[i] == b[i + 1]) {
                for (int j = i + 1; j < k; j++) b[j] = b[j + 1];
                k--;
                break;
            }
        }
    }
"
7729,10555306,7,"    public static void subBomb() {
        for (int k = 0; k < 19; k++) {
            bomb[k] = bomb[k + 1];
            bomb[19] = null;
        }
    }
"
2450,1637025,7,"    private float[] oddFiltering(float[] src, int z) throws ErrorException {
        int subbandSize = src.length;
        int half = subbandSize / 2;
        float dst[] = new float[subbandSize];
        for (int k = 0; k < half; k++) {
            dst[2 * k] = src[k];
            dst[2 * k + 1] = src[half + k + 1];
        }
        dst[subbandSize - 1] = src[half];
        if (WTTypes[z] == 1) {
            dst[0] = dst[0] - (float) (Math.floor(((dst[1] + dst[1] + 2) / 4)));
            for (int k = 2; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - (float) (Math.floor(((dst[k - 1] + dst[k + 1] + 2) / 4)));
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] - (float) (Math.floor((dst[subbandSize - 2] + dst[subbandSize - 2] + 2) / 4));
            for (int k = 1; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] + (float) (Math.floor(((dst[k - 1] + dst[k + 1]) / 2)));
            }
        } else if (WTTypes[z] == 2 || WTTypes[z] == 3) {
            final float alfa_97 = -1.586134342059924F;
            final float beta_97 = -0.052980118572961F;
            final float gamma_97 = 0.882911075530934F;
            final float delta_97 = 0.443506852043971F;
            final float nh_97, nl_97;
            if (WTTypes[z] == 2) {
                nh_97 = 1.230174104914001F;
                nl_97 = 1F / nh_97;
            } else {
                nh_97 = 1.14960430535816F;
                nl_97 = -1F / nh_97;
            }
            for (int k = 0; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] / nl_97;
                dst[k + 1] = dst[k + 1] / nh_97;
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] / nl_97;
            dst[0] = dst[0] - delta_97 * (dst[1] + dst[1]);
            for (int k = 2; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - delta_97 * (dst[k - 1] + dst[k + 1]);
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] - delta_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
            for (int k = 1; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - gamma_97 * (dst[k - 1] + dst[k + 1]);
            }
            dst[0] = dst[0] - beta_97 * (dst[1] + dst[1]);
            for (int k = 2; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - beta_97 * (dst[k - 1] + dst[k + 1]);
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] - beta_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
            for (int k = 1; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - alfa_97 * (dst[k - 1] + dst[k + 1]);
            }
        } else if (WTTypes[z] == 4) {
            throw new ErrorException(""Integer 9/7M CCSDS Recommended is not implemented for odd signals.!!!"");
        } else if (WTTypes[z] == 5 || WTTypes[z] == 6) {
            final float alfa, beta, gamma, delta;
            if (WTTypes[z] == 6) {
                alfa = -1.58615986717275F;
                beta = -0.05297864003258F;
                gamma = 0.88293362717904F;
                delta = 0.44350482244527F;
            } else {
                alfa = -0.5F;
                beta = 0.25F;
                gamma = 0.F;
                delta = 0.F;
            }
            if (WTTypes[z] == 6) {
                dst[0] = dst[0] - (float) Math.floor(delta * (dst[1] + dst[1]) + 0.5);
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - (float) Math.floor(delta * (dst[k - 1] + dst[k + 1]) + 0.5);
                }
                dst[subbandSize - 1] = dst[subbandSize - 1] - (float) Math.floor(delta * (dst[subbandSize - 2] + dst[subbandSize - 2]) + 0.5);
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - (float) Math.floor(gamma * (dst[k - 1] + dst[k + 1]) + 0.5);
                }
            }
            dst[0] = dst[0] - (float) Math.floor(beta * (dst[1] + dst[1]) + 0.5);
            for (int k = 2; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - (float) Math.floor(beta * (dst[k - 1] + dst[k + 1]) + 0.5);
            }
            dst[subbandSize - 1] = dst[subbandSize - 1] - (float) Math.floor(beta * (dst[subbandSize - 2] + dst[subbandSize - 2]) + 0.5);
            for (int k = 1; k < subbandSize - 1; k += 2) {
                dst[k] = dst[k] - (float) Math.floor(alfa * (dst[k - 1] + dst[k + 1]) + 0.5);
            }
        } else if (WTTypes[z] == 7) {
            float sample1 = 0, sample2 = 0;
            float normFactor = (float) (Math.sqrt(2));
            for (int k = 0; k < subbandSize - 1; k += 2) {
                sample1 = dst[k] + dst[k + 1];
                sample2 = dst[k] - dst[k + 1];
                dst[k] = sample1 * normFactor;
                dst[k + 1] = sample2 * normFactor;
            }
            dst[subbandSize - 1] = dst[subbandSize - 1];
        } else if (WTTypes[z] == 8) {
            float s = 0;
            for (int k = 0; k < subbandSize - 1; k += 2) {
                s = dst[k] - (float) Math.floor(dst[k + 1] / 2);
                dst[k] = dst[k + 1] + s;
                dst[k + 1] = s;
            }
            dst[subbandSize - 1] = dst[subbandSize - 1];
        } else {
            throw new ErrorException(""Unrecognized wavelet transform type."");
        }
        return (dst);
    }
"
4226,4647387,7,"    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = ""IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN"")
    RetVal RPSpos(int nr, double Tr[], double Xr[], double Yr[], double Zr[], double Vs, double Xt, double Yt, double Zt) {
        int i, j, k, ns, cmax;
        int[] ce = new int[NMAX];
        double Rq;
        double[] Rs = new double[NMAX];
        double[] Xs = new double[NMAX];
        double[] Ys = new double[NMAX];
        double[] Zs = new double[NMAX];
        double x, y, z, Rmax;
        double Ww, Xw, Yw, Zw, w, q;
        double err, var, vmax, vmin;
        j = k = 0;
        var = 0;
        vmax = SMAX * SMAX * Vs * Vs;
        vmin = 1.0 * Vs * Vs;
        ns = 0;
        Rs[NMAX - 1] = TMAX;
        Rmax = Vs * TMAX;
        for (i = 0; i < nr; i++) {
            if (Tr[i] == 0.0) continue;
            Rq = Vs * (Tr[i] + offset);
            if ((Rq >= Rmax) || (Rq < Vs * TMIN)) continue;
            if (ns == 0) {
                Rs[0] = Rq;
                Xs[0] = Xr[i];
                Ys[0] = Yr[i];
                Zs[0] = Zr[i];
                ns = 1;
            } else {
                j = ((ns == NMAX) ? (ns - 1) : (ns++));
                for (; ; j--) {
                    if ((j > 0) && (Rq < Rs[j - 1])) {
                        Rs[j] = Rs[j - 1];
                        Xs[j] = Xs[j - 1];
                        Ys[j] = Ys[j - 1];
                        Zs[j] = Zs[j - 1];
                    } else {
                        if ((j < NMAX - 1) || (Rq < Rs[j])) {
                            Rs[j] = Rq;
                            Xs[j] = Xr[i];
                            Ys[j] = Yr[i];
                            Zs[j] = Zr[i];
                        }
                        break;
                    }
                }
            }
        }
        for (i = 0; i < ns; i++) ce[i] = 0;
        for (i = 0; i < ns - 1; i++) {
            for (j = i + 1; j < ns; j++) {
                q = Math.sqrt((Xs[i] - Xs[j]) * (Xs[i] - Xs[j]) + (Ys[i] - Ys[j]) * (Ys[i] - Ys[j]) + (Zs[i] - Zs[j]) * (Zs[i] - Zs[j]));
                if ((Rs[i] + Rs[j] < q) || (Rs[i] - Rs[j] > q) || (Rs[j] - Rs[i] > q)) {
                    ++ce[i];
                    ++ce[j];
                }
            }
        }
        cmax = 1;
        while (cmax != 0) {
            cmax = 0;
            for (i = 0; i < ns; i++) {
                if (ce[i] >= cmax) {
                    cmax = ce[i];
                    j = i;
                }
            }
            if (cmax > 0) {
                for (i = 0; i < ns; i++) {
                    if (i == j) continue;
                    q = Math.sqrt((Xs[i] - Xs[j]) * (Xs[i] - Xs[j]) + (Ys[i] - Ys[j]) * (Ys[i] - Ys[j]) + (Zs[i] - Zs[j]) * (Zs[i] - Zs[j]));
                    if ((Rs[i] + Rs[j] < q) || (Rs[i] - Rs[j] > q) || (Rs[j] - Rs[i] > q)) {
                        --ce[i];
                    }
                }
                for (i = j; i < ns - 1; i++) {
                    Rs[i] = Rs[i + 1];
                    Xs[i] = Xs[i + 1];
                    Ys[i] = Ys[i + 1];
                    Zs[i] = Zs[i + 1];
                    ce[i] = ce[i + 1];
                }
                --ns;
            }
        }
        if (ns < 3) {
            Xt = Yt = Zt = 9.9999999e99;
            return new RetVal(1, Xt, Yt, Zt, Vs);
        }
        x = y = 0.0;
        z = -100000.0;
        for (i = 0; i < 1250; i++) {
            if (i < 50) j = k = i % ns; else if (i < 1000) {
                while ((j = (int) Math.floor((ns) * Math.random())) == k) {
                }
                k = j;
            } else j = (1249 - i) % ns;
            if (i < 750) w = 1.0; else {
                w = 1.0 - Rs[j] / Rmax;
                w = w * w;
            }
            if (i >= 1000) w *= 5.0 - 0.004 * i;
            q = Math.sqrt((Xs[j] - x) * (Xs[j] - x) + (Ys[j] - y) * (Ys[j] - y) + (Zs[j] - z) * (Zs[j] - z));
            q = w * (1.0 - Rs[j] / q);
            x += q * (Xs[j] - x);
            y += q * (Ys[j] - y);
            z += q * (Zs[j] - z);
        }
        for (i = 0; i < 15; i++) {
            Ww = Xw = Yw = Zw = var = 0.0;
            for (j = 0; j < ns; j++) {
                q = Math.sqrt((Xs[j] - x) * (Xs[j] - x) + (Ys[j] - y) * (Ys[j] - y) + (Zs[j] - z) * (Zs[j] - z));
                err = q - Rs[j];
                q = 1.0 - Rs[j] / q;
                w = 1.0 - Rs[j] / Rmax;
                w = w * w;
                Xw += w * (x + q * (Xs[j] - x));
                Yw += w * (y + q * (Ys[j] - y));
                Zw += w * (z + q * (Zs[j] - z));
                Ww += w;
                var += w * err * err;
            }
            x = Xw / Ww;
            y = Yw / Ww;
            z = Zw / Ww;
            var = var / Ww;
        }
        Xt = x;
        Yt = y;
        Zt = z;
        if ((var > vmax) || ((ns == 3) && (var > vmin))) {
            return new RetVal(2, Xt, Yt, Zt, Vs);
        }
        return new RetVal(0, Xt, Yt, Zt, Vs);
    }
"
14020,21514569,7,"    public synchronized void remove(Axis Axis) {
        for (int i = 0; i < size - 1; i++) {
            if (axes[i] == Axis) {
                for (; i < size - 1; i++) {
                    axes[i] = axes[i + 1];
                }
            }
        }
        size--;
        axes[size] = null;
    }
"
8246,12432826,7,"        public void addToQueue(Object o) {
            if (!isFull) {
                pos++;
                q[pos] = o;
            } else {
                for (int i = 0; i < size - 1; i++) {
                    q[i] = q[i + 1];
                }
                q[size - 1] = o;
            }
            if (pos >= (size - 1)) {
                isFull = true;
            }
        }
"
11620,17866017,7,"    public RatPoly differentiate() {
        if (deg == 0) return ZERO;
        RatPoly deriv = new RatPoly(BigRational.ZERO, deg - 1);
        for (int i = 0; i < deg; i++) deriv.coef[i] = coef[i + 1].times(new BigRational(i + 1));
        deriv.deg = deriv.degree();
        return deriv;
    }
"
2128,1197769,7,"    public void put(Rectangle2D.Double ext) {
        if ((ext != null) && ((num < 1) || (ext != extents[num - 1]))) {
            if (num < (NUMREC)) {
                extents[num] = ext;
                num = num + 1;
            } else {
                for (int i = 0; i < (NUMREC - 1); i++) {
                    extents[i] = extents[i + 1];
                }
                extents[num - 1] = ext;
            }
        }
    }
"
708,323857,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
8201,12288290,7,"    public static void main(String args[]) {
        args = new String[] { ""ExtractMassChromatograms"", ""-h"" };
        try {
            if (args.length < 1) {
                System.err.println(""[ERROR]: the tool-name to be executed needs to be supplied."");
                System.exit(0);
            }
            Class<? extends Object> cls = null;
            for (Class<? extends Object> c : Tool.getAllClasses(""mzmatch.ipeak"")) {
                if (c.getName().endsWith(args[0])) {
                    cls = c;
                    break;
                }
            }
            if (cls == null) {
                System.err.println(""[ERROR]: unable to locate the requested application '"" + args[0] + ""'"");
                System.exit(0);
            }
            String real_args[] = new String[args.length - 1];
            for (int i = 0; i < args.length - 1; ++i) real_args[i] = args[i + 1];
            for (Method method : cls.getMethods()) {
                if (method.getName().equals(""main"")) {
                    method.invoke(null, (Object) real_args);
                    break;
                }
            }
        } catch (Exception e) {
            Tool.unexpectedError(e, ""mzmatch.Execute"");
        }
    }
"
1935,921066,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
4685,5362350,7,"    private CommandLine parseCommandLine(TclObject argv[]) throws ParseException {
        String[] args = new String[argv.length - 1];
        for (int i = 0; i < argv.length - 1; i++) args[i] = argv[i + 1].toString();
        CommandLine cl = (new PosixParser()).parse(this.opts, args);
        return cl;
    }
"
8471,12812043,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
"
88,34923,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
8071,11832425,7,"    private Object[] getArgs(Object value[]) {
        Object[] args = new Object[value.length - 1];
        for (int i = 0; i < args.length; i++) {
            args[i] = value[i + 1];
        }
        return args;
    }
"
9308,14039746,7,"    protected static Long[] removeFromIDArray(Long[] array, Long el) {
        int index = -1;
        for (int n = 0; n < array.length; n++) {
            if (array[n] == el) {
                index = n;
                break;
            }
        }
        assert index != -1;
        Long[] retArray = new Long[array.length - 1];
        for (int n = 0; n < retArray.length; n++) {
            if (n < index) {
                retArray[n] = array[n];
            } else {
                retArray[n] = array[n + 1];
            }
        }
        return retArray;
    }
"
7176,9396597,7,"    protected double backDelay(double[] pattern) {
        int y;
        for (y = 0; y < m_taps; ++y) {
            backmemory[y] = backmemory[y + 1];
            backmemory[y] += pattern[y];
        }
        backmemory[m_taps] = pattern[m_taps];
        return backmemory[0];
    }
"
10548,16103479,7,"    public IDLValue parseIDLArrayTokens(String[] tokens, int type) {
        IDLValue expr1 = null, result = null;
        int ileft;
        int iright;
        if (tokens.length == 0) {
            return null;
        }
        if (tokens.length == 1) {
            expr1 = new IDLValue(Double.parseDouble(tokens[0]));
            return expr1;
        }
        String[] ops = null;
        int next_parser;
        if (type == EXPR) {
            ops = new String[2];
            ops[0] = ""+"";
            ops[1] = ""-"";
            next_parser = TERM;
        } else if (type == TERM) {
            ops = new String[2];
            ops[0] = ""*"";
            ops[1] = ""/"";
            next_parser = FACTOR;
        } else if (type == FACTOR) {
            ops = new String[1];
            ops[0] = ""^"";
            next_parser = NUMBER;
            if (tokens[0].equals(""-"")) {
                String[] expr = new String[tokens.length - 1];
                for (int i = 0; i < expr.length; i++) expr[i] = tokens[i + 1];
                expr1 = parseIDLArrayTokens(expr, FACTOR);
                result = expr1.IDLmultiply(new IDLValue(-1));
                return result;
            }
        } else {
            next_parser = NOPARSER;
            if (tokens[0].equals(""("") && tokens[tokens.length - 1].equals("")"")) {
                ileft = 1;
                iright = tokens.length - 2;
                String[] expr = new String[iright - ileft + 1];
                for (int i = 0; i < expr.length; i++) expr[i] = tokens[i + ileft];
                expr1 = parseIDLArrayTokens(expr, EXPR);
                return expr1;
            } else if (tokens[0].equals(""["") && tokens[tokens.length - 1].equals(""]"")) {
                expr1 = parseIDLExprList(tokens);
                return expr1;
            } else if (tokens[0].equalsIgnoreCase(""findgen"") || tokens[0].equalsIgnoreCase(""dindgen"")) {
                String[] expr = new String[tokens.length - 3];
                for (int i = 0; i < expr.length; i++) expr[i] = tokens[i + 2];
                expr1 = parseIDLArrayTokens(expr, EXPR);
                if (expr1.type != IDLValue.SCALAR) {
                    org.das2.util.DasDie.println(""Syntax error in findgen argument"");
                    System.exit(-1);
                } else {
                    expr1 = IDLValue.findgen((int) expr1.sValue);
                }
            } else if (tokens[0].equalsIgnoreCase(""alog10"")) {
                String[] expr = new String[tokens.length - 3];
                for (int i = 0; i < expr.length; i++) expr[i] = tokens[i + 2];
                expr1 = parseIDLArrayTokens(expr, EXPR);
                expr1 = IDLValue.alog10(expr1);
            } else if (tokens[0].equalsIgnoreCase(""sin"")) {
                String[] expr = new String[tokens.length - 3];
                for (int i = 0; i < expr.length; i++) expr[i] = tokens[i + 2];
                expr1 = parseIDLArrayTokens(expr, EXPR);
                expr1 = IDLValue.sin(expr1);
            } else {
                return null;
            }
            return expr1;
        }
        int ileftop = 9999;
        String leftop = """";
        int nleft_paren = 0;
        int nleft_bracket = 0;
        for (int iop = 0; iop < ops.length; iop++) {
            for (int itok = 0; itok < tokens.length; itok++) {
                if (tokens[itok].equals(""["")) nleft_bracket++;
                if (tokens[itok].equals(""("")) nleft_paren++;
                if (tokens[itok].equals(""]"")) nleft_bracket--;
                if (tokens[itok].equals("")"")) nleft_paren--;
                if (tokens[itok].equals(ops[iop]) && itok != 0) {
                    if ((iop < ileftop) && (nleft_paren == 0) && (nleft_bracket == 0)) {
                        ileftop = itok;
                        leftop = ops[iop];
                    }
                }
            }
        }
        if (ileftop == 9999) {
            result = parseIDLArrayTokens(tokens, next_parser);
        } else {
            String[] expr = new String[ileftop];
            for (int i = 0; i < ileftop; i++) expr[i] = tokens[i];
            expr1 = parseIDLArrayTokens(expr, next_parser);
            expr = new String[tokens.length - ileftop - 1];
            for (int i = 0; i < expr.length; i++) expr[i] = tokens[i + ileftop + 1];
            IDLValue expr2 = parseIDLArrayTokens(expr, type);
            if (expr1 == null || expr2 == null) {
                if (next_parser == NOPARSER) result = null; else result = parseIDLArrayTokens(tokens, next_parser);
            } else if (leftop.equals(""+"")) {
                result = expr1.IDLadd(expr2);
            } else if (leftop.equals(""-"")) {
                result = expr1.IDLsubtract(expr2);
            } else if (leftop.equals(""*"")) {
                result = expr1.IDLmultiply(expr2);
            } else if (leftop.equals(""/"")) {
                result = expr1.IDLdivide(expr2);
            } else if (leftop.equals(""^"")) {
                result = expr1.IDLexponeniate(expr2);
            }
        }
        return result;
    }
"
4705,5385367,7,"    public void moveInstrument(int fromPos, int toPos) {
        Instrument tempInstr;
        if (toPos == fromPos) return;
        tempInstr = instruments[fromPos];
        changeInstrument(toPos, fromPos + OFFSET);
        if (toPos < fromPos) {
            for (int i = fromPos; i > toPos; i--) {
                instruments[i] = instruments[i - 1];
                changeInstrument(i, i - 1 + OFFSET);
            }
        } else {
            for (int i = fromPos; i < toPos; i++) {
                instruments[i] = instruments[i + 1];
                changeInstrument(i, i + 1 + OFFSET);
            }
        }
        instruments[toPos] = tempInstr;
        normalizeInstrument();
    }
"
14405,22077976,7,"    public static void invoke(Object... args) {
        String eventName = (String) args[0];
        int len = args.length - 1;
        Object[] eventArgs = new Object[len];
        for (int i = 0; i < len; i++) {
            eventArgs[i] = args[i + 1];
        }
        List<Event> events = EventFactory.getInstance().getEvents(eventName);
        if (events != null) {
            for (Event event : events) {
                try {
                    event.execute(eventArgs);
                } catch (Exception ex) {
                    logger.error(ex);
                }
            }
        }
    }
"
14097,21607021,7,"    public static void loadBinary(InputStream inStream) throws IOException {
        DataInputStream in = new DataInputStream(inStream);
        head = readShortTable(in, HEAD_LENGTH);
        int[] tableSizes = new int[INDEX_TABLEEND];
        for (int i = 0; i < INDEX_TABLEEND; i++) {
            tableSizes[i] = head[i + 1] - head[i];
        }
        table_scriptIDs = readShortTable(in, tableSizes[INDEX_scriptIDs]);
        table_scriptFonts = readShortTable(in, tableSizes[INDEX_scriptFonts]);
        table_elcIDs = readShortTable(in, tableSizes[INDEX_elcIDs]);
        table_sequences = readShortTable(in, tableSizes[INDEX_sequences]);
        table_fontfileNameIDs = readShortTable(in, tableSizes[INDEX_fontfileNameIDs]);
        table_componentFontNameIDs = readShortTable(in, tableSizes[INDEX_componentFontNameIDs]);
        table_filenames = readShortTable(in, tableSizes[INDEX_filenames]);
        table_awtfontpaths = readShortTable(in, tableSizes[INDEX_awtfontpaths]);
        table_exclusions = readShortTable(in, tableSizes[INDEX_exclusions]);
        table_proportionals = readShortTable(in, tableSizes[INDEX_proportionals]);
        table_scriptFontsMotif = readShortTable(in, tableSizes[INDEX_scriptFontsMotif]);
        table_alphabeticSuffix = readShortTable(in, tableSizes[INDEX_alphabeticSuffix]);
        table_stringIDs = readShortTable(in, tableSizes[INDEX_stringIDs]);
        stringCache = new String[table_stringIDs.length + 1];
        int len = tableSizes[INDEX_stringTable];
        byte[] bb = new byte[len * 2];
        table_stringTable = new char[len];
        in.read(bb);
        int i = 0, j = 0;
        while (i < len) {
            table_stringTable[i++] = (char) (bb[j++] << 8 | (bb[j++] & 0xff));
        }
        if (verbose) {
            dump();
        }
    }
"
1740,801834,7,"    public static int[] keyLeftMove(int[] source, int i) {
        int temp = 0;
        int len = source.length;
        int ls = LS[i];
        for (int k = 0; k < ls; k++) {
            temp = source[0];
            for (int j = 0; j < len - 1; j++) {
                source[j] = source[j + 1];
            }
            source[len - 1] = temp;
        }
        return source;
    }
"
7238,9525629,7,"    String InputCommand() {
        int size = Shell.CMD_MAXLINE - 2;
        byte[] c = new byte[1];
        IntRef n = new IntRef(1);
        int str_len = 0;
        int str_index = 0;
        IntRef len = new IntRef(0);
        boolean current_hist = false;
        byte[] line = new byte[Shell.CMD_MAXLINE];
        int it_history = 0;
        int it_completion = 0;
        while (size != 0) {
            Dos.dos.echo = false;
            while (!Dos_files.DOS_ReadFile(input_handle, c, n)) {
                IntRef dummy = new IntRef(0);
                Dos_files.DOS_CloseFile(input_handle);
                Dos_files.DOS_OpenFile(""con"", 2, dummy);
                Log.log(LogTypes.LOG_MISC, LogSeverities.LOG_ERROR, ""Reopening the input handle.This is a bug!"");
            }
            if (n.value == 0) {
                size = 0;
                continue;
            }
            switch(c[0]) {
                case 0x00:
                    {
                        Dos_files.DOS_ReadFile(input_handle, c, n);
                        switch(c[0]) {
                            case 0x3d:
                                if (l_history.size() == 0) break;
                                it_history = 0;
                                if (l_history.size() > 0 && ((String) l_history.firstElement()).length() > str_len) {
                                    String reader = ((String) l_history.firstElement()).substring(str_len);
                                    for (int i = 0; i < reader.length(); i++) {
                                        c[0] = (byte) reader.charAt(0);
                                        line[str_index++] = (byte) reader.charAt(0);
                                        Dos_files.DOS_WriteFile(Dos_files.STDOUT, c, n);
                                    }
                                    str_len = str_index = ((String) l_history.firstElement()).length();
                                    size = Shell.CMD_MAXLINE - str_index - 2;
                                    line[str_len] = 0;
                                }
                                break;
                            case 0x4B:
                                if (str_index != 0) {
                                    outc(8);
                                    str_index--;
                                }
                                break;
                            case 0x4D:
                                if (str_index < str_len) {
                                    outc(line[str_index++]);
                                }
                                break;
                            case 0x47:
                                while (str_index != 0) {
                                    outc(8);
                                    str_index--;
                                }
                                break;
                            case 0x4F:
                                while (str_index < str_len) {
                                    outc(line[str_index++]);
                                }
                                break;
                            case 0x48:
                                if (l_history.size() == 0 || it_history == l_history.size()) break;
                                if (it_history == 0 && !current_hist) {
                                    current_hist = true;
                                    l_history.insertElementAt(new String(line, 0, str_len), 0);
                                    it_history++;
                                }
                                for (; str_index > 0; str_index--) {
                                    outc(8);
                                    outc(' ');
                                    outc(8);
                                }
                                StringHelper.strcpy(line, (String) l_history.elementAt(it_history));
                                len.value = ((String) l_history.elementAt(it_history)).length();
                                str_len = str_index = len.value;
                                size = Shell.CMD_MAXLINE - str_index - 2;
                                Dos_files.DOS_WriteFile(Dos_files.STDOUT, line, len);
                                it_history++;
                                break;
                            case 0x50:
                                if (l_history.size() == 0 || it_history == 0) break;
                                it_history--;
                                if (it_history == 0) {
                                    it_history++;
                                    if (current_hist) {
                                        current_hist = false;
                                        l_history.removeElementAt(0);
                                    }
                                    break;
                                } else it_history--;
                                for (; str_index > 0; str_index--) {
                                    outc(8);
                                    outc(' ');
                                    outc(8);
                                }
                                StringHelper.strcpy(line, (String) l_history.elementAt(it_history));
                                len.value = ((String) l_history.elementAt(it_history)).length();
                                str_len = str_index = len.value;
                                size = Shell.CMD_MAXLINE - str_index - 2;
                                Dos_files.DOS_WriteFile(Dos_files.STDOUT, line, len);
                                it_history++;
                                break;
                            case 0x53:
                                {
                                    if (str_index >= str_len) break;
                                    IntRef a = new IntRef(str_len - str_index - 1);
                                    byte[] text = new byte[a.value];
                                    System.arraycopy(line, str_index + 1, text, 0, a.value);
                                    Dos_files.DOS_WriteFile(Dos_files.STDOUT, text, a);
                                    outc(' ');
                                    outc(8);
                                    for (int i = str_index; i < str_len - 1; i++) {
                                        line[i] = line[i + 1];
                                        outc(8);
                                    }
                                    line[--str_len] = 0;
                                    size++;
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    break;
                case 0x08:
                    if (str_index != 0) {
                        outc(8);
                        int str_remain = str_len - str_index;
                        size++;
                        if (str_remain != 0) {
                            for (int i = 0; i < str_remain; i++) line[str_index - 1 + i] = line[str_index + i];
                            line[--str_len] = 0;
                            str_index--;
                            for (int i = str_index; i < str_len; i++) outc(line[i]);
                        } else {
                            line[--str_index] = '\0';
                            str_len--;
                        }
                        outc(' ');
                        outc(8);
                        while (str_remain-- != 0) outc(8);
                    }
                    if (l_completion.size() != 0) l_completion.clear();
                    break;
                case 0x0a:
                    break;
                case 0x0d:
                    outc('\n');
                    size = 0;
                    break;
                case '\t':
                    {
                        if (l_completion.size() != 0) {
                            it_completion++;
                            if (it_completion == l_completion.size()) it_completion = 0;
                        } else {
                            boolean dir_only = StringHelper.toString(line).toUpperCase().startsWith(""CD "");
                            String sLine = StringHelper.toString(line);
                            int p_completion_start = sLine.lastIndexOf(' ');
                            if (p_completion_start >= 0) {
                                p_completion_start++;
                                completion_index = p_completion_start;
                            } else {
                                p_completion_start = 0;
                                completion_index = 0;
                            }
                            int path;
                            if ((path = sLine.substring(completion_index).lastIndexOf('\\')) >= 0) completion_index += path + 1;
                            if ((path = sLine.substring(completion_index).lastIndexOf('/')) >= 0) completion_index += path + 1;
                            String mask;
                            if (p_completion_start >= 0) {
                                mask = sLine.substring(p_completion_start);
                                int dot_pos = mask.lastIndexOf('.');
                                int bs_pos = mask.lastIndexOf('\\');
                                int fs_pos = mask.lastIndexOf('/');
                                int cl_pos = mask.lastIndexOf(':');
                                if ((dot_pos - bs_pos > 0) && (dot_pos - fs_pos > 0) && (dot_pos - cl_pos > 0)) mask += ""*""; else mask += ""*.*"";
                            } else {
                                mask = ""*.*"";
                            }
                            int save_dta = Dos.dos.dta();
                            Dos.dos.dta((int) Dos.dos.tables.tempdta);
                            boolean res = Dos_files.DOS_FindFirst(mask, 0xffff & ~Dos_system.DOS_ATTR_VOLUME);
                            if (!res) {
                                Dos.dos.dta((int) save_dta);
                                break;
                            }
                            Dos_DTA dta = new Dos_DTA(Dos.dos.dta());
                            StringRef name = new StringRef();
                            LongRef sz = new LongRef(0);
                            IntRef date = new IntRef(0);
                            IntRef time = new IntRef(0);
                            ShortRef att = new ShortRef(0);
                            int extIndex = 0;
                            while (res) {
                                dta.GetResult(name, sz, date, time, att);
                                if (!name.value.equals(""."") && !name.value.equals("".."")) {
                                    if (dir_only) {
                                        if ((att.value & Dos_system.DOS_ATTR_DIRECTORY) != 0) l_completion.add(name.value);
                                    } else {
                                        int pos = name.value.lastIndexOf('.');
                                        String ext = null;
                                        if (pos >= 0) ext = name.value.substring(pos + 1);
                                        if (ext != null && (ext.equalsIgnoreCase(""BAT"") || ext.equalsIgnoreCase(""COM"") || ext.equalsIgnoreCase(""EXE""))) l_completion.insertElementAt(name.value, extIndex++); else l_completion.add(name.value);
                                    }
                                }
                                res = Dos_files.DOS_FindNext();
                            }
                            it_completion = 0;
                            Dos.dos.dta((int) save_dta);
                        }
                        if (l_completion.size() != 0 && ((String) l_completion.elementAt(it_completion)).length() != 0) {
                            for (; str_index > completion_index; str_index--) {
                                outc(8);
                                outc(' ');
                                outc(8);
                            }
                            StringHelper.strcpy(line, completion_index, (String) l_completion.elementAt(it_completion));
                            len.value = ((String) l_completion.elementAt(it_completion)).length();
                            str_len = str_index = completion_index + len.value;
                            size = Shell.CMD_MAXLINE - str_index - 2;
                            Dos_files.DOS_WriteFile(Dos_files.STDOUT, ((String) l_completion.elementAt(it_completion)).getBytes(), len);
                        }
                    }
                    break;
                case 0x1b:
                    outc('\\');
                    outc('\n');
                    line[0] = 0;
                    if (l_completion.size() != 0) l_completion.clear();
                    StringHelper.strcpy(line, InputCommand());
                    size = 0;
                    str_len = 0;
                    break;
                default:
                    if (l_completion.size() != 0) l_completion.clear();
                    if (str_index < str_len && true) {
                        outc(' ');
                        IntRef a = new IntRef(str_len - str_index);
                        byte[] text = new byte[a.value];
                        System.arraycopy(line, str_index, text, 0, a.value);
                        Dos_files.DOS_WriteFile(Dos_files.STDOUT, text, a);
                        outc(8);
                        for (int i = str_len; i > str_index; i--) {
                            line[i] = line[i - 1];
                            outc(8);
                        }
                        line[++str_len] = 0;
                        size--;
                    }
                    line[str_index] = c[0];
                    str_index++;
                    if (str_index > str_len) {
                        line[str_index] = '\0';
                        str_len++;
                        size--;
                    }
                    Dos_files.DOS_WriteFile(Dos_files.STDOUT, c, n);
                    break;
            }
        }
        if (str_len == 0) return null;
        str_len++;
        if (current_hist) {
            current_hist = false;
            l_history.removeElementAt(0);
        }
        String sLine = StringHelper.toString(line);
        l_history.insertElementAt(sLine, 0);
        it_history = 0;
        if (l_completion.size() != 0) l_completion.clear();
        return sLine;
    }
"
13577,20727054,7,"    protected void drawPrimaryLineAsPath(XYItemRendererState state, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea) {
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double x1 = dataset.getXValue(series, item);
        double y1 = dataset.getYValue(series, item);
        double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation);
        double transY1 = rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation);
        if (!Double.isNaN(transX1) && !Double.isNaN(transY1)) {
            ControlPoint p = new ControlPoint(plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transY1 : (float) transX1, plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transX1 : (float) transY1);
            if (!this.points.contains(p)) {
                this.points.add(p);
            }
        }
        if (item == dataset.getItemCount(series) - 1) {
            State s = (State) state;
            if (this.points.size() > 1) {
                ControlPoint cp0 = (ControlPoint) this.points.get(0);
                s.seriesPath.moveTo(cp0.x, cp0.y);
                if (this.points.size() == 2) {
                    ControlPoint cp1 = (ControlPoint) this.points.get(1);
                    s.seriesPath.lineTo(cp1.x, cp1.y);
                } else {
                    int np = this.points.size();
                    float[] d = new float[np];
                    float[] x = new float[np];
                    float y;
                    float t;
                    float[] a = new float[np];
                    float t1;
                    float t2;
                    float[] h = new float[np];
                    for (int i = 0; i < np; i++) {
                        ControlPoint cpi = (ControlPoint) this.points.get(i);
                        x[i] = cpi.x;
                        d[i] = cpi.y;
                    }
                    for (int i = 1; i <= np - 1; i++) {
                        h[i] = x[i] - x[i - 1];
                    }
                    float[] sub = new float[np - 1];
                    float[] diag = new float[np - 1];
                    float[] sup = new float[np - 1];
                    for (int i = 1; i <= np - 2; i++) {
                        diag[i] = (h[i] + h[i + 1]) / 3;
                        sup[i] = h[i + 1] / 6;
                        sub[i] = h[i] / 6;
                        a[i] = (d[i + 1] - d[i]) / h[i + 1] - (d[i] - d[i - 1]) / h[i];
                    }
                    solveTridiag(sub, diag, sup, a, np - 2);
                    s.seriesPath.moveTo(x[0], d[0]);
                    for (int i = 1; i <= np - 1; i++) {
                        for (int j = 1; j <= this.precision; j++) {
                            t1 = (h[i] * j) / this.precision;
                            t2 = h[i] - t1;
                            y = ((-a[i - 1] / 6 * (t2 + h[i]) * t1 + d[i - 1]) * t2 + (-a[i] / 6 * (t1 + h[i]) * t2 + d[i]) * t1) / h[i];
                            t = x[i - 1] + t1;
                            s.seriesPath.lineTo(t, y);
                        }
                    }
                }
                drawFirstPassShape(g2, pass, series, item, s.seriesPath);
            }
            this.points = new Vector();
        }
    }
"
12288,19068322,7,"    void image(int subsample, GRect rect, int index, final byte[] img8, int rowsize, int pixsep, boolean fast) {
        int nlevel = 0;
        while ((nlevel < 5) && ((32 >> nlevel) > subsample)) {
            nlevel++;
        }
        final int boxsize = 1 << nlevel;
        if (subsample != (32 >> nlevel)) {
            throw new IllegalArgumentException(""(IWMap::image) Unsupported subsampling factor"");
        }
        if (rect.isEmpty()) {
            throw new IllegalArgumentException(""(IWMap::image) GRect is empty"");
        }
        GRect irect = new GRect(0, 0, ((iw + subsample) - 1) / subsample, ((ih + subsample) - 1) / subsample);
        if ((rect.xmin < 0) || (rect.ymin < 0) || (rect.xmax > irect.xmax) || (rect.ymax > irect.ymax)) {
            throw new IllegalArgumentException(""(IWMap::image) GRect is out of bounds: "" + rect.xmin + "","" + rect.ymin + "","" + rect.xmax + "","" + rect.ymax + "","" + irect.xmax + "","" + irect.ymax);
        }
        GRect[] needed = new GRect[8];
        GRect[] recomp = new GRect[8];
        for (int i = 0; i < 8; ) {
            needed[i] = new GRect();
            recomp[i++] = new GRect();
        }
        int r = 1;
        needed[nlevel] = (GRect) rect.clone();
        recomp[nlevel] = (GRect) rect.clone();
        for (int i = nlevel - 1; i >= 0; i--) {
            needed[i] = recomp[i + 1];
            needed[i].inflate(3 * r, 3 * r);
            needed[i].intersect(needed[i], irect);
            r += r;
            recomp[i].xmin = ((needed[i].xmin + r) - 1) & ~(r - 1);
            recomp[i].xmax = needed[i].xmax & ~(r - 1);
            recomp[i].ymin = ((needed[i].ymin + r) - 1) & ~(r - 1);
            recomp[i].ymax = needed[i].ymax & ~(r - 1);
        }
        GRect work = new GRect();
        work.xmin = needed[0].xmin & ~(boxsize - 1);
        work.ymin = needed[0].ymin & ~(boxsize - 1);
        work.xmax = ((needed[0].xmax - 1) & ~(boxsize - 1)) + boxsize;
        work.ymax = ((needed[0].ymax - 1) & ~(boxsize - 1)) + boxsize;
        final int dataw = work.width();
        final short[] data = new short[dataw * work.height()];
        int blkw = bw >> 5;
        int lblock = ((work.ymin >> nlevel) * blkw) + (work.xmin >> nlevel);
        final short[] liftblock = new short[1024];
        for (int by = work.ymin, ldata = 0; by < work.ymax; by += boxsize, ldata += (dataw << nlevel), lblock += blkw) {
            for (int bx = work.xmin, bidx = lblock, rdata = ldata; bx < work.xmax; bx += boxsize, bidx++, rdata += boxsize) {
                IWBlock block = blocks[bidx];
                int mlevel = nlevel;
                if ((nlevel > 2) && (((bx + 31) < needed[2].xmin) || (bx > needed[2].xmax) || ((by + 31) < needed[2].ymin) || (by > needed[2].ymax))) {
                    mlevel = 2;
                }
                final int bmax = ((1 << (mlevel + mlevel)) + 15) >> 4;
                final int ppinc = 1 << (nlevel - mlevel);
                final int ppmod1 = dataw << (nlevel - mlevel);
                final int ttmod0 = 32 >> mlevel;
                final int ttmod1 = ttmod0 << 5;
                block.write_liftblock(liftblock, 0, bmax);
                for (int ii = 0, tt = 0, pp = rdata; ii < boxsize; ii += ppinc, pp += ppmod1, tt += (ttmod1 - 32)) {
                    for (int jj = 0; jj < boxsize; jj += ppinc, tt += ttmod0) {
                        data[pp + jj] = liftblock[tt];
                    }
                }
            }
        }
        r = boxsize;
        for (int i = 0; i < nlevel; i++) {
            GRect comp = needed[i];
            comp.xmin = comp.xmin & ~(r - 1);
            comp.ymin = comp.ymin & ~(r - 1);
            comp.translate(-work.xmin, -work.ymin);
            if (fast && (i >= 4)) {
                for (int ii = comp.ymin, pp = (comp.ymin * dataw); ii < comp.ymax; ii += 2, pp += (dataw + dataw)) {
                    for (int jj = comp.xmin; jj < comp.xmax; jj += 2) {
                        data[pp + jj + dataw] = data[pp + jj + dataw + 1] = data[pp + jj + 1] = data[pp + jj];
                    }
                }
                break;
            }
            backward(data, (comp.ymin * dataw) + comp.xmin, comp.width(), comp.height(), dataw, r, r >> 1);
            r >>= 1;
        }
        GRect nrect = (GRect) rect.clone();
        nrect.translate(-work.xmin, -work.ymin);
        for (int i = nrect.ymin, pidx = (nrect.ymin * dataw), ridx = index; i++ < nrect.ymax; ridx += rowsize, pidx += dataw) {
            for (int j = nrect.xmin, pixidx = ridx; j < nrect.xmax; j++, pixidx += pixsep) {
                int x = (data[pidx + j] + 32) >> 6;
                if (x < -128) {
                    x = -128;
                } else if (x > 127) {
                    x = 127;
                }
                img8[pixidx] = (byte) x;
            }
        }
    }
"
3087,2506360,7,"    public static final double neville(double[] x, double[] y, double t) {
        double[] w = ArrayUtils.copy(y);
        for (int i = 0; i < x.length; i++) {
            for (int j = i - 1; j >= 0; j--) {
                w[j] = w[j + 1] + (w[j + 1] - w[j]) * (t - x[i]) / (x[i] - x[j]);
            }
        }
        return w[0];
    }
"
8934,13558690,7,"    public void removeElementAt(int i) {
        if (i >= size || i < 0) throw new RuntimeException(""tried to remove an element outside the vector's limits"");
        for (int j = i; j < size - 1; j++) store[j] = store[j + 1];
        setSize(size - 1);
    }
"
5217,5953187,7,"    public Object[] invoke(DPWSContextImpl context, OperationInfo context_aoi, Object body) throws DPWSException {
        String actionURI = (context_aoi.isEvent()) ? context_aoi.getOutAction() : context_aoi.getInAction();
        OperationInfo aoi = invokationMap.get(actionURI);
        if (aoi == null) throw new DPWSException(""Could not invoke action : "" + actionURI + "" ."");
        Method method = aoi.getMethod();
        if (method == null) throw new DPWSException(""No method define for action : "" + actionURI + "" ."");
        Class<?>[] classes = method.getParameterTypes();
        if (classes == null) throw new DPWSException(""Method with incorrect parameters for action : "" + actionURI + "" ."");
        int len = classes.length;
        Object[] params = new Object[classes.length];
        params[0] = context;
        Object localImplementor = actionToImplementor.get(actionURI);
        if (body == null) {
        } else if (body instanceof List) {
            List<?> bodyList = (List<?>) body;
            if (!(localImplementor instanceof InvocationHandler) && len != 1 + bodyList.size()) throw new DPWSException(""Incorrect parameter number for action : "" + actionURI + "" ."");
            for (int i = 0; i < bodyList.size(); i++) params[i + 1] = bodyList.get(i);
        } else {
            params[1] = new Object[] { body };
        }
        try {
            Class<?> retClass = method.getReturnType();
            if (localImplementor instanceof InvocationHandler) {
                InvocationHandler handler = (InvocationHandler) localImplementor;
                Object obj = handler.invoke(null, method, params);
                return new Object[] { obj };
            }
            if (retClass.isArray()) {
                return (Object[]) method.invoke(localImplementor, params);
            }
            Object obj = null;
            if ((getIfmappingpe() != null) && (getIfmappingpe().serviceMap.containsKey(actionURI))) {
                Mappedservice ms = getIfmappingpe().serviceMap.get(actionURI);
                if (ms.invparams.length == 0) obj = ms.invmethode.invoke(getIfmappingpe().invokerinstanz); else {
                    Object[] invokingparameters = new Object[params.length - 1];
                    for (int i = 0; i < params.length - 1; i++) invokingparameters[0] = params[i + 1];
                    obj = ms.invmethode.invoke(getIfmappingpe().invokerinstanz, invokingparameters);
                }
            } else {
                obj = method.invoke(localImplementor, params);
            }
            return new Object[] { obj };
        } catch (IllegalArgumentException e) {
            throw new DPWSException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new DPWSException(e.getMessage());
        } catch (InvocationTargetException e) {
            if (e.getTargetException() instanceof DPWSException) throw (DPWSException) e.getTargetException();
            throw new DPWSException(e.getTargetException());
        } catch (Throwable e) {
            log.error(""While invoking InvocationHandler"", e);
            throw new DPWSException(e.getMessage());
        }
    }
"
10089,15095879,7,"    public void setAttributes(Attribute[] attrs) {
        for (int i = 0; i < attrs.length; i++) {
            if (attrs[i].getName().contains("".csv"")) {
                Attribute[] attrs2 = new Attribute[attrs.length - 1];
                for (int j = 0; j < i; j++) {
                    attrs2[j] = attrs[j];
                }
                for (int j = i; j < attrs2.length; j++) {
                    attrs2[j] = attrs[j + 1];
                }
                attrs = attrs2;
                i = -1;
            }
        }
        super.setAttributes(attrs);
        allAttributes = null;
    }
"
10566,16118684,7,"    @Override
    protected boolean readEphCoeff(double jultime) {
        boolean result = false;
        if ((jultime < this.startepoch) || (jultime >= this.finalepoch)) {
            return result;
        }
        if ((jultime < this.ephemerisdates[1]) || (jultime >= this.ephemerisdates[2])) {
            int i = 0;
            int records = 0;
            int j = 0;
            String filename = "" "";
            char[] cline = new char[80];
            try {
                for (i = 0; i < startfiledates.length - 1; i++) {
                    if ((jultime >= startfiledates[i]) && (jultime < startfiledates[i + 1])) {
                        ephemerisdates[1] = startfiledates[i];
                        ephemerisdates[2] = startfiledates[i + 1];
                        filename = filenames[i];
                        records = (int) (ephemerisdates[2] - ephemerisdates[1]) / intervalduration;
                    }
                }
                filename = this.patheph + filename;
                FileReader file = new FileReader(filename);
                for (j = 1; j <= records; j++) {
                    file.read(cline, 0, 13);
                    for (i = 2; i <= 341; i++) {
                        file.read(cline, 0, 79);
                        cline[22] = 'e';
                        cline[48] = 'e';
                        cline[74] = 'e';
                        if (i > 2) {
                            ephemeriscoefficients[(j - 1) * numbersperinterval + (3 * (i - 2) - 1)] = Double.parseDouble(String.valueOf(cline, 1, 25));
                        }
                        if ((i > 2) & (i < 341)) {
                            ephemeriscoefficients[(j - 1) * numbersperinterval + 3 * (i - 2)] = Double.parseDouble(String.valueOf(cline, 27, 25));
                        }
                        if (i < 341) {
                            ephemeriscoefficients[(j - 1) * numbersperinterval + (3 * (i - 2) + 1)] = Double.parseDouble(String.valueOf(cline, 53, 25));
                        }
                    }
                }
                file.close();
                result = true;
            } catch (IOException e) {
                System.out.println(""Error = "" + e.toString());
            } catch (StringIndexOutOfBoundsException e) {
                System.out.println(""Error = "" + e.toString());
            }
        } else {
            result = true;
        }
        return result;
    }
"
9144,13773908,7,"    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println(""The first argument must be a command."");
            usage();
            System.exit(-1);
        }
        String commandName = args[0];
        Command command = commands.get(commandName);
        if (command == null) {
            System.err.println(""Unknown command: "" + commandName);
            usage();
            System.exit(-1);
        }
        String[] commandArgs = new String[args.length - 1];
        for (int i = 0; i < commandArgs.length; i++) {
            commandArgs[i] = args[i + 1];
        }
        Object options = command.getOptions();
        CmdLineParser parser = new CmdLineParser(options);
        try {
            parser.parseArgument(commandArgs);
            command.validate();
            command.execute();
            System.exit(0);
        } catch (CmdLineException e) {
            System.err.println(e.getMessage());
            usage(parser, commandName);
            System.exit(1);
        } catch (CommandException e) {
            System.err.print(e.getMessage());
            Throwable cause = e.getCause();
            if (cause != null) {
                System.out.println(String.format("" (%s)"", cause.getMessage()));
            } else {
                System.out.println();
            }
            if (e.isUsageError()) {
                usage(parser, commandName);
            }
            System.exit(2);
        } catch (RuntimeException e) {
            System.err.println(""Unexpected error:"");
            e.printStackTrace();
            System.exit(3);
        }
    }
"
11406,17467704,7,"    private void shiftToLeft(final Gene[] genes, final int begin, final int end) {
        for (int i = begin; i < end; i++) {
            genes[i] = genes[i + 1];
        }
    }
"
8158,12260540,7,"    private void deleteFriend(YahooUser yu, String gr) {
        int idx, j;
        for (idx = 0; idx < groups.length; idx++) if (groups[idx].getName().equalsIgnoreCase(gr)) break;
        if (idx >= groups.length) return;
        j = groups[idx].getIndexOfFriend(yu.getId());
        if (j < 0) return;
        groups[idx].removeUserAt(j);
        yu.adjustGroupCount(-1);
        if (groups[idx].isEmpty()) {
            YahooGroup[] arr = new YahooGroup[groups.length - 1];
            for (j = 0; j < idx; j++) arr[j] = groups[j];
            for (j = idx; j < arr.length; j++) arr[j] = groups[j + 1];
            groups = arr;
        }
    }
"
11524,17734555,7,"    public DoubleMatrix2D getPrecedentInfo(int distance, LogReader log) {
        int numSimilarPIs = 0;
        log.reset();
        modelElements = log.getLogSummary().getLogEvents();
        System.out.println(""walid"");
        boolean update = false;
        int s = modelElements.size();
        DoubleMatrix2D D = DoubleFactory2D.sparse.make(s, s, 0);
        while (log.hasNext()) {
            ProcessInstance pi = log.next();
            numSimilarPIs = MethodsForWorkflowLogDataStructures.getNumberSimilarProcessInstances(pi);
            int[] memory = new int[distance];
            int i = 0;
            AuditTrailEntries ates = pi.getAuditTrailEntries();
            while (ates.hasNext()) {
                AuditTrailEntry ate = ates.next();
                if (i < distance) {
                    memory[i] = modelElements.findLogEventNumber(ate.getElement(), ate.getType());
                    i++;
                    continue;
                }
                int index = modelElements.findLogEventNumber(ate.getElement(), ate.getType());
                if (distance == 0) {
                    D.set(index, index, D.get(index, index) + numSimilarPIs);
                } else {
                    D.set(index, memory[0], D.get(index, memory[0]) + numSimilarPIs);
                    for (int j = 0; j < distance - 1; j++) {
                        memory[j] = memory[j + 1];
                    }
                    memory[distance - 1] = index;
                }
            }
        }
        return D;
    }
"
12718,19658649,7,"    private static void dualPivotQuicksort(float[] a, int left, int right) {
        int sixth = (right - left + 1) / 6;
        int e1 = left + sixth;
        int e5 = right - sixth;
        int e3 = (left + right) >>> 1;
        int e4 = e3 + sixth;
        int e2 = e3 - sixth;
        float ae1 = a[e1], ae2 = a[e2], ae3 = a[e3], ae4 = a[e4], ae5 = a[e5];
        if (ae1 > ae2) {
            float t = ae1;
            ae1 = ae2;
            ae2 = t;
        }
        if (ae4 > ae5) {
            float t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        if (ae1 > ae3) {
            float t = ae1;
            ae1 = ae3;
            ae3 = t;
        }
        if (ae2 > ae3) {
            float t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae1 > ae4) {
            float t = ae1;
            ae1 = ae4;
            ae4 = t;
        }
        if (ae3 > ae4) {
            float t = ae3;
            ae3 = ae4;
            ae4 = t;
        }
        if (ae2 > ae5) {
            float t = ae2;
            ae2 = ae5;
            ae5 = t;
        }
        if (ae2 > ae3) {
            float t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae4 > ae5) {
            float t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        a[e1] = ae1;
        a[e3] = ae3;
        a[e5] = ae5;
        float pivot1 = ae2;
        a[e2] = a[left];
        float pivot2 = ae4;
        a[e4] = a[right];
        int less = left + 1;
        int great = right - 1;
        boolean pivotsDiffer = (pivot1 != pivot2);
        if (pivotsDiffer) {
            outer: for (int k = less; k <= great; k++) {
                float ak = a[k];
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = a[great];
                        a[great--] = ak;
                    }
                }
            }
        } else {
            for (int k = less; k <= great; k++) {
                float ak = a[k];
                if (ak == pivot1) {
                    continue;
                }
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = pivot1;
                        a[great--] = ak;
                    }
                }
            }
        }
        a[left] = a[less - 1];
        a[less - 1] = pivot1;
        a[right] = a[great + 1];
        a[great + 1] = pivot2;
        doSort(a, left, less - 2);
        doSort(a, great + 2, right);
        if (!pivotsDiffer) {
            return;
        }
        if (less < e1 && great > e5) {
            while (a[less] == pivot1) {
                less++;
            }
            while (a[great] == pivot2) {
                great--;
            }
            outer: for (int k = less; k <= great; k++) {
                float ak = a[k];
                if (ak == pivot2) {
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) {
                        a[k] = a[less];
                        a[less++] = pivot1;
                    } else {
                        a[k] = a[great];
                    }
                    a[great--] = pivot2;
                } else if (ak == pivot1) {
                    a[k] = a[less];
                    a[less++] = pivot1;
                }
            }
        }
        doSort(a, less, great);
    }
"
11321,17356254,7,"    protected void computeCoefficients() throws ArithmeticException {
        int i, j, n;
        double c[], tc[], d, t;
        n = degree() + 1;
        coefficients = new double[n];
        for (i = 0; i < n; i++) {
            coefficients[i] = 0.0;
        }
        c = new double[n + 1];
        c[0] = 1.0;
        for (i = 0; i < n; i++) {
            for (j = i; j > 0; j--) {
                c[j] = c[j - 1] - c[j] * x[i];
            }
            c[0] *= (-x[i]);
            c[i + 1] = 1;
        }
        tc = new double[n];
        for (i = 0; i < n; i++) {
            d = 1;
            for (j = 0; j < n; j++) {
                if (i != j) {
                    d *= (x[i] - x[j]);
                }
            }
            if (d == 0.0) {
                throw new ArithmeticException(""Identical abscissas cause division by zero."");
            }
            t = y[i] / d;
            tc[n - 1] = c[n];
            coefficients[n - 1] += t * tc[n - 1];
            for (j = n - 2; j >= 0; j--) {
                tc[j] = c[j + 1] + tc[j + 1] * x[i];
                coefficients[j] += t * tc[j];
            }
        }
        coefficientsComputed = true;
    }
"
4985,5701392,7,"    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException(""You can't remove an item until you've done at least one next()"");
        }
        if (list[position - 1] != null) {
            for (int i = position - 1; i < (list.length - 1); i++) {
                list[i] = list[i + 1];
            }
            list[list.length - 1] = null;
        }
    }
"
7809,10824720,7,"        FinishedMatchRegular getStatsMessage() {
            MauMauPlayerWrapper[] sort = new MauMauPlayerWrapper[indexOfNextSubscriberToAdd];
            System.arraycopy(players, 0, sort, 0, sort.length);
            MauMauPlayerWrapper s;
            for (int o = 0; o < sort.length; o++) for (int i = 0; i < sort.length - o - 1; i++) if (sort[i + 1].getMinusPoints() < sort[i].getMinusPoints()) {
                s = sort[i];
                sort[i] = sort[i + 1];
                sort[i + 1] = s;
            }
            if (matchEndsWithGamesWon()) {
                for (int o = 0; o < sort.length; o++) for (int i = 0; i < sort.length - o - 1; i++) if (sort[i].getGamesWon() < sort[i + 1].getGamesWon()) {
                    s = sort[i];
                    sort[i] = sort[i + 1];
                    sort[i + 1] = s;
                }
            }
            String[] playersNames = new String[sort.length];
            int[] playersMali = new int[sort.length];
            int[] playersGames = new int[sort.length];
            for (int i = 0; i < sort.length; i++) {
                playersNames[i] = sort[i].getName();
                playersMali[i] = sort[i].getMinusPoints();
                playersGames[i] = sort[i].getGamesWon();
            }
            return new FinishedMatchRegular(getName(), playersNames, playersMali, playersGames);
        }
"
12758,19680898,7,"    public static int[] getFirstDifference(final int[] population) {
        Arrays.sort(population);
        final int[] jumps = new int[population.length - 1];
        for (int i = 0; i < jumps.length; i++) {
            jumps[i] = population[i + 1] - population[i];
        }
        return jumps;
    }
"
14904,23246356,7,"        private static void rotate(byte[] key) {
            byte[] x = new byte[64];
            System.arraycopy(key, 0, x, 0, x.length);
            for (int i = 0; i < 55; i++) {
                x[i] = x[i + 1];
            }
            x[27] = key[0];
            x[55] = key[28];
            System.arraycopy(x, 0, key, 0, key.length);
        }
"
6332,7999521,7,"    private void processColorCache(RdpPacket_Localised data) throws RdesktopException {
        byte[] palette = null;
        byte[] red = null;
        byte[] green = null;
        byte[] blue = null;
        int j = 0;
        int cache_id = data.get8();
        int n_colors = data.getLittleEndian16();
        palette = new byte[n_colors * 4];
        red = new byte[n_colors];
        green = new byte[n_colors];
        blue = new byte[n_colors];
        data.copyToByteArray(palette, 0, data.getPosition(), palette.length);
        data.incrementPosition(palette.length);
        for (int i = 0; i < n_colors; i++) {
            blue[i] = palette[j];
            green[i] = palette[j + 1];
            red[i] = palette[j + 2];
            j += 4;
        }
        IndexColorModel cm = new IndexColorModel(8, n_colors, red, green, blue);
        cache.put_colourmap(cache_id, cm);
    }
"
12378,19204899,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = 0;
        } else items[0] = 0;
        current_item--;
    }
"
10324,15563829,7,"    public void removeLayerAt(int idx) {
        for (int i = idx; i < layers.length - 1; i++) {
            layers[i] = layers[i + 1];
        }
        layers[layers.length - 1] = null;
        layers = Arrays.copyOf(layers, layers.length - 1);
    }
"
4960,5693688,7,"    protected void drawPrimaryLineAsPath(XYItemRendererState state, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea) {
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double x1 = dataset.getXValue(series, item);
        double y1 = dataset.getYValue(series, item);
        double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation);
        double transY1 = rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation);
        if (!Double.isNaN(transX1) && !Double.isNaN(transY1)) {
            ControlPoint p = new ControlPoint(plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transY1 : (float) transX1, plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transX1 : (float) transY1);
            if (!this.points.contains(p)) {
                this.points.add(p);
            }
        }
        if (item == dataset.getItemCount(series) - 1) {
            State s = (State) state;
            if (this.points.size() > 1) {
                ControlPoint cp0 = (ControlPoint) this.points.get(0);
                s.seriesPath.moveTo(cp0.x, cp0.y);
                if (this.points.size() == 2) {
                    ControlPoint cp1 = (ControlPoint) this.points.get(1);
                    s.seriesPath.lineTo(cp1.x, cp1.y);
                } else {
                    int np = this.points.size();
                    float[] d = new float[np];
                    float[] x = new float[np];
                    float y;
                    float t;
                    float oldy = 0;
                    float oldt = 0;
                    float[] a = new float[np];
                    float t1;
                    float t2;
                    float[] h = new float[np];
                    for (int i = 0; i < np; i++) {
                        ControlPoint cpi = (ControlPoint) this.points.get(i);
                        x[i] = cpi.x;
                        d[i] = cpi.y;
                    }
                    for (int i = 1; i <= np - 1; i++) {
                        h[i] = x[i] - x[i - 1];
                    }
                    float[] sub = new float[np - 1];
                    float[] diag = new float[np - 1];
                    float[] sup = new float[np - 1];
                    for (int i = 1; i <= np - 2; i++) {
                        diag[i] = (h[i] + h[i + 1]) / 3;
                        sup[i] = h[i + 1] / 6;
                        sub[i] = h[i] / 6;
                        a[i] = (d[i + 1] - d[i]) / h[i + 1] - (d[i] - d[i - 1]) / h[i];
                    }
                    solveTridiag(sub, diag, sup, a, np - 2);
                    oldt = x[0];
                    oldy = d[0];
                    s.seriesPath.moveTo(oldt, oldy);
                    for (int i = 1; i <= np - 1; i++) {
                        for (int j = 1; j <= this.precision; j++) {
                            t1 = (h[i] * j) / this.precision;
                            t2 = h[i] - t1;
                            y = ((-a[i - 1] / 6 * (t2 + h[i]) * t1 + d[i - 1]) * t2 + (-a[i] / 6 * (t1 + h[i]) * t2 + d[i]) * t1) / h[i];
                            t = x[i - 1] + t1;
                            s.seriesPath.lineTo(t, y);
                            oldt = t;
                            oldy = y;
                        }
                    }
                }
                drawFirstPassShape(g2, pass, series, item, s.seriesPath);
            }
            this.points = new Vector();
        }
    }
"
5743,7043771,7,"    private int lame_decode_initfile(final RandomAccessFile fd, final MP3Data mp3data, final Enc enc) {
        byte buf[] = new byte[100];
        short pcm_l[] = new short[1152], pcm_r[] = new short[1152];
        boolean freeformat = false;
        if (hip != null) {
            mpg.hip_decode_exit(hip);
        }
        hip = mpg.hip_decode_init();
        int len = 4;
        try {
            fd.readFully(buf, 0, len);
        } catch (IOException e) {
            e.printStackTrace();
            return -1;
        }
        if (buf[0] == 'I' && buf[1] == 'D' && buf[2] == '3') {
            if (parse.silent < 10) {
                System.out.println(""ID3v2 found. "" + ""Be aware that the ID3 tag is currently lost when transcoding."");
            }
            len = 6;
            try {
                fd.readFully(buf, 0, len);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
            buf[2] &= 127;
            buf[3] &= 127;
            buf[4] &= 127;
            buf[5] &= 127;
            len = (((((buf[2] << 7) + buf[3]) << 7) + buf[4]) << 7) + buf[5];
            try {
                fd.skipBytes(len);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
            len = 4;
            try {
                fd.readFully(buf, 0, len);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
        }
        if (check_aid(buf)) {
            try {
                fd.readFully(buf, 0, 2);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
            int aid_header = (buf[0] & 0xff) + 256 * (buf[1] & 0xff);
            if (parse.silent < 10) {
                System.out.printf(""Album ID found.  length=%d \n"", aid_header);
            }
            try {
                fd.skipBytes(aid_header - 6);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
            try {
                fd.readFully(buf, 0, len);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
        }
        len = 4;
        while (!is_syncword_mp123(buf)) {
            int i;
            for (i = 0; i < len - 1; i++) buf[i] = buf[i + 1];
            try {
                fd.readFully(buf, len - 1, 1);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
        }
        if ((buf[2] & 0xf0) == 0) {
            if (parse.silent < 10) {
                System.out.println(""Input file is freeformat."");
            }
            freeformat = true;
        }
        int ret = mpg.hip_decode1_headersB(hip, buf, len, pcm_l, pcm_r, mp3data, enc);
        if (-1 == ret) return -1;
        while (!mp3data.header_parsed) {
            try {
                fd.readFully(buf);
            } catch (IOException e) {
                e.printStackTrace();
                return -1;
            }
            ret = mpg.hip_decode1_headersB(hip, buf, buf.length, pcm_l, pcm_r, mp3data, enc);
            if (-1 == ret) return -1;
        }
        if (mp3data.bitrate == 0 && !freeformat) {
            if (parse.silent < 10) {
                System.err.println(""fail to sync..."");
            }
            return lame_decode_initfile(fd, mp3data, enc);
        }
        if (mp3data.totalframes > 0) {
        } else {
            mp3data.nsamp = -1;
        }
        return 0;
    }
"
10165,15246531,7,"    public static void main(String[] args) {
        int nmcnt = 0;
        int mmcnt = 0;
        int umcnt = 0;
        int qccnt = 0;
        int total = 0;
        int[] lenHisto = new int[100];
        if (args.length < 2) {
            System.out.println(""usage: <output file name> <eland files>"");
            System.exit(0);
        }
        String outName = args[0];
        String[] files = new String[args.length - 1];
        for (int i = 0; i < files.length; i++) {
            files[i] = args[i + 1];
        }
        System.out.println(""Working with:"");
        for (String s : files) System.out.println(s);
        int[] lengths = null;
        lengths = getLengths(files);
        BufferedReader[] elands = new BufferedReader[files.length];
        String[] lines = new String[files.length];
        String um_f = outName + "".um.eland"";
        String nm_f = outName + "".nm.eland"";
        String mm_f = outName + "".mm.eland"";
        String qc_f = outName + "".qc.eland"";
        String sum_f = outName + "".summary"";
        System.out.println(""Writing to:\n"" + um_f + ""\n"" + nm_f + ""\n"" + mm_f + ""\n"" + qc_f + ""\n"" + sum_f);
        FileWriter um = null;
        FileWriter nm = null;
        FileWriter mm = null;
        FileWriter qc = null;
        FileWriter sum = null;
        try {
            um = new FileWriter(um_f);
            nm = new FileWriter(nm_f);
            mm = new FileWriter(mm_f);
            qc = new FileWriter(qc_f);
            sum = new FileWriter(sum_f);
        } catch (IOException io) {
            System.out.println(""Can't create files.  Exiting"");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
            System.exit(0);
        }
        assert (um != null);
        assert (nm != null);
        assert (mm != null);
        assert (qc != null);
        assert (sum != null);
        for (int i = 0; i < elands.length; i++) {
            try {
                elands[i] = new BufferedReader(new FileReader(files[i]));
            } catch (FileNotFoundException FNF) {
                System.out.println(""Could not open a file provided: "" + files[i]);
            }
        }
        try {
            while (elands[0].ready()) {
                total++;
                if (total % 10000 == 0) {
                    System.out.print(""."");
                }
                for (int i = 0; i < elands.length; i++) {
                    lines[i] = elands[i].readLine();
                }
                if (!sameRead(lines)) {
                    System.out.println(""reads are not the same!"");
                    write(lines);
                    System.exit(0);
                }
                if (hasQCerror(lines[0])) {
                    qccnt++;
                    qc.write(alnToFasta(lines[lines.length - 1], lengths[lines.length - 1]) + ""\n"");
                    continue;
                }
                if (hasNoMatch(lines[0])) {
                    nm.write(alnToFasta(lines[lines.length - 1], lengths[lines.length - 1]) + ""\n"");
                    nmcnt++;
                    continue;
                }
                boolean umatch = false;
                for (int i = lines.length - 1; i >= 0; i--) {
                    if (hasUniqueMatch(lines[i])) {
                        um.write(lines[i].substring(0, lines[i].indexOf('\t') + 1));
                        String seq = null;
                        seq = getSeq(lines[i], lengths[i]);
                        lenHisto[seq.length()]++;
                        um.write(seq);
                        um.write(lines[i].substring(lines[i].indexOf('\t', lines[i].indexOf(seq) + 1)));
                        um.write(""\n"");
                        umatch = true;
                        umcnt++;
                        break;
                    }
                }
                if (umatch) {
                    continue;
                }
                boolean mmatch = false;
                for (int i = lines.length - 1; i >= 0; i--) {
                    if (hasMultiMatch(lines[i])) {
                        alnToFasta(lines[i], lengths[i]);
                        mm.write(alnToFasta(lines[i], lengths[i]) + ""\n"");
                        mmatch = true;
                        mmcnt++;
                        break;
                    }
                }
                if (!mmatch) {
                    System.out.println(""Error! No matches?!?!"");
                    write(lines);
                }
            }
        } catch (IOException io) {
            System.out.println(""Failure parsing file."");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
        }
        try {
            sum.write(""total\t"" + total + ""\n"");
            sum.write(""unique\t"" + umcnt + ""\n"");
            sum.write(""multi\t"" + mmcnt + ""\n"");
            sum.write(""none\t"" + nmcnt + ""\n"");
            sum.write(""QC\t"" + qccnt + ""\n"");
            for (int i = 0; i < lenHisto.length; i++) {
                if (lenHisto[i] != 0) {
                    sum.write(i + ""\t"" + lenHisto[i] + ""\n"");
                }
            }
        } catch (IOException io) {
            System.out.println(""Failure writing to files."");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
        }
        System.out.printf(""%n||Total reads |%d|%n||Unique Matches |%d|%n||Multimatches |%d|%n||No Match |%d|%n||Poor quality |%d|%n"", total, umcnt, mmcnt, nmcnt, qccnt);
        try {
            um.close();
            nm.close();
            mm.close();
            sum.close();
            qc.close();
        } catch (IOException io) {
            System.out.println(""Failure closing files."");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
        }
    }
"
902,416525,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
"
3307,3090795,7,"    public void deleteColumn(int column) throws BadElementException {
        float newWidths[] = new float[--columns];
        for (int i = 0; i < column; i++) {
            newWidths[i] = widths[i];
        }
        for (int i = column; i < columns; i++) {
            newWidths[i] = widths[i + 1];
        }
        setWidths(newWidths);
        for (int i = 0; i < columns; i++) {
            newWidths[i] = widths[i];
        }
        widths = newWidths;
        Row row;
        int size = rows.size();
        for (int i = 0; i < size; i++) {
            row = (Row) rows.get(i);
            row.deleteColumn(column);
            rows.set(i, row);
        }
        if (column == columns) {
            curPosition.setLocation(curPosition.x + 1, 0);
        }
    }
"
7964,11351198,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
"
6472,8233624,7,"    public int[] getStateSequence(int[] ob) {
        int l = ob.length;
        int stateCount = stProb.length;
        int[][] top = new int[l][stateCount];
        double[][] d = new double[l][stateCount];
        for (int i = 0; i < stateCount; i++) {
            d[0][i] = stProb[i] * obProb[i][ob[0]];
        }
        for (int t = 1; t < l; t++) {
            for (int i = 0; i < stateCount; i++) {
                double max = -Double.MAX_VALUE;
                int top_state = -1;
                for (int j = 0; j < stateCount; j++) {
                    double v = d[t - 1][j] * transProb[j][i];
                    if (v > max) {
                        max = v;
                        top_state = j;
                    }
                }
                d[t][i] = max * obProb[i][ob[t]];
                top[t][i] = top_state;
            }
        }
        int[] seq = new int[l];
        double max = -Double.MAX_VALUE;
        int maxi = -1;
        for (int i = 0; i < stateCount; i++) {
            double v = d[l - 1][i];
            if (v > max) {
                max = v;
                maxi = i;
            }
        }
        seq[l - 1] = maxi;
        for (int t = l - 2; t >= 0; t--) {
            seq[t] = top[t + 1][seq[t + 1]];
        }
        return seq;
    }
"
3724,3823290,7,"    private final void update_box(ImageConsumer cons, int y, int x, int w, byte buf[]) {
        int si = y * W + x;
        int p = 0;
        x <<= 3;
        y <<= 3;
        int h, s;
        if (scale == 1) {
            s = w * 8;
            for (int n = 0; n < 8; n++) {
                for (int k = 0; k < w; k++) {
                    int m = screen[si++];
                    byte c0 = (byte) (m >>> 8 & 0xF);
                    byte c1 = (byte) (m >>> 12);
                    m &= 0xFF;
                    do buf[p++] = (m & 1) == 0 ? c0 : c1; while ((m >>>= 1) != 0);
                }
                si += (W / 8) - w;
            }
            h = 8;
        } else {
            h = scale << 3;
            s = w * h;
            for (int n = 0; n < 8; n++) {
                for (int k = 0; k < w; k++) {
                    int m = screen[si++];
                    byte c0 = (byte) (m >>> 8 & 0xF);
                    byte c1 = (byte) (m >>> 12);
                    m &= 0xFF;
                    do {
                        buf[p] = buf[p + 1] = buf[p + s] = buf[p + s + 1] = (m & 1) == 0 ? c0 : c1;
                        p += 2;
                    } while ((m >>>= 1) != 0);
                }
                p += s;
                si += (W / 8) - w;
            }
            x *= scale;
            y *= scale;
        }
        cons.setPixels(x, y, s, h, cm, buf, 0, s);
    }
"
12172,18806015,7,"    public double calcMassAlignmentError() {
        int totNrPeaks = 0;
        for (PeakList spectrum : spectra) {
            totNrPeaks += spectrum.size();
        }
        double[] masses = new double[totNrPeaks];
        double[] mzDiffSingle = new double[totNrPeaks];
        double[] mzDiffComb = new double[totNrPeaks];
        int pos = 0;
        int j = 0;
        for (PeakList spectrum : spectra) {
            double[] mz = ((PeakListImpl) spectrum).getMzs(masses, pos);
            pos += spectrum.size();
            for (int i = 1; i < mz.length; i++) {
                mzDiffSingle[j] = mz[i] - mz[i - 1];
                j++;
            }
        }
        for (; j < totNrPeaks; j++) mzDiffSingle[j] = 10000.0;
        Arrays.sort(mzDiffSingle);
        Arrays.sort(masses);
        double lambda = 0;
        int cnt = 0;
        for (int i = 0; i < masses.length - 1; i++) {
            mzDiffComb[i] = masses[i + 1] - masses[i];
            if (mzDiffComb[i] < specAlignMZTol) {
                lambda += mzDiffComb[i];
                cnt++;
            }
        }
        lambda = lambda / cnt;
        if (cnt < 10) {
            throw new IllegalStateException(""Not enough matching peaks between spectra!"");
        }
        double th = -lambda * Math.log(0.01);
        cnt = 0;
        for (int i = 0; mzDiffSingle[i] < th; i++) cnt++;
        if (cnt / spectra.size() > 5) {
            throw new IllegalStateException(""Peaks within same spectrum are too close!"");
        }
        return th;
    }
"
11230,17212102,7,"    private final void deleteRoomAt(int index) {
        for (int i = index; i < events_fill_p; i++) events[i] = events[i + 1];
        events_fill_p--;
    }
"
14254,21872530,7,"    public DependencyInstance parseSentence(DependencyInstance instance) {
        String[] forms = instance.forms;
        FeatureVector[][][] fvs = new FeatureVector[forms.length][forms.length][2];
        double[][][] probs = new double[forms.length][forms.length][2];
        FeatureVector[][][][] nt_fvs = new FeatureVector[forms.length][pipe.types.length][2][2];
        double[][][][] nt_probs = new double[forms.length][pipe.types.length][2][2];
        pipe.fillFeatureVectors(instance, fvs, probs, nt_fvs, nt_probs, params);
        int K = 1;
        Object[][] d = null;
        d = decoder.decodeNonProjective(instance, fvs, probs, nt_fvs, nt_probs, K);
        String[] res = ((String) d[0][1]).split("" "");
        String[] pos = instance.cpostags;
        String[] formsNoRoot = new String[forms.length - 1];
        String[] posNoRoot = new String[formsNoRoot.length];
        String[] labels = new String[formsNoRoot.length];
        int[] heads = new int[formsNoRoot.length];
        for (int j = 0; j < formsNoRoot.length; j++) {
            formsNoRoot[j] = forms[j + 1];
            posNoRoot[j] = pos[j + 1];
            String[] trip = res[j].split(""[\\|:]"");
            labels[j] = pipe.types[Integer.parseInt(trip[2])];
            heads[j] = Integer.parseInt(trip[0]);
        }
        DependencyInstance di = new DependencyInstance(formsNoRoot, posNoRoot, labels, heads);
        return di;
    }
"
11436,17577167,7,"    protected void deleteVertex(int index) {
        Vector3D deleted = v[index];
        for (int i = index; i < v.length - 1; i++) {
            v[i] = v[i + 1];
        }
        v[v.length - 1] = deleted;
        numVertices--;
    }
"
8327,12584459,7,"        public Iterator<E> iterator() {
            return new Iterator<E>() {

                private int currentIndex = -1;

                public boolean hasNext() {
                    return size > 0 && currentIndex < size;
                }

                public E next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    currentIndex++;
                    return (E) elements[currentIndex];
                }

                public void remove() {
                    if (-1 == currentIndex) {
                        throw new IllegalStateException();
                    }
                    for (int i = currentIndex; i < size - 1; i++) {
                        elements[i] = elements[i + 1];
                    }
                    size--;
                }
            };
        }
"
12266,19008074,7,"    protected final void addToken(SynonymToken token) {
        int l = tokens.length - 1;
        for (int i = 0; i < l; i++) tokens[i] = tokens[i + 1];
        tokens[l] = token;
        if (queueSize < tokens.length) queueSize++;
    }
"
15079,23577329,7,"    public void runTasks(float seconds, Object[] runners) {
        start = timer.getTimeInSeconds();
        end = start + seconds;
        currenttasks.clear();
        for (int k = 0; k < runners.length; k++) {
            Task[] tasks = ((TaskRunner) runners[k]).getTasks();
            for (int i = 0; i < tasks.length; i++) {
                Task task = tasks[i];
                if (task != null && task.isUsingManager(this)) {
                    if (task.isCompleted()) {
                        completedTask(task);
                    } else if (task.isPaused()) {
                        task.prepareRun();
                        currenttasks.add(tasks[i]);
                    }
                }
            }
        }
        for (int k = 0; k < runners.length; k++) {
            TaskRunner runner = (TaskRunner) runners[k];
            int tasksearch = tasklimit;
            int reserve = runner.reserveTask();
            while (reserve != -1 && --tasksearch >= 0) {
                if (tasks[tasksearch].isUsingRunner(runner)) {
                    Task task = tasks[tasksearch];
                    tasks[tasksearch] = null;
                    tasklimit--;
                    for (int i = tasksearch; i < tasklimit; i++) {
                        tasks[i] = tasks[i + 1];
                    }
                    task.assign(reserve);
                    task.prepareRun();
                    currenttasks.add(task);
                    reserve = runner.reserveTask();
                } else {
                }
            }
            if (reserve != -1) runner.cancelReserveTask(reserve);
        }
        Iterator it = currenttasks.iterator();
        while (it.hasNext() && timeLeft() > 0) {
            Task task = (Task) it.next();
            task.resume();
        }
        it = currenttasks.iterator();
        while (it.hasNext()) {
            Task task = (Task) it.next();
            task.attemptPause();
        }
    }
"
3889,4097918,7,"    void addLine(String s) {
        if (curRow < text.length - 1) {
            text[++curRow] = s;
        } else {
            for (int i = 0; i < text.length - 1; i++) {
                text[i] = text[i + 1];
            }
            text[text.length - 1] = s;
        }
    }
"
8856,13451846,7,"    private void statistiken() {
        historyswitch++;
        if (historyswitch == 3) {
            if (historycountereinmaldurch == false) {
                geldhistory[historycounter] = (int) getGeld();
                firmenwerthistory[historycounter] = (int) getFirmenwert();
                if (geldhistory[historycounter] == 0) {
                    geldhistory[historycounter] = -1;
                }
                if (firmenwerthistory[historycounter] == 0) {
                    firmenwerthistory[historycounter] = -1;
                }
                historycounter++;
                if (historycounter == Master.OPTIONEN.getMaximumDiagramm()) {
                    historycountereinmaldurch = true;
                }
            } else {
                for (int i = 0; i < Master.OPTIONEN.getMaximumDiagramm() - 1; i++) {
                    geldhistory[i] = geldhistory[i + 1];
                    firmenwerthistory[i] = firmenwerthistory[i + 1];
                }
                geldhistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = (int) getGeld();
                firmenwerthistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = (int) getFirmenwert();
                if (geldhistory[Master.OPTIONEN.getMaximumDiagramm() - 1] == 0) {
                    geldhistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = -1;
                }
                if (firmenwerthistory[Master.OPTIONEN.getMaximumDiagramm() - 1] == 0) {
                    firmenwerthistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = -1;
                }
            }
            historyswitch = 0;
        }
    }
"
9924,14957244,7,"    private void novo_dia(double p, double dias[]) {
        for (int i = 0; i < PERIODO - 1; i++) dias[i] = dias[i + 1];
        dias[PERIODO - 1] = p;
    }
"
6621,8512408,7,"    private CommandLine parseCommandLine(TclObject argv[]) throws ParseException {
        String[] args = new String[argv.length - 1];
        for (int i = 0; i < argv.length - 1; i++) args[i] = argv[i + 1].toString();
        CommandLine cl = (new PosixParser()).parse(this.opts, args);
        return cl;
    }
"
9792,14615632,7,"    public static void main(String[] args) throws Exception {
        File dir = new File(""."");
        TestCompiler tc = new TestCompiler(dir, null, dir);
        tc.addErrorListener(new ConsoleErrorReporter(System.out));
        tc.setForceCompile(true);
        String[] names = tc.compile(args[0]);
        System.out.println(""Compiled "" + names.length + "" sources"");
        for (int i = 0; i < names.length; i++) {
            System.out.println(names[i]);
        }
        int errorCount = tc.getErrorCount();
        if (errorCount > 0) {
            String msg = String.valueOf(errorCount) + "" error"";
            if (errorCount != 1) {
                msg += 's';
            }
            System.out.println(msg);
            return;
        }
        TemplateLoader loader = new TemplateLoader();
        TemplateLoader.Template template = loader.getTemplate(args[0]);
        int length = args.length - 1;
        Object[] params = new Object[length];
        for (int i = 0; i < length; i++) {
            params[i] = args[i + 1];
        }
        System.out.println(""Executing "" + template);
        template.execute(new Context(System.out), params);
    }
"
1662,773930,7,"    public void run() {
        VM_Controller.boot();
        VM_ApplicationClassLoader.setPathProperty();
        ClassLoader cl = new VM_ApplicationClassLoader(VM_SystemClassLoader.getVMClassLoader());
        String[] mainArgs = null;
        INSTRUCTION[] mainCode = null;
        VM_Class cls = null;
        try {
            cls = (VM_Class) cl.loadClass(args[0], true).getVMType();
        } catch (ClassNotFoundException e) {
            VM.sysWrite(e + ""\n"");
            return;
        }
        mainMethod = cls.findMainMethod();
        if (mainMethod == null) {
            VM.sysWrite(cls.getName() + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
            return;
        }
        mainArgs = new String[args.length - 1];
        for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
        mainCode = mainMethod.compile();
        VM_Callbacks.notifyStartup();
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainCode);
    }
"
2861,2235436,7,"    private LinkedList<Datum> calculateBLUEsFromPhenotypes(MarkerPhenotypeAdapter mpa, String datasetName) {
        if (isInteractive()) {
            String msg = ""The data set you have selected does not contain any marker data. Do you want to calculate BLUEs (best linear unbiased estimates) of the phenotypes?"";
            String title = ""Calculate BLUEs"";
            int action = JOptionPane.showConfirmDialog(getParentFrame(), msg, title, JOptionPane.YES_NO_OPTION);
            if (action != JOptionPane.YES_OPTION) return null;
        }
        LinkedList<Datum> theResults = new LinkedList<Datum>();
        LinkedList<Object[]> anovaResults = new LinkedList<Object[]>();
        LinkedList<double[]> blueList = new LinkedList<double[]>();
        ArrayList<ArrayList<Object>> taxaListList = new ArrayList<ArrayList<Object>>();
        int numberOfCovariates = mpa.getNumberOfCovariates();
        int numberOfFactors = mpa.getNumberOfFactors();
        int numberOfPhenotypes = mpa.getNumberOfPhenotypes();
        for (int ph = 0; ph < numberOfPhenotypes; ph++) {
            double[] phenotypeData = mpa.getPhenotypeValues(ph);
            boolean[] missing = mpa.getMissingPhenotypes(ph);
            ArrayList<String[]> factorList = MarkerPhenotypeAdapterUtils.getFactorList(mpa, ph, missing);
            ArrayList<double[]> covariateList = MarkerPhenotypeAdapterUtils.getCovariateList(mpa, ph, missing);
            int[] nonmissingRows = MarkerPhenotypeAdapterUtils.getNonMissingIndex(missing);
            int numberOfObs = nonmissingRows.length;
            double[] y = new double[numberOfObs];
            for (int i = 0; i < numberOfObs; i++) {
                y[i] = phenotypeData[nonmissingRows[i]];
            }
            ArrayList<ModelEffect> modelEffects = new ArrayList<ModelEffect>();
            FactorModelEffect meanEffect = new FactorModelEffect(new int[numberOfObs], false);
            meanEffect.setID(""mean"");
            modelEffects.add(meanEffect);
            Identifier[] alltaxa = mpa.getTaxa(ph);
            Identifier[] taxa = new Identifier[numberOfObs];
            ArrayList<Object> taxaIds = new ArrayList<Object>();
            for (int i = 0; i < numberOfObs; i++) {
                taxa[i] = alltaxa[nonmissingRows[i]];
            }
            int[] taxaLevels = ModelEffectUtils.getIntegerLevels(taxa, taxaIds);
            taxaListList.add(taxaIds);
            FactorModelEffect taxaEffect = new FactorModelEffect(taxaLevels, true, ""Taxa"");
            modelEffects.add(taxaEffect);
            if (numberOfFactors > 0) {
                for (int f = 0; f < numberOfFactors; f++) {
                    String[] afactor = factorList.get(f);
                    String[] factorLabels = new String[numberOfObs];
                    for (int i = 0; i < numberOfObs; i++) factorLabels[i] = afactor[nonmissingRows[i]];
                    FactorModelEffect fme = new FactorModelEffect(ModelEffectUtils.getIntegerLevels(factorLabels), true, mpa.getFactorName(f));
                    modelEffects.add(fme);
                }
            }
            if (numberOfCovariates > 0) {
                for (int c = 0; c < numberOfCovariates; c++) {
                    double[] covar = new double[numberOfObs];
                    double[] covariateData = covariateList.get(c);
                    for (int i = 0; i < numberOfObs; i++) covar[i] = covariateData[nonmissingRows[i]];
                    modelEffects.add(new CovariateModelEffect(covar, mpa.getCovariateName(c)));
                }
            }
            SweepFastLinearModel sflm = new SweepFastLinearModel(modelEffects, y);
            double[] taxaSSdf = sflm.getMarginalSSdf(1);
            double[] modelSSdf = sflm.getFullModelSSdf();
            double[] errorSSdf = sflm.getResidualSSdf();
            double[] beta = sflm.getBeta();
            double F, p;
            F = taxaSSdf[0] / taxaSSdf[1] / errorSSdf[0] * errorSSdf[1];
            try {
                p = LinearModelUtils.Ftest(F, taxaSSdf[1], errorSSdf[1]);
            } catch (Exception e) {
                p = Double.NaN;
            }
            Object[] result = new Object[9];
            result[0] = mpa.getPhenotypeName(ph);
            result[1] = new Double(F);
            result[2] = new Double(p);
            result[3] = new Double(taxaSSdf[1]);
            result[4] = new Double(taxaSSdf[0] / taxaSSdf[1]);
            result[5] = new Double(errorSSdf[1]);
            result[6] = new Double(errorSSdf[0] / errorSSdf[1]);
            result[7] = new Double(modelSSdf[1]);
            result[8] = new Double(modelSSdf[0] / modelSSdf[1]);
            anovaResults.add(result);
            double overallMean = beta[0];
            int nEffects = modelEffects.size();
            int start = 0;
            for (int i = 1; i < nEffects; i++) {
                ModelEffect me = modelEffects.get(i);
                if (me instanceof FactorModelEffect && !me.getID().equals(""Taxa"")) {
                    FactorModelEffect fme = (FactorModelEffect) me;
                    int nLevels = fme.getNumberOfLevels();
                    int nEstimates;
                    if (fme.getRestricted()) {
                        nEstimates = nLevels - 1;
                    } else {
                        nEstimates = nLevels;
                    }
                    double factorMean = 0;
                    for (int j = 0; j < nEstimates; j++) {
                        factorMean += beta[j + start];
                    }
                    factorMean /= nLevels;
                    overallMean += factorMean;
                    start += nEstimates;
                } else {
                    start += me.getNumberOfLevels();
                }
            }
            int n = taxaIds.size();
            double[] blues = new double[n];
            for (int i = 0; i < n - 1; i++) {
                blues[i] = beta[i + 1] + overallMean;
            }
            blues[n - 1] = overallMean;
            blueList.add(blues);
            taxaListList.add(taxaIds);
        }
        String[] anovaColumnLabels = new String[] { ""Trait"", ""F"", ""p"", ""taxaDF"", ""taxaMS"", ""errorDF"", ""errorMS"", ""modelDF"", ""modelMS"" };
        Object[][] table = new Object[anovaResults.size()][];
        anovaResults.toArray(table);
        String datumName = ""Phenotype ANOVA from "" + datasetName;
        StringBuilder datumComments = new StringBuilder(""ANOVA for Phenotypes using GLM\n"");
        datumComments.append(""Data set: "").append(datasetName);
        datumComments.append(""\nmodel: trait = mean + taxa"");
        for (int i = 0; i < mpa.getNumberOfFactors(); i++) {
            datumComments.append("" + "");
            datumComments.append(mpa.getFactorName(i));
        }
        for (int i = 0; i < mpa.getNumberOfCovariates(); i++) {
            datumComments.append("" + "");
            datumComments.append(mpa.getCovariateName(i));
        }
        SimpleTableReport str = new SimpleTableReport(datumName, anovaColumnLabels, table);
        Datum theAnova = new Datum(datumName, str, datumComments.toString());
        theResults.add(theAnova);
        TreeSet<Identifier> taxaSet = new TreeSet<Identifier>();
        for (ArrayList<Object> list : taxaListList) {
            for (Object taxon : list) taxaSet.add((Identifier) taxon);
        }
        HashMap<Identifier, Integer> taxaMap = new HashMap<Identifier, Integer>();
        int count = 0;
        for (Identifier taxon : taxaSet) {
            taxaMap.put(taxon, count++);
        }
        String[] blueColumnLabels = new String[numberOfPhenotypes + 1];
        blueColumnLabels[0] = ""Taxa"";
        for (int i = 0; i < numberOfPhenotypes; i++) {
            blueColumnLabels[i + 1] = mpa.getPhenotypeName(i);
        }
        int nrows = taxaSet.size();
        double[][] blues = new double[nrows][numberOfPhenotypes];
        for (int r = 0; r < nrows; r++) {
            for (int c = 0; c < numberOfPhenotypes; c++) {
                blues[r][c] = Double.NaN;
            }
        }
        LinkedList<Trait> traitList = new LinkedList<Trait>();
        for (int c = 0; c < numberOfPhenotypes; c++) {
            traitList.add(new Trait(mpa.getPhenotypeName(c), false, Trait.TYPE_DATA));
            double[] pheno = blueList.get(c);
            int n = pheno.length;
            ArrayList<Object> taxaList = taxaListList.get(c);
            for (int i = 0; i < n; i++) {
                int ndx = taxaMap.get(taxaList.get(i));
                if (ndx > -1) blues[ndx][c] = pheno[i];
            }
        }
        Identifier[] taxaIds = new Identifier[taxaSet.size()];
        taxaSet.toArray(taxaIds);
        Phenotype thePhenotype = new SimplePhenotype(new SimpleIdGroup(taxaIds), traitList, blues);
        theResults.add(new Datum(""BLUEs_"" + datasetName, thePhenotype, ""BLUEs calculated from "" + datasetName));
        return theResults;
    }
"
12695,19658639,7,"    private static void dualPivotQuicksort(char[] a, int left, int right) {
        int sixth = (right - left + 1) / 6;
        int e1 = left + sixth;
        int e5 = right - sixth;
        int e3 = (left + right) >>> 1;
        int e4 = e3 + sixth;
        int e2 = e3 - sixth;
        char ae1 = a[e1], ae2 = a[e2], ae3 = a[e3], ae4 = a[e4], ae5 = a[e5];
        if (ae1 > ae2) {
            char t = ae1;
            ae1 = ae2;
            ae2 = t;
        }
        if (ae4 > ae5) {
            char t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        if (ae1 > ae3) {
            char t = ae1;
            ae1 = ae3;
            ae3 = t;
        }
        if (ae2 > ae3) {
            char t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae1 > ae4) {
            char t = ae1;
            ae1 = ae4;
            ae4 = t;
        }
        if (ae3 > ae4) {
            char t = ae3;
            ae3 = ae4;
            ae4 = t;
        }
        if (ae2 > ae5) {
            char t = ae2;
            ae2 = ae5;
            ae5 = t;
        }
        if (ae2 > ae3) {
            char t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae4 > ae5) {
            char t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        a[e1] = ae1;
        a[e3] = ae3;
        a[e5] = ae5;
        char pivot1 = ae2;
        a[e2] = a[left];
        char pivot2 = ae4;
        a[e4] = a[right];
        int less = left + 1;
        int great = right - 1;
        boolean pivotsDiffer = (pivot1 != pivot2);
        if (pivotsDiffer) {
            outer: for (int k = less; k <= great; k++) {
                char ak = a[k];
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = a[great];
                        a[great--] = ak;
                    }
                }
            }
        } else {
            for (int k = less; k <= great; k++) {
                char ak = a[k];
                if (ak == pivot1) {
                    continue;
                }
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = pivot1;
                        a[great--] = ak;
                    }
                }
            }
        }
        a[left] = a[less - 1];
        a[less - 1] = pivot1;
        a[right] = a[great + 1];
        a[great + 1] = pivot2;
        doSort(a, left, less - 2);
        doSort(a, great + 2, right);
        if (!pivotsDiffer) {
            return;
        }
        if (less < e1 && great > e5) {
            while (a[less] == pivot1) {
                less++;
            }
            while (a[great] == pivot2) {
                great--;
            }
            outer: for (int k = less; k <= great; k++) {
                char ak = a[k];
                if (ak == pivot2) {
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) {
                        a[k] = a[less];
                        a[less++] = pivot1;
                    } else {
                        a[k] = a[great];
                    }
                    a[great--] = pivot2;
                } else if (ak == pivot1) {
                    a[k] = a[less];
                    a[less++] = pivot1;
                }
            }
        }
        doSort(a, less, great);
    }
"
6076,7696633,7,"    public static String byteToString(byte[] b, boolean compressedBytes) {
        String str = """";
        try {
            if (compressedBytes) {
                for (int i = 0; i < b.length; i += 2) {
                    byte[] b2 = new byte[2];
                    b2[0] = b[i];
                    b2[1] = b[i + 1];
                    int iChar = MTFToolClass.byteToShort(b2);
                    str += (char) iChar;
                }
            } else {
                for (int i = 0; i < b.length; i++) {
                    str += (char) b[i];
                }
            }
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            str = """";
        }
        return str;
    }
"
1053,494899,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
"
7001,9097634,7,"    public static Gsv valueOf(final String... values) {
        Validator.notNull(values, ""GSV sentences"");
        if (values.length == 0) {
            throw new IllegalArgumentException(""GSV sentences must not be empty."");
        }
        String[] parts = values[0].split("","");
        final int totalNumberOfMessages = Integer.parseInt(parts[1]);
        if (totalNumberOfMessages != values.length) {
            throw new NmeaFormatException(String.format(""Not all messages given. Expected %s but got %s: '%s' "", totalNumberOfMessages, values.length, values[0]));
        }
        final int messageNumber = Integer.parseInt(parts[2]);
        if (messageNumber != 1) {
            throw new NmeaFormatException(""Expecting message number 1, but was "" + messageNumber + ""."");
        }
        final int satellitesInView = Integer.parseInt(parts[3]);
        for (int i = 1; i < values.length; ++i) {
            Checksum.check(values[i]);
            parts = values[i].split("","");
            if (totalNumberOfMessages != Integer.parseInt(parts[1])) {
                throw new NmeaFormatException(""Different number of messages."");
            }
            if (Integer.parseInt(parts[2]) != i + 1) {
                throw new NmeaFormatException(""Expecting message number "" + (i + 1) + "", but was "" + messageNumber + ""."");
            }
            if (satellitesInView != Integer.parseInt(parts[3])) {
                throw new NmeaFormatException(""Different number of satellites in view."");
            }
        }
        final List<Info> info = new ArrayList<Info>();
        for (int i = 0; i < values.length; ++i) {
            parts = values[i].split("","");
            for (int j = 4; j < parts.length; j += 4) {
                if (info.size() < satellitesInView) {
                    String[] inf = new String[4];
                    inf[0] = parts[j + 0];
                    inf[1] = parts[j + 1];
                    inf[2] = parts[j + 2];
                    inf[3] = trim(parts[j + 3]);
                    info.add(parseInfo(inf));
                }
            }
        }
        if (info.size() != satellitesInView) {
            throw new NmeaFormatException(""Different satellite infos."");
        }
        return new Gsv(totalNumberOfMessages, satellitesInView, info.toArray(new Info[0]));
    }
"
4546,5236991,7,"        private ArrayList<Face> emitPolygon(Obj parent, Vertex[] v) {
            ArrayList<Face> triangles = new ArrayList<Face>();
            int n = v.length;
            int prev, cur, next;
            int[] vp;
            int count;
            int min_vert;
            int i;
            double dist;
            double min_dist;
            boolean poly_orientation;
            boolean beenHere = false;
            vp = new int[n];
            poly_orientation = this.orientation(v);
            for (i = 0; i < n; i++) vp[i] = i;
            count = n;
            while (count > 3) {
                min_dist = Double.MAX_VALUE;
                min_vert = 0;
                for (cur = 0; cur < count; cur++) {
                    prev = cur - 1;
                    next = cur + 1;
                    if (cur == 0) prev = count - 1; else if (next == count) next = 0;
                    if ((determinant(vp[prev], vp[cur], vp[next], v) == poly_orientation) && no_interior(vp[prev], vp[cur], vp[next], v, vp, count, poly_orientation) && ((dist = distance2(v[vp[prev]].getX(), v[vp[prev]].getY(), v[vp[next]].getX(), v[vp[next]].getY())) < min_dist)) {
                        min_dist = dist;
                        min_vert = cur;
                    }
                }
                if (min_dist == Double.MAX_VALUE) {
                    if (beenHere) return null;
                    poly_orientation = !poly_orientation;
                    beenHere = true;
                } else {
                    beenHere = false;
                    prev = min_vert - 1;
                    next = min_vert + 1;
                    if (min_vert == 0) prev = count - 1; else if (next == count) next = 0;
                    triangles.add(new Face(parent, v[vp[prev]], v[vp[min_vert]], v[vp[next]]));
                    count--;
                    for (i = min_vert; i < count; i++) vp[i] = vp[i + 1];
                }
            }
            triangles.add(new Face(parent, v[vp[0]], v[vp[1]], v[vp[2]]));
            return triangles;
        }
"
5015,5709508,7,"    @Override
    public FloatPlane xGradient() {
        FloatPlane plane = new FloatPlane(getSize());
        float[] src = floatArray();
        float[] dst = plane.floatArray();
        int w = getWidth();
        int h = getHeight();
        for (int y = 0; y < h; y++) {
            int row = y * w;
            int end = row + w - 1;
            for (int x = row; x < end; x++) {
                dst[x] = src[x + 1] - src[x] + 0.5f;
            }
        }
        return plane;
    }
"
11336,17364382,7,"    public void novo_dia(double p, double dias[]) {
        for (int i = 0; i < PERIODO - 1; i++) dias[i] = dias[i + 1];
        dias[PERIODO - 1] = p;
    }
"
4130,4509735,7,"    private void removeObservation(int index) {
        final int N = y.numRows - 1;
        final double d[] = y.data;
        for (int i = index; i < N; i++) {
            d[i] = d[i + 1];
        }
        y.numRows--;
    }
"
12841,19747588,7,"    public int[] getStateSequence(double[][] ob) {
        int l = ob.length;
        int stateCount = stProb.length;
        int[][] top = new int[l][stateCount];
        double[][] d = new double[l][stateCount];
        for (int i = 0; i < stateCount; i++) {
            d[0][i] = stProb[i] * getDensity(i, ob[0]);
        }
        for (int t = 1; t < l; t++) {
            for (int i = 0; i < stateCount; i++) {
                double max = -Double.MAX_VALUE;
                int top_state = -1;
                for (int j = 0; j < stateCount; j++) {
                    double v = d[t - 1][j] * transProb[j][i];
                    if (v > max) {
                        max = v;
                        top_state = j;
                    }
                }
                d[t][i] = max * getDensity(i, ob[t]);
                top[t][i] = top_state;
            }
        }
        int[] seq = new int[l];
        double max = -Double.MAX_VALUE;
        int maxi = -1;
        for (int i = 0; i < stateCount; i++) {
            double v = d[l - 1][i];
            if (v > max) {
                max = v;
                maxi = i;
            }
        }
        seq[l - 1] = maxi;
        for (int t = l - 2; t >= 0; t--) {
            seq[t] = top[t + 1][seq[t + 1]];
        }
        return seq;
    }
"
5422,6181090,7,"    public Deployer(String[] args) throws Exception {
        defaultConnection = false;
        String database = null;
        String user = null;
        String password = null;
        for (int i = 0; i < args.length; ++i) {
            if (args[i] == null) continue;
            boolean moreArgs = (i + 1 < args.length && !args[i + 1].startsWith(""-""));
            if (args[i].equals(""--database"")) {
                if (moreArgs) database = args[i + 1];
            } else if (args[i].equals(""--user"")) {
                if (moreArgs) user = args[i + 1];
            } else if (args[i].equals(""--password"")) {
                if (moreArgs) password = args[i + 1];
            } else continue;
            if (moreArgs) {
                args[i] = args[i + 1] = null;
                ++i;
            } else throw new Exception(""Missing argument for option "" + args[i]);
        }
        if (database == null) throw new Exception(""Option --database must be present"");
        conn = DriverManager.getConnection(""jdbc:firebirdsql:"" + database, user, password);
        conn.setAutoCommit(false);
    }
"
3702,3769505,7,"    public void removePoint() {
        Integer index = datapanel.getPointChosenIndex();
        if (index != null) {
            int newsize = sdata.length - 1;
            int iindex = index.intValue();
            double[] oldsdata = sdata;
            double[] olddata = data;
            double[] tempsdata = new double[newsize];
            double[] tempdata = new double[newsize];
            for (int i = 0; i < newsize; i++) {
                if (i < iindex) {
                    tempsdata[i] = oldsdata[i];
                    tempdata[i] = olddata[i];
                } else {
                    tempsdata[i] = oldsdata[i + 1];
                    tempdata[i] = olddata[i + 1];
                }
            }
            sdata = tempsdata;
            data = tempdata;
            plotData();
        }
    }
"
1310,621550,7,"    public void addRandomRows(int count) {
        Row r;
        for (int i = 0; i < count; i++) {
            r = new Row(ROWS - 1);
            for (int z = 0; z < r.blocks.length; z++) {
                if (Math.abs((int) rand.nextLong() % 6) != 0) {
                    int color = Brick.colors[Math.abs((int) rand.nextLong() % 7)];
                    r.blocks[z] = new Block(color, z, ROWS - 1);
                }
            }
            for (int y = 0; y < ROWS - 1; y++) {
                rows[y] = rows[y + 1];
            }
            rows[ROWS - 1] = r;
        }
        repaint();
    }
"
2769,2062008,7,"        private void mouseDragged(MouseDraggedEvent ev) {
            if (clickPoint == null) return;
            Point pos = ev.getPoint();
            handlePos[selected].x = pos.x;
            double newx = ((double) pos.x - graphBounds.x) / (graphBounds.width - 1.0);
            double newy = ((double) (graphBounds.height - pos.y + graphBounds.y)) / (graphBounds.height - 1.0);
            newy = newy * (maxy - miny) + miny;
            if (newx < 0.0) newx = 0.0;
            if (newx > 1.0) newx = 1.0;
            if (newy < miny) newy = miny;
            if (newy > maxy) newy = maxy;
            y[selected] = 0.001 * ((int) (1000.0 * newy));
            if (selected == 0 || selected == x.length - 1) {
                editModule.calcCoefficients();
                adjustComponents();
                canvas.repaint();
                return;
            }
            x[selected] = 0.001 * ((int) (1000.0 * newx));
            while (x[selected] < x[selected - 1]) {
                double temp = x[selected];
                x[selected] = x[selected - 1];
                x[selected - 1] = temp;
                temp = y[selected];
                y[selected] = y[selected - 1];
                y[selected - 1] = temp;
                Point tempPos = handlePos[selected];
                handlePos[selected] = handlePos[selected - 1];
                handlePos[selected - 1] = tempPos;
                selected--;
            }
            while (x[selected] > x[selected + 1]) {
                double temp = x[selected];
                x[selected] = x[selected + 1];
                x[selected + 1] = temp;
                temp = y[selected];
                y[selected] = y[selected + 1];
                y[selected + 1] = temp;
                Point tempPos = handlePos[selected];
                handlePos[selected] = handlePos[selected + 1];
                handlePos[selected + 1] = tempPos;
                selected++;
            }
            editModule.calcCoefficients();
            adjustComponents();
            canvas.repaint();
        }
"
8059,11816411,7,"    public void loeschen(int index) {
        if (index >= 0 && index < anzahl) {
            for (int i = index; i < anzahl - 1; i++) werte[i] = werte[i + 1];
            anzahl--;
        } else System.out.println(""ungltiger Index"");
    }
"
8035,11714316,7,"    private void getNextChangingElement(int a0, boolean isWhite, int[] ret) {
        int[] pce = this.prevChangingElems;
        int ces = this.changingElemSize;
        int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
        if (isWhite) {
            start &= ~0x1;
        } else {
            start |= 0x1;
        }
        int i = start;
        for (; i < ces; i += 2) {
            int temp = pce[i];
            if (temp > a0) {
                lastChangingElement = i;
                ret[0] = temp;
                break;
            }
        }
        if (i + 1 < ces) {
            ret[1] = pce[i + 1];
        }
    }
"
10646,16275146,7,"    private void init(Context context) {
        g = new AndroidDebugDraw();
        for (int i = 0; i < 100; ++i) {
            this.requestFocus();
        }
        registerExample(new VaryingFriction(this));
        registerExample(new Pyramid(this));
        registerExample(new VaryingRestitution(this));
        nanos = new long[fpsAverageCount];
        long nanosPerFrameGuess = (long) (1000000000.0 / targetFPS);
        nanos[fpsAverageCount - 1] = System.nanoTime();
        for (int i = fpsAverageCount - 2; i >= 0; --i) {
            nanos[i] = nanos[i + 1] - nanosPerFrameGuess;
        }
        nanoStart = System.nanoTime();
    }
"
13342,20470497,7,"    public void visitSwitch(JCSwitch tree) {
        int limit = code.nextreg;
        assert tree.selector.type.tag != CLASS;
        int startpcCrt = genCrt ? code.curPc() : 0;
        Item sel = genExpr(tree.selector, syms.intType);
        List<JCCase> cases = tree.cases;
        if (cases.isEmpty()) {
            sel.load().drop();
            if (genCrt) code.crt.put(TreeInfo.skipParens(tree.selector), CRT_FLOW_CONTROLLER, startpcCrt, code.curPc());
        } else {
            sel.load();
            if (genCrt) code.crt.put(TreeInfo.skipParens(tree.selector), CRT_FLOW_CONTROLLER, startpcCrt, code.curPc());
            Env<GenContext> switchEnv = env.dup(tree, new GenContext());
            switchEnv.info.isSwitch = true;
            int lo = Integer.MAX_VALUE;
            int hi = Integer.MIN_VALUE;
            int nlabels = 0;
            int[] labels = new int[cases.length()];
            int defaultIndex = -1;
            List<JCCase> l = cases;
            for (int i = 0; i < labels.length; i++) {
                if (l.head.pat != null) {
                    int val = ((Number) l.head.pat.type.constValue()).intValue();
                    labels[i] = val;
                    if (val < lo) lo = val;
                    if (hi < val) hi = val;
                    nlabels++;
                } else {
                    assert defaultIndex == -1;
                    defaultIndex = i;
                }
                l = l.tail;
            }
            long table_space_cost = 4 + ((long) hi - lo + 1);
            long table_time_cost = 3;
            long lookup_space_cost = 3 + 2 * (long) nlabels;
            long lookup_time_cost = nlabels;
            int opcode = nlabels > 0 && table_space_cost + 3 * table_time_cost <= lookup_space_cost + 3 * lookup_time_cost ? tableswitch : lookupswitch;
            int startpc = code.curPc();
            code.emitop0(opcode);
            code.align(4);
            int tableBase = code.curPc();
            int[] offsets = null;
            code.emit4(-1);
            if (opcode == tableswitch) {
                code.emit4(lo);
                code.emit4(hi);
                for (long i = lo; i <= hi; i++) {
                    code.emit4(-1);
                }
            } else {
                code.emit4(nlabels);
                for (int i = 0; i < nlabels; i++) {
                    code.emit4(-1);
                    code.emit4(-1);
                }
                offsets = new int[labels.length];
            }
            Code.State stateSwitch = code.state.dup();
            code.markDead();
            l = cases;
            for (int i = 0; i < labels.length; i++) {
                JCCase c = l.head;
                l = l.tail;
                int pc = code.entryPoint(stateSwitch);
                if (i != defaultIndex) {
                    if (opcode == tableswitch) {
                        code.put4(tableBase + 4 * (labels[i] - lo + 3), pc - startpc);
                    } else {
                        offsets[i] = pc - startpc;
                    }
                } else {
                    code.put4(tableBase, pc - startpc);
                }
                genStats(c.stats, switchEnv, CRT_FLOW_TARGET);
            }
            code.resolve(switchEnv.info.exit);
            if (code.get4(tableBase) == -1) {
                code.put4(tableBase, code.entryPoint(stateSwitch) - startpc);
            }
            if (opcode == tableswitch) {
                int defaultOffset = code.get4(tableBase);
                for (long i = lo; i <= hi; i++) {
                    int t = (int) (tableBase + 4 * (i - lo + 3));
                    if (code.get4(t) == -1) code.put4(t, defaultOffset);
                }
            } else {
                if (defaultIndex >= 0) for (int i = defaultIndex; i < labels.length - 1; i++) {
                    labels[i] = labels[i + 1];
                    offsets[i] = offsets[i + 1];
                }
                if (nlabels > 0) qsort2(labels, offsets, 0, nlabels - 1);
                for (int i = 0; i < nlabels; i++) {
                    int caseidx = tableBase + 8 * (i + 1);
                    code.put4(caseidx, labels[i]);
                    code.put4(caseidx + 4, offsets[i]);
                }
            }
        }
        code.endScopes(limit);
    }
"
8746,13330595,7,"    void removeGroupedInstance(String groupName, MudObject instance) {
        MudObject[] instances = (MudObject[]) groupedInstances.get(groupName);
        if (instances != null) {
            if (instances.length == 1) {
                if (instances[0].equals(instance)) {
                    groupedInstances.remove(groupName);
                }
            } else {
                int removalIndex = -1;
                for (int i = 0; i < instances.length; i++) {
                    if (instances[i].equals(instance)) {
                        removalIndex = i;
                        break;
                    }
                }
                if (removalIndex >= 0) {
                    MudObject[] trimmedInstances = new MudObject[instances.length - 1];
                    for (int i = 0; i < removalIndex; i++) {
                        trimmedInstances[i] = instances[i];
                    }
                    for (int i = removalIndex; i < trimmedInstances.length; i++) {
                        trimmedInstances[i] = instances[i + 1];
                    }
                    groupedInstances.put(groupName, trimmedInstances);
                }
            }
        }
    }
"
10820,16579951,7,"    private int procedure_A(int x0, int c, BigInteger[] pq, int size) {
        while (x0 < 0 || x0 > 65536) {
            x0 = init_random.nextInt() / 32768;
        }
        while ((c < 0 || c > 65536) || (c / 2 == 0)) {
            c = init_random.nextInt() / 32768 + 1;
        }
        BigInteger C = new BigInteger(Integer.toString(c));
        BigInteger constA16 = new BigInteger(""19381"");
        BigInteger[] y = new BigInteger[1];
        y[0] = new BigInteger(Integer.toString(x0));
        int[] t = new int[1];
        t[0] = size;
        int s = 0;
        for (int i = 0; t[i] >= 17; i++) {
            int tmp_t[] = new int[t.length + 1];
            System.arraycopy(t, 0, tmp_t, 0, t.length);
            t = new int[tmp_t.length];
            System.arraycopy(tmp_t, 0, t, 0, tmp_t.length);
            t[i + 1] = t[i] / 2;
            s = i + 1;
        }
        BigInteger p[] = new BigInteger[s + 1];
        p[s] = new BigInteger(""8003"", 16);
        int m = s - 1;
        for (int i = 0; i < s; i++) {
            int rm = t[m] / 16;
            step6: for (; ; ) {
                BigInteger tmp_y[] = new BigInteger[y.length];
                System.arraycopy(y, 0, tmp_y, 0, y.length);
                y = new BigInteger[rm + 1];
                System.arraycopy(tmp_y, 0, y, 0, tmp_y.length);
                for (int j = 0; j < rm; j++) {
                    y[j + 1] = (y[j].multiply(constA16).add(C)).mod(TWO.pow(16));
                }
                BigInteger Ym = new BigInteger(""0"");
                for (int j = 0; j < rm; j++) {
                    Ym = Ym.add(y[j].multiply(TWO.pow(16 * j)));
                }
                y[0] = y[rm];
                BigInteger N = TWO.pow(t[m] - 1).divide(p[m + 1]).add((TWO.pow(t[m] - 1).multiply(Ym)).divide(p[m + 1].multiply(TWO.pow(16 * rm))));
                if (N.mod(TWO).compareTo(ONE) == 0) {
                    N = N.add(ONE);
                }
                int k = 0;
                step11: for (; ; ) {
                    p[m] = p[m + 1].multiply(N.add(BigInteger.valueOf(k))).add(ONE);
                    if (p[m].compareTo(TWO.pow(t[m])) == 1) {
                        continue step6;
                    }
                    if ((TWO.modPow(p[m + 1].multiply(N.add(BigInteger.valueOf(k))), p[m]).compareTo(ONE) == 0) && (TWO.modPow(N.add(BigInteger.valueOf(k)), p[m]).compareTo(ONE) != 0)) {
                        m -= 1;
                        break;
                    } else {
                        k += 2;
                        continue step11;
                    }
                }
                if (m >= 0) {
                    break;
                } else {
                    pq[0] = p[0];
                    pq[1] = p[1];
                    return y[0].intValue();
                }
            }
        }
        return y[0].intValue();
    }
"
12966,19914231,7,"    public void removeChild(String name, String value) {
        boolean found = false;
        for (int i = 0; i < values.length; i++) {
            if (!found) {
                if (values[i].getId().equals(name)) {
                    if (values[i].get().equals(value)) {
                        values[i] = null;
                        found = true;
                        numValidChildren--;
                    }
                }
            }
            if (i < (values.length - 1)) values[i] = values[i + 1];
        }
        if (found) values[values.length - 1] = null;
    }
"
3613,3500209,7,"    private static String[] processHeader(int numberOfColumns, String[] parsedline, String filename) {
        if (parsedline[0].equalsIgnoreCase(""<Header"")) {
            String headername = parsedline[1].split(""[=>\\s]"")[1];
            if (!parsedline[1].contains(""name="") || headername.length() == 0) {
                StringBuilder msg = new StringBuilder(""Error in "");
                msg.append(filename);
                msg.append("": Improperly formatted <Header name=> line."");
                throw new IllegalArgumentException(msg.toString());
            }
            int finalBracketPosition = 0;
            while (!parsedline[finalBracketPosition].contains("">"")) finalBracketPosition++;
            if (numberOfColumns == 0) numberOfColumns = parsedline.length - finalBracketPosition - 1; else if (numberOfColumns != parsedline.length - finalBracketPosition - 1) {
                StringBuilder msg = new StringBuilder(""Error in "");
                msg.append(filename);
                msg.append("": The number of "");
                msg.append(parsedline[0]).append("" "").append(parsedline[1]);
                msg.append("" columns does not match the number of columns in previous header rows"");
                throw new IllegalArgumentException(msg.toString());
            }
            String[] contents = new String[numberOfColumns + 1];
            contents[0] = headername;
            for (int i = 0; i < numberOfColumns; i++) {
                contents[i + 1] = parsedline[i + finalBracketPosition + 1];
            }
            return contents;
        } else {
            if (numberOfColumns == 0) numberOfColumns = parsedline.length - 1; else if (numberOfColumns != parsedline.length - 1) {
                StringBuilder msg = new StringBuilder(""Error in "");
                msg.append(filename);
                msg.append("": The number of "");
                msg.append(parsedline[0]);
                msg.append("" columns does not match the number of columns in previous header rows"");
                throw new IllegalArgumentException(msg.toString());
            }
            String[] contents = new String[numberOfColumns];
            for (int i = 0; i < numberOfColumns; i++) {
                contents[i] = parsedline[i + 1];
            }
            return contents;
        }
    }
"
3184,2748906,7,"    private void _mindex() {
        int k = pop();
        int e = stack[stackIndex - k];
        for (int i = stackIndex - k; i < stackIndex - 1; i++) {
            stack[i] = stack[i + 1];
        }
        stack[stackIndex - 1] = e;
    }
"
7598,10407212,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = null;
        } else items[0] = null;
        current_item--;
    }
"
2943,2331294,7,"    public void deleteBranch(int index) {
        branch[index] = null;
        for (int i = index; i < 2; i++) {
            branch[i] = branch[i + 1];
        }
    }
"
5862,7364950,7,"    private void sinft(float z[], int n, int isign) {
        double theta, wi = 0.0, wpi, wpr, wr = 1.0, wtemp;
        float a[], sum, y1, y2;
        int j;
        int n2 = n + 2;
        a = new float[n + 1];
        for (j = 1; j <= n; j++) {
            a[j] = z[j - 1];
        }
        theta = PI / n;
        wtemp = Math.sin(0.5 * theta);
        wpr = -2.0 * wtemp * wtemp;
        wpi = Math.sin(theta);
        a[1] = 0.0f;
        for (j = 2; j <= (n >> 1) + 1; j++) {
            wr = (wtemp = wr) * wpr - wi * wpi + wr;
            wi = wi * wpr + wtemp * wpi + wi;
            y1 = (float) (wi * (a[j] + a[n2 - j]));
            y2 = (float) (0.5 * (a[j] - a[n2 - j]));
            a[j] = y1 + y2;
            a[n2 - j] = y1 - y2;
        }
        realft(a, n, 1);
        a[1] *= 0.5;
        sum = a[2] = 0.0f;
        for (j = 1; j <= n - 1; j += 2) {
            sum += a[j];
            a[j] = a[j + 1];
            a[j + 1] = sum;
        }
        if (isign == 1) {
            for (j = 1; j <= n; j++) {
                z[j - 1] = a[j];
            }
        } else if (isign == -1) {
            for (j = 1; j <= n; j++) {
                z[j - 1] = (float) 2.0 * a[j] / n;
            }
        }
        z[n] = 0.0f;
        a = null;
    }
"
7713,10534297,7,"    public int[] createSamples(byte[] samples) {
        int[] sampleInt = new int[samples.length / 4];
        byte[] temp = new byte[4];
        int j = 0;
        for (int i = 0; i < samples.length; i += 4) {
            temp[0] = samples[i];
            temp[1] = samples[i + 1];
            temp[2] = samples[i + 2];
            temp[3] = samples[i + 3];
            sampleInt[j] = TypeConverter.byteArrayToInt(temp);
            j++;
        }
        return sampleInt;
    }
"
5706,6845354,7,"    public void leftShift(int from, int to) {
        structure = null;
        Path first = genes[from];
        for (int i = from; i < to; ++i) {
            genes[i] = genes[i + 1];
        }
        genes[to] = first;
    }
"
5090,5828016,7,"    private void updateN_M(int[] n_M, DiscreteEstimator de) {
        int n = n_M.length;
        int[] tmp = new int[n];
        tmp[n - 1] = (int) de.getSumOfCounts();
        n_M[n - 1] += tmp[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            tmp[i] = tmp[i + 1] - (int) de.getCount(i + 1);
            n_M[i] += tmp[i];
        }
    }
"
13015,19954473,7,"    public static void bsw32(byte[] ary, int offset) {
        byte t = ary[offset];
        ary[offset] = ary[offset + 3];
        ary[offset + 3] = t;
        t = ary[offset + 1];
        ary[offset + 1] = ary[offset + 2];
        ary[offset + 2] = t;
    }
"
6486,8257384,7,"        void convertFromABGRToRGBA() {
            int i;
            if (imageDataType == ImageComponentRetained.ImageDataType.TYPE_BYTE_ARRAY) {
                byte[] srcBuffer, dstBuffer;
                srcBuffer = getAsByteArray();
                if (dataIsByRef) {
                    dstBuffer = new byte[length];
                    for (i = 0; i < length; i += 4) {
                        dstBuffer[i] = srcBuffer[i + 3];
                        dstBuffer[i + 1] = srcBuffer[i + 2];
                        dstBuffer[i + 2] = srcBuffer[i + 1];
                        dstBuffer[i + 3] = srcBuffer[i];
                    }
                    data = dstBuffer;
                    dataIsByRef = false;
                } else {
                    byte a, b;
                    for (i = 0; i < length; i += 4) {
                        a = srcBuffer[i];
                        b = srcBuffer[i + 1];
                        srcBuffer[i] = srcBuffer[i + 3];
                        srcBuffer[i + 1] = srcBuffer[i + 2];
                        srcBuffer[i + 2] = b;
                        srcBuffer[i + 3] = a;
                    }
                }
            } else if (imageDataType == ImageComponentRetained.ImageDataType.TYPE_BYTE_BUFFER) {
                assert dataIsByRef;
                ByteBuffer srcBuffer, dstBuffer;
                srcBuffer = getAsByteBuffer();
                srcBuffer.rewind();
                ByteOrder order = ByteOrder.nativeOrder();
                dstBuffer = ByteBuffer.allocateDirect(length).order(order);
                dstBuffer.rewind();
                for (i = 0; i < length; i += 4) {
                    dstBuffer.put(i, srcBuffer.get(i + 3));
                    dstBuffer.put(i + 1, srcBuffer.get(i + 2));
                    dstBuffer.put(i + 2, srcBuffer.get(i + 1));
                    dstBuffer.put(i + 3, srcBuffer.get(i));
                }
                dataIsByRef = false;
            }
        }
"
12369,19170235,7,"    public void run() {
        try {
            Socket.setSocketImplFactory(new SocketImplFactory() {

                public SocketImpl createSocketImpl() {
                    return new JikesRVMSocketImpl();
                }
            });
            ServerSocket.setSocketFactory(new SocketImplFactory() {

                public SocketImpl createSocketImpl() {
                    return new JikesRVMSocketImpl();
                }
            });
            DatagramSocket.setDatagramSocketImplFactory(new DatagramSocketImplFactory() {

                public DatagramSocketImpl createDatagramSocketImpl() {
                    throw new VM_UnimplementedError(""Need to implement JikesRVMDatagramSocketImpl"");
                }
            });
        } catch (java.io.IOException e) {
            VM.sysWrite(""trouble setting socket impl factories"");
        }
        VM_Controller.boot();
        ClassLoader cl = VM_ClassLoader.getApplicationClassLoader();
        setContextClassLoader(cl);
        VM_Class cls = null;
        try {
            VM_Atom mainAtom = VM_Atom.findOrCreateUnicodeAtom(args[0].replace('.', '/'));
            VM_TypeReference mainClass = VM_TypeReference.findOrCreate(cl, mainAtom.descriptorFromClassName());
            cls = mainClass.resolve().asClass();
            cls.resolve();
            cls.instantiate();
            cls.initialize();
        } catch (ClassNotFoundException e) {
            VM.sysWrite(e + ""\n"");
            return;
        }
        mainMethod = cls.findMainMethod();
        if (mainMethod == null) {
            VM.sysWrite(cls + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
            return;
        }
        String[] mainArgs = new String[args.length - 1];
        for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
        mainMethod.compile();
        VM_Callbacks.notifyStartup();
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainMethod.getCurrentCompiledMethod().getInstructions());
    }
"
14639,22544014,7,"    public void deleteValue(long value) throws InvalidValueException {
        int index = findValue(value);
        for (int i = index; i < numElements - 1; i++) {
            array[i] = array[i + 1];
        }
        numElements--;
    }
"
14417,22100520,7,"    private void cycle() {
        for (int i = 0; i < DEPTH - 1; i++) {
            edits[i] = edits[i + 1];
            editTypes[i] = editTypes[i + 1];
        }
        currentEdit = DEPTH - 1;
    }
"
99,40613,7,"    public boolean delete(long value) {
        int j;
        for (j = 0; j < nElems; j++) if (value == a[j]) break;
        if (j == nElems) return false; else {
            for (int k = j; k < nElems; k++) a[k] = a[k + 1];
            nElems--;
            return true;
        }
    }
"
5687,6795987,7,"    public MultipleGradientPaintContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform t, RenderingHints hints, float[] fractions, Color[] colors, MultipleGradientPaint.CycleMethodEnum cycleMethod, MultipleGradientPaint.ColorSpaceEnum colorSpace) throws NoninvertibleTransformException {
        boolean fixFirst = false;
        boolean fixLast = false;
        int len = fractions.length;
        if (fractions[0] != 0f) {
            fixFirst = true;
            len++;
        }
        if (fractions[fractions.length - 1] != 1f) {
            fixLast = true;
            len++;
        }
        for (int i = 0; i < fractions.length - 1; i++) if (fractions[i] == fractions[i + 1]) len--;
        this.fractions = new float[len];
        Color[] loColors = new Color[len - 1];
        Color[] hiColors = new Color[len - 1];
        normalizedIntervals = new float[len - 1];
        gradientUnderflow = colors[0].getRGB();
        gradientOverflow = colors[colors.length - 1].getRGB();
        int idx = 0;
        if (fixFirst) {
            this.fractions[0] = 0;
            loColors[0] = colors[0];
            hiColors[0] = colors[0];
            normalizedIntervals[0] = fractions[0];
            idx++;
        }
        for (int i = 0; i < fractions.length - 1; i++) {
            if (fractions[i] == fractions[i + 1]) {
                if (!colors[i].equals(colors[i + 1])) {
                    hasDiscontinuity = true;
                }
                continue;
            }
            this.fractions[idx] = fractions[i];
            loColors[idx] = colors[i];
            hiColors[idx] = colors[i + 1];
            normalizedIntervals[idx] = fractions[i + 1] - fractions[i];
            idx++;
        }
        this.fractions[idx] = fractions[fractions.length - 1];
        if (fixLast) {
            loColors[idx] = hiColors[idx] = colors[colors.length - 1];
            normalizedIntervals[idx] = 1 - fractions[fractions.length - 1];
            idx++;
            this.fractions[idx] = 1;
        }
        AffineTransform tInv = t.createInverse();
        double m[] = new double[6];
        tInv.getMatrix(m);
        a00 = (float) m[0];
        a10 = (float) m[1];
        a01 = (float) m[2];
        a11 = (float) m[3];
        a02 = (float) m[4];
        a12 = (float) m[5];
        this.cycleMethod = cycleMethod;
        this.colorSpace = colorSpace;
        if (cm.getColorSpace() == lrgbmodel_A.getColorSpace()) dataModel = lrgbmodel_A; else if (cm.getColorSpace() == srgbmodel_A.getColorSpace()) dataModel = srgbmodel_A; else throw new IllegalArgumentException(""Unsupported ColorSpace for interpolation"");
        calculateGradientFractions(loColors, hiColors);
        model = GraphicsUtil.coerceColorModel(dataModel, cm.isAlphaPremultiplied());
    }
"
14049,21554477,7,"    private void performRowSwap() {
        for (int row = 0; row < variables.length - 3; row += 3) {
            IntVar[] temp = variables[row];
            variables[row] = variables[row + 2];
            variables[row + 2] = temp;
        }
    }
"
12006,18547061,7,"    private static void CloseSocket() {
        int sockNum, i;
        ECBClass tmpECB = ECBList;
        ECBClass tmp2ECB = ECBList;
        sockNum = swapByte(CPU_Regs.reg_edx.word());
        if (!sockInUse(sockNum)) return;
        for (i = 0; i < socketCount - 1; i++) {
            if (opensockets[i] == sockNum) {
                for (int j = i; j < SOCKETTABLESIZE - 1; j++) opensockets[j] = opensockets[j + 1];
                break;
            }
        }
        --socketCount;
        while (tmpECB != null) {
            tmp2ECB = tmpECB.nextECB;
            if (tmpECB.getSocket() == sockNum) {
                tmpECB.setCompletionFlag(COMP_CANCELLED);
                tmpECB.setInUseFlag(USEFLAG_AVAILABLE);
                tmpECB.close();
            }
            tmpECB = tmp2ECB;
        }
    }
"
290,100258,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
4754,5475040,7,"    public void reverseRGB(final byte[] image) {
        byte swap;
        for (int i = 0; i < image.length; i += RGB_CHANNELS) {
            swap = image[i];
            image[i] = image[i + 2];
            image[i + 2] = swap;
        }
    }
"
6693,8626755,7,"    private static byte[] encodeString(String s, boolean use_iso) throws UnsupportedEncodingException, IOException {
        if (use_iso) return s.getBytes(CHAR_ENCODING_ISO); else {
            byte bytes[] = s.getBytes(CHAR_ENCODING_UTF_16);
            if (((0xff & bytes[0]) == 0xFE) && ((0xff & bytes[1]) == 0xFF)) {
                for (int i = 0; i < bytes.length; i += 2) {
                    byte temp = bytes[i];
                    bytes[i] = bytes[i + 1];
                    bytes[i + 1] = temp;
                }
            }
            return bytes;
        }
    }
"
15152,23654567,7,"    public int[] label(SparseVector[] x) {
        double[][][] scores = scores(x);
        double[][] gamma = new double[x.length][yAlphabet.size()];
        int[][] back = new int[x.length][yAlphabet.size()];
        for (int y = 0; y < yAlphabet.size(); y++) {
            gamma[0][y] = scores[0][0][y];
        }
        for (int t = 1; t < x.length; t++) {
            for (int yt = 0; yt < yAlphabet.size(); yt++) {
                gamma[t][yt] = Double.NEGATIVE_INFINITY;
                for (int ytm1 = 0; ytm1 < yAlphabet.size(); ytm1++) {
                    if (gamma[t][yt] < gamma[t - 1][ytm1] + scores[t][ytm1][yt]) {
                        back[t][yt] = ytm1;
                        gamma[t][yt] = gamma[t - 1][ytm1] + scores[t][ytm1][yt];
                    }
                }
            }
        }
        int[] tags = new int[x.length];
        for (int y = 0; y < yAlphabet.size(); y++) {
            if (gamma[x.length - 1][tags[x.length - 1]] < gamma[x.length - 1][y]) {
                tags[x.length - 1] = y;
            }
        }
        for (int t = x.length - 2; t >= 0; t--) {
            tags[t] = back[t + 1][tags[t + 1]];
        }
        return tags;
    }
"
11930,18463334,7,"    public Node removeChild(int n) {
        int numChildren = getChildCount();
        if (n >= numChildren) {
            throw new IllegalArgumentException(""Nonexistent child"");
        }
        Node[] newChild = new Node[numChildren - 1];
        for (int i = 0; i < n; i++) {
            newChild[i] = child[i];
        }
        for (int i = n; i < numChildren - 1; i++) {
            newChild[i] = child[i + 1];
        }
        Node removed = child[n];
        removed.setParent(null);
        child = newChild;
        return removed;
    }
"
4665,5332053,7,"    protected static final void determineThresholdsG(int i, int j, double[][] in0, double[][] inG, double[][] in2, double[] ave0, double[] Gave, double[] ave2, int[] ind) {
        for (int k = 0; k < ind.length; k++) {
            switch(ind[k]) {
                case 0:
                    Gave[0] = 1. / 2. * (inG[i][j] + inG[i - 2][j]);
                    ave2[0] = in2[i - 1][j];
                    ave0[0] = 1. / 4. * (in0[i - 2][j - 1] + in0[i - 2][j + 1] + in0[i][j - 1] + in0[i][j + 1]);
                    break;
                case 1:
                    Gave[1] = 1. / 2. * (inG[i][j] + inG[i][j + 2]);
                    ave0[1] = in0[i][j + 1];
                    ave2[1] = 1. / 4. * (in2[i - 1][j] + in2[i + 1][j] + in2[i - 1][j + 2] + in2[i + 1][j + 2]);
                    break;
                case 2:
                    Gave[2] = 1. / 2. * (inG[i][j] + inG[i + 2][j]);
                    ave2[2] = in2[i + 1][j];
                    ave0[2] = 1. / 4. * (in0[i][j - 1] + in0[i][j + 1] + in0[i + 2][j - 1] + in0[i + 2][j + 1]);
                    break;
                case 3:
                    Gave[3] = 1. / 2. * (inG[i][j] + inG[i][j - 2]);
                    ave0[3] = in0[i][j - 1];
                    ave2[3] = 1. / 4. * (in2[i - 1][j - 2] + in2[i - 1][j] + in2[i + 1][j - 2] + in2[i + 1][j]);
                    break;
                case 4:
                    ave0[4] = 1. / 2. * (in0[i - 2][j + 1] + in0[i][j + 1]);
                    ave2[4] = 1. / 2. * (in2[i - 1][j] + in2[i - 1][j + 2]);
                    Gave[4] = inG[i - 1][j + 1];
                    break;
                case 5:
                    ave0[5] = 1. / 2. * (in0[i][j + 1] + in0[i + 2][j + 1]);
                    ave2[5] = 1. / 2. * (in2[i + 1][j] + in2[i + 1][j + 2]);
                    Gave[5] = inG[i + 1][j + 1];
                    break;
                case 6:
                    ave0[6] = 1. / 2. * (in0[i][j - 1] + in0[i - 2][j - 1]);
                    ave2[6] = 1. / 2. * (in2[i - 1][j - 2] + in2[i - 1][j]);
                    Gave[6] = inG[i - 1][j - 1];
                    break;
                case 7:
                    ave0[7] = 1. / 2. * (in0[i][j - 1] + in0[i + 2][j - 1]);
                    ave2[7] = 1. / 2. * (in2[i + 1][j - 2] + in2[i + 1][j]);
                    Gave[7] = inG[i + 1][j - 1];
                    break;
            }
        }
    }
"
511,215863,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
8878,13491945,7,"    public void deleteSympthom(int sympthomIndex) {
        for (int i = sympthomIndex; i < names.length - 1; i++) {
            names[i] = names[i + 1];
        }
        names[names.length - 1] = """";
        values.remove(sympthomIndex);
        values.add(new Vector<String>());
        fireModifiedListeners();
    }
"
566,245876,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
12746,19673242,7,"    public void visitSwitch(JCSwitch tree) {
        int limit = code.nextreg;
        assert tree.selector.type.tag != CLASS;
        int startpcCrt = genCrt ? code.curPc() : 0;
        Item sel = genExpr(tree.selector, syms.intType);
        List<JCCase> cases = tree.cases;
        if (cases.isEmpty()) {
            sel.load().drop();
            if (genCrt) code.crt.put(TreeInfo.skipParens(tree.selector), CRT_FLOW_CONTROLLER, startpcCrt, code.curPc());
        } else {
            sel.load();
            if (genCrt) code.crt.put(TreeInfo.skipParens(tree.selector), CRT_FLOW_CONTROLLER, startpcCrt, code.curPc());
            Env<GenContext> switchEnv = env.dup(tree, new GenContext());
            switchEnv.info.isSwitch = true;
            int lo = Integer.MAX_VALUE;
            int hi = Integer.MIN_VALUE;
            int nlabels = 0;
            int[] labels = new int[cases.length()];
            int defaultIndex = -1;
            List<JCCase> l = cases;
            for (int i = 0; i < labels.length; i++) {
                if (l.head.pat != null) {
                    int val = ((Number) l.head.pat.type.constValue()).intValue();
                    labels[i] = val;
                    if (val < lo) lo = val;
                    if (hi < val) hi = val;
                    nlabels++;
                } else {
                    assert defaultIndex == -1;
                    defaultIndex = i;
                }
                l = l.tail;
            }
            long table_space_cost = 4 + ((long) hi - lo + 1);
            long table_time_cost = 3;
            long lookup_space_cost = 3 + 2 * (long) nlabels;
            long lookup_time_cost = nlabels;
            int opcode = nlabels > 0 && table_space_cost + 3 * table_time_cost <= lookup_space_cost + 3 * lookup_time_cost ? tableswitch : lookupswitch;
            int startpc = code.curPc();
            code.emitop0(opcode);
            code.align(4);
            int tableBase = code.curPc();
            int[] offsets = null;
            code.emit4(-1);
            if (opcode == tableswitch) {
                code.emit4(lo);
                code.emit4(hi);
                for (long i = lo; i <= hi; i++) {
                    code.emit4(-1);
                }
            } else {
                code.emit4(nlabels);
                for (int i = 0; i < nlabels; i++) {
                    code.emit4(-1);
                    code.emit4(-1);
                }
                offsets = new int[labels.length];
            }
            Code.State stateSwitch = code.state.dup();
            code.markDead();
            l = cases;
            for (int i = 0; i < labels.length; i++) {
                JCCase c = l.head;
                l = l.tail;
                int pc = code.entryPoint(stateSwitch);
                if (i != defaultIndex) {
                    if (opcode == tableswitch) {
                        code.put4(tableBase + 4 * (labels[i] - lo + 3), pc - startpc);
                    } else {
                        offsets[i] = pc - startpc;
                    }
                } else {
                    code.put4(tableBase, pc - startpc);
                }
                genStats(c.stats, switchEnv, CRT_FLOW_TARGET);
            }
            code.resolve(switchEnv.info.exit);
            if (code.get4(tableBase) == -1) {
                code.put4(tableBase, code.entryPoint(stateSwitch) - startpc);
            }
            if (opcode == tableswitch) {
                int defaultOffset = code.get4(tableBase);
                for (long i = lo; i <= hi; i++) {
                    int t = (int) (tableBase + 4 * (i - lo + 3));
                    if (code.get4(t) == -1) code.put4(t, defaultOffset);
                }
            } else {
                if (defaultIndex >= 0) for (int i = defaultIndex; i < labels.length - 1; i++) {
                    labels[i] = labels[i + 1];
                    offsets[i] = offsets[i + 1];
                }
                if (nlabels > 0) qsort2(labels, offsets, 0, nlabels - 1);
                for (int i = 0; i < nlabels; i++) {
                    int caseidx = tableBase + 8 * (i + 1);
                    code.put4(caseidx, labels[i]);
                    code.put4(caseidx + 4, offsets[i]);
                }
            }
        }
        code.endScopes(limit);
    }
"
6194,7785431,7,"    private void _swapInt() {
        byte i = event[index];
        sevent[index] = event[index + 3];
        sevent[index + 3] = i;
        i = event[index + 1];
        sevent[index + 1] = event[index + 2];
        sevent[index + 2] = i;
        index += 4;
    }
"
11646,17880003,7,"        public void removeFilter(Filter filter) {
            int n = 0;
            for (; n < filters.length && filters[n] != filter; n++) ;
            if (n != filters.length) {
                filtersPanel.remove(filters[n]);
                for (; n < filters.length - 1; n++) filters[n] = filters[n + 1];
            }
        }
"
13812,21122719,7,"    public static BigInteger encrypt(FHEParams fheparams, GHKeyGen key, int b) {
        int i, num = 1;
        int[] bit = new int[1];
        bit[0] = b;
        long n = 1 << (fheparams.logn);
        double p = ((double) fheparams.noise) / n;
        if (p > 0.5) p = 0.5;
        BigInteger[] vals = evalRandPoly(num, n, p, key.root, key.det);
        BigInteger[] out = new BigInteger[num];
        for (i = 0; i < num; i++) {
            out[i] = vals[i + 1];
        }
        for (i = 0; i < num; i++) {
            out[i] = out[i].shiftLeft(1);
            out[i] = out[i].add(new BigInteger(Integer.toString(bit[i])));
            if (out[i].compareTo(key.det) >= 0) out[i] = out[i].subtract(key.det);
        }
        return out[0];
    }
"
7207,9470469,7,"    private int testOTP(String msg, String[] challenge) {
        String[] lines = Utilities.split(msg, ""\r\n"");
        for (int i = 0; i < lines.length; i++) {
            String[] t = Utilities.split(lines[i], "" "");
            for (int k = 1; k < t.length; k++) {
                try {
                    if (Pattern.matches(""[0-9]+"", t[k])) {
                        challenge[0] = t[k];
                        challenge[1] = t[k + 1];
                        if (lines[i].indexOf(""md4"") != -1) return 4; else return 5;
                    }
                } catch (Exception e) {
                }
            }
        }
        return -1;
    }
"
9049,13630878,7,"    private int[] doAbsorbingRandowWalk(final Matrix mP, int highest) {
        final int size = mP.numRows();
        final int[] ranking = new int[size];
        ranking[0] = highest;
        final int[] map = new int[size];
        for (int i = 0; i < highest; ++i) map[i] = i;
        for (int i = highest; i < size - 1; ++i) map[i] = i + 1;
        for (int absorbed = 1; absorbed < size; ++absorbed) {
            System.out.println(""absorbed "" + absorbed);
            final int sizeOfQ = size - absorbed;
            final Matrix mIminusQ = new DenseMatrix(sizeOfQ, sizeOfQ);
            for (int i = 0; i < sizeOfQ; ++i) for (int j = 0; j < sizeOfQ; ++j) mIminusQ.set(i, j, (i == j ? 1.0 : 0.0) - mP.get(map[i], map[j]));
            final Matrix mI = Matrices.identity(sizeOfQ);
            final Matrix mN = mI.copy();
            mIminusQ.solve(mI, mN);
            final Vector v = new DenseVector(sizeOfQ);
            for (int i = 0; i < sizeOfQ; ++i) {
                for (int j = 0; j < sizeOfQ; ++j) v.add(i, mN.get(i, j));
                v.set(i, v.get(i) / sizeOfQ);
            }
            highest = findHighestRanked(v);
            ranking[absorbed] = map[highest];
            for (int i = highest; i < size - 1; ++i) map[i] = map[i + 1];
        }
        return ranking;
    }
"
14363,22008893,7,"    private void rotate(int[] a) {
        int tmp = a[0];
        for (int i = 0; i < a.length - 1; i++) {
            a[i] = a[i + 1];
        }
        a[a.length - 1] = tmp;
    }
"
6808,8813150,7,"    private boolean removeCardFromProgram(int card) {
        log.debug(""starting removeCardFromProgram."");
        if (programSet[card].isBlocked()) return false;
        log.debug(""searching for card from program set in card set."");
        int i = 0;
        while (i < 9 && codeSet[i].getPriotity() != programSet[card].getPriotity()) {
            i++;
        }
        if (i == 9) {
            log.debug("" -- card not found"");
            return false;
        } else log.debug("" -- found card at ["" + i + ""]"");
        log.debug(""removing card from programm card set."");
        programSet[card].removeCard(programSetPane);
        programSet[card] = null;
        codeSet[i].select(false);
        i = card;
        while (i < 4) {
            programSet[i] = programSet[i + 1];
            programSet[i + 1] = null;
            i++;
        }
        drawCards();
        return true;
    }
"
6312,7930609,7,"    boolean moveDelta(int index, int dx, int dy) {
        if (dx == 0 && dy == 0) return false;
        boolean needResize = false;
        boolean needLayout = false;
        if (dy == 0) {
            int[] ws = new int[items.length];
            for (int i = 0; i < ws.length; i++) {
                ws[i] = items[i].idealWidth;
            }
            boolean needCalculate = false;
            CoolItem item = items[index];
            if (item.wrap && (dx < 0 || isLastItemOfRow(index))) {
                return false;
            }
            if ((index == 0 && items.length > 1) || (item.wrap && !isLastItemOfRow(index))) {
                if (dx >= item.lastCachedWidth) {
                    CoolItem next = items[index + 1];
                    items[index] = next;
                    items[index + 1] = item;
                    if (item.wrap) {
                        next.wrap = true;
                        item.wrap = false;
                    }
                    int width = next.idealWidth;
                    next.idealWidth = item.idealWidth;
                    item.idealWidth = width;
                    dx = dx - item.lastCachedWidth;
                    index++;
                    needLayout = true;
                }
            }
            if (dx != 0 && index > 0 && !(item.wrap && !isLastItemOfRow(index))) {
                CoolItem cur = item;
                CoolItem prev = items[index - 1];
                int idx = index - 1;
                while (dx < 0) {
                    if (prev.lastCachedWidth + dx < minWidth(prev)) {
                        int ddx = prev.lastCachedWidth - minWidth(prev);
                        prev.idealWidth -= ddx;
                        item.idealWidth += ddx;
                        needCalculate = true;
                        dx += ddx;
                        if (dx < 0) {
                            if (idx - 1 >= 0 && !items[idx].wrap) {
                                idx--;
                                prev = items[idx];
                            } else {
                                if (dx + 11 <= 0) {
                                    CoolItem swpItem = prev;
                                    int swpIndex = index;
                                    while (dx + minWidth(swpItem) <= 0) {
                                        dx += minWidth(swpItem);
                                        swpItem = items[swpIndex - 1];
                                        items[swpIndex - 1] = items[swpIndex];
                                        items[swpIndex] = swpItem;
                                        if (swpItem.wrap) {
                                            items[swpIndex - 1].wrap = true;
                                            swpItem.wrap = false;
                                        }
                                        needLayout = true;
                                        swpIndex--;
                                        if (swpIndex == 0 || swpItem.wrap) {
                                            break;
                                        }
                                    }
                                }
                                dx = 0;
                                break;
                            }
                        }
                    } else {
                        break;
                    }
                }
                CoolItem next = null;
                idx = index;
                while (dx > 0 && cur.lastCachedWidth - dx < minWidth(cur)) {
                    int dxx = cur.lastCachedWidth - minWidth(cur);
                    prev.idealWidth += dxx;
                    cur.idealWidth -= dxx;
                    needCalculate = true;
                    dx -= dxx;
                    if (dx > 0) {
                        if (idx + 1 < items.length && !isLastItemOfRow(idx)) {
                            idx++;
                            cur = items[idx];
                            if (next == null) {
                                next = cur;
                            }
                        } else {
                            if (dx >= 11 && next != null) {
                                CoolItem swpItem = next;
                                int swpIndex = index;
                                while (dx >= minWidth(swpItem)) {
                                    items[swpIndex + 1] = items[swpIndex];
                                    items[swpIndex] = swpItem;
                                    if (swpItem.wrap) {
                                        items[swpIndex].wrap = true;
                                        swpItem.wrap = false;
                                    }
                                    swpItem = items[swpIndex + 1];
                                    needLayout = true;
                                    dx -= minWidth(swpItem);
                                    swpIndex++;
                                    if (swpIndex >= items.length || isLastItemOfRow(swpIndex)) {
                                        break;
                                    }
                                }
                            }
                            dx = 0;
                            break;
                        }
                    }
                }
                prev.idealWidth += dx;
                if (dx != 0) {
                    needCalculate = true;
                }
                if (item != cur) {
                    if (cur.idealWidth - dx < 0) {
                        if (cur.idealWidth != 0) {
                            needCalculate = true;
                        }
                        cur.idealWidth = 0;
                    } else {
                        cur.idealWidth -= dx;
                    }
                } else {
                    item.idealWidth -= dx;
                }
            }
            if (needCalculate && !needLayout) {
                for (int i = 0; i < ws.length; i++) {
                    if (ws[i] != items[i].idealWidth) {
                        needLayout = true;
                        break;
                    }
                }
            }
        } else {
            int line = verticalLine(index);
            if (line + dy < 0) {
                if (index == 0 && isLastItemOfRow(index)) {
                } else {
                    CoolItem ci = items[index];
                    if ((index == 0 && items.length > 1) || (ci.wrap && index < items.length - 1)) {
                        items[index + 1].wrap = true;
                    }
                    for (int i = index; i > 0; i--) {
                        items[i] = items[i - 1];
                    }
                    items[0] = ci;
                    items[1].wrap = true;
                    ci.wrap = false;
                    needLayout = true;
                    needResize = true;
                }
            } else if (line + dy < getVerticalLines()) {
                int lineNumber = line + dy;
                int i = 0;
                for (i = 0; i < items.length; i++) {
                    if (lineNumber == 0) {
                        break;
                    }
                    if (items[i].wrap) {
                        lineNumber--;
                    }
                }
                if (i > 0) i--;
                CoolItem ci = items[index];
                if (index == 0 && isLastItemOfRow(index)) {
                    needResize = true;
                }
                if (ci.wrap) {
                    if (isLastItemOfRow(index)) {
                        needResize = true;
                    }
                    if (index < items.length - 1) {
                        items[index + 1].wrap = true;
                    }
                }
                int x = ci.getPosition().x + dx;
                if (x <= 0) {
                    if (i == 0) {
                        ci.wrap = false;
                    } else {
                        if (index == 0 && i == 1) {
                        } else {
                            ci.wrap = true;
                        }
                        if (i < items.length - 1) {
                            items[i + 1].wrap = false;
                        }
                    }
                } else {
                    int rowWidth = 0;
                    int separator = 2;
                    for (; i < items.length; i++) {
                        CoolItem item = items[i];
                        int minimum = item.minimumWidth + (item.minimumWidth != 0 ? 2 : 0);
                        rowWidth += 7 + 2 + Math.max(item.idealWidth, minimum) + separator;
                        int xx = item.getPosition().x;
                        if (xx < x && (x <= rowWidth || isLastItemOfRow(i))) {
                            item.idealWidth = Math.max(0, x - xx - (7 + 2 + minimum + separator));
                            minimum = ci.minimumWidth + (ci.minimumWidth != 0 ? 2 : 0);
                            int mw = 7 + 2 + minimum + separator;
                            ci.idealWidth = Math.max(item.minimumWidth, Math.max(ci.idealWidth, rowWidth - x - mw));
                            if (rowWidth - x - mw < ci.idealWidth) {
                                needResize = true;
                            }
                            break;
                        }
                    }
                    ci.wrap = false;
                }
                if (dy < 0 && x > 0 && i < items.length - 1) {
                    i++;
                }
                if (dy > 0) {
                    for (int j = index; j < i; j++) {
                        items[j] = items[j + 1];
                    }
                } else {
                    for (int j = index; j > i; j--) {
                        items[j] = items[j - 1];
                    }
                }
                items[i] = ci;
                items[0].wrap = false;
                needLayout = true;
            } else {
                if ((items[index].wrap || index == 0) && isLastItemOfRow(index)) {
                } else {
                    CoolItem ci = items[index];
                    if (index > 0 && ci.wrap) {
                        items[index + 1].wrap = true;
                    }
                    for (int i = index; i < items.length - 1; i++) {
                        items[i] = items[i + 1];
                    }
                    items[items.length - 1] = ci;
                    ci.wrap = true;
                    needLayout = true;
                    needResize = true;
                }
            }
        }
        int w = width;
        int h = height;
        if (needResize) {
            Point computeSize = computeSize(-1, -1, false);
            w = computeSize.x;
            h = computeSize.y;
        }
        if (needLayout) {
            SetWindowPos(null, null, 0, 0, width, h, -1);
        }
        if (w > width) {
            for (int i = index + 1; i < items.length; i++) {
                if (isLastItemOfRow(i)) {
                    moveDelta(i, width - height, 0);
                    break;
                }
            }
        }
        return needLayout;
    }
"
7656,10513112,7,"    public DoubleSquareMatrix[] singularValueDecompose() {
        int i, j, k;
        final int N = numRows;
        final int Nm1 = N - 1;
        final double array[][] = new double[N][N];
        final double arrayU[][] = new double[N][N];
        final double arrayS[] = new double[N];
        final double arrayV[][] = new double[N][N];
        final double e[] = new double[N];
        final double work[] = new double[N];
        for (i = 0; i < N; i++) {
            array[i][0] = matrix[i][0];
            for (j = 1; j < N; j++) array[i][j] = matrix[i][j];
        }
        for (k = 0; k < Nm1; k++) {
            arrayS[k] = array[k][k];
            for (i = k + 1; i < N; i++) arrayS[k] = ExtraMath.hypot(arrayS[k], array[i][k]);
            if (arrayS[k] != 0.0) {
                if (array[k][k] < 0.0) arrayS[k] = -arrayS[k];
                for (i = k; i < N; i++) array[i][k] /= arrayS[k];
                array[k][k] += 1.0;
            }
            arrayS[k] = -arrayS[k];
            for (j = k + 1; j < N; j++) {
                if (arrayS[k] != 0.0) {
                    double t = 0.0;
                    for (i = k; i < N; i++) t += array[i][k] * array[i][j];
                    t /= -array[k][k];
                    for (i = k; i < N; i++) array[i][j] += t * array[i][k];
                }
                e[j] = array[k][j];
            }
            for (i = k; i < N; i++) arrayU[i][k] = array[i][k];
            if (k < N - 2) {
                e[k] = e[k + 1];
                for (i = k + 2; i < N; i++) e[k] = ExtraMath.hypot(e[k], e[i]);
                if (e[k] != 0.0) {
                    if (e[k + 1] < 0.0) e[k] = -e[k];
                    for (i = k + 1; i < N; i++) e[i] /= e[k];
                    e[k + 1] += 1.0;
                }
                e[k] = -e[k];
                if (e[k] != 0.0) {
                    for (i = k + 1; i < N; i++) {
                        work[i] = 0.0;
                        for (j = k + 1; j < N; j++) work[i] += e[j] * array[i][j];
                    }
                    for (j = k + 1; j < N; j++) {
                        double t = -e[j] / e[k + 1];
                        for (i = k + 1; i < N; i++) array[i][j] += t * work[i];
                    }
                }
                for (i = k + 1; i < N; i++) arrayV[i][k] = e[i];
            }
        }
        int p = N;
        arrayS[Nm1] = array[Nm1][Nm1];
        e[N - 2] = array[N - 2][Nm1];
        e[Nm1] = 0.0;
        for (i = 0; i < N; i++) arrayU[i][Nm1] = 0.0;
        arrayU[Nm1][Nm1] = 1.0;
        for (k = N - 2; k >= 0; k--) {
            if (arrayS[k] != 0.0) {
                for (j = k + 1; j < N; j++) {
                    double t = arrayU[k][k] * arrayU[k][j];
                    for (i = k + 1; i < N; i++) t += arrayU[i][k] * arrayU[i][j];
                    t /= -arrayU[k][k];
                    for (i = k; i < N; i++) arrayU[i][j] += t * arrayU[i][k];
                }
                for (i = k; i < N; i++) arrayU[i][k] = -arrayU[i][k];
                arrayU[k][k] += 1.0;
                for (i = 0; i < k - 1; i++) arrayU[i][k] = 0.0;
            } else {
                for (i = 0; i < N; i++) arrayU[i][k] = 0.0;
                arrayU[k][k] = 1.0;
            }
        }
        for (k = Nm1; k >= 0; k--) {
            if (k < N - 2 && e[k] != 0.0) {
                for (j = k + 1; j < N; j++) {
                    double t = arrayV[k + 1][k] * arrayV[k + 1][j];
                    for (i = k + 2; i < N; i++) t += arrayV[i][k] * arrayV[i][j];
                    t /= -arrayV[k + 1][k];
                    for (i = k + 1; i < N; i++) arrayV[i][j] += t * arrayV[i][k];
                }
            }
            for (i = 0; i < N; i++) arrayV[i][k] = 0.0;
            arrayV[k][k] = 1.0;
        }
        final double eps = Math.pow(2.0, -52.0);
        int iter = 0;
        while (p > 0) {
            int action;
            for (k = p - 2; k >= -1; k--) {
                if (k == -1) break;
                if (Math.abs(e[k]) <= eps * (Math.abs(arrayS[k]) + Math.abs(arrayS[k + 1]))) {
                    e[k] = 0.0;
                    break;
                }
            }
            if (k == p - 2) {
                action = 4;
            } else {
                int ks;
                for (ks = p - 1; ks >= k; ks--) {
                    if (ks == k) break;
                    double t = (ks != p ? Math.abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.0);
                    if (Math.abs(arrayS[ks]) <= eps * t) {
                        arrayS[ks] = 0.0;
                        break;
                    }
                }
                if (ks == k) {
                    action = 3;
                } else if (ks == p - 1) {
                    action = 1;
                } else {
                    action = 2;
                    k = ks;
                }
            }
            k++;
            switch(action) {
                case 1:
                    {
                        double f = e[p - 2];
                        e[p - 2] = 0.0;
                        for (j = p - 2; j >= k; j--) {
                            double t = ExtraMath.hypot(arrayS[j], f);
                            final double cs = arrayS[j] / t;
                            final double sn = f / t;
                            arrayS[j] = t;
                            if (j != k) {
                                f = -sn * e[j - 1];
                                e[j - 1] *= cs;
                            }
                            for (i = 0; i < N; i++) {
                                t = cs * arrayV[i][j] + sn * arrayV[i][p - 1];
                                arrayV[i][p - 1] = -sn * arrayV[i][j] + cs * arrayV[i][p - 1];
                                arrayV[i][j] = t;
                            }
                        }
                    }
                    break;
                case 2:
                    {
                        double f = e[k - 1];
                        e[k - 1] = 0.0;
                        for (j = k; j < p; j++) {
                            double t = ExtraMath.hypot(arrayS[j], f);
                            final double cs = arrayS[j] / t;
                            final double sn = f / t;
                            arrayS[j] = t;
                            f = -sn * e[j];
                            e[j] *= cs;
                            for (i = 0; i < N; i++) {
                                t = cs * arrayU[i][j] + sn * arrayU[i][k - 1];
                                arrayU[i][k - 1] = -sn * arrayU[i][j] + cs * arrayU[i][k - 1];
                                arrayU[i][j] = t;
                            }
                        }
                    }
                    break;
                case 3:
                    {
                        final double scale = Math.max(Math.max(Math.max(Math.max(Math.abs(arrayS[p - 1]), Math.abs(arrayS[p - 2])), Math.abs(e[p - 2])), Math.abs(arrayS[k])), Math.abs(e[k]));
                        double sp = arrayS[p - 1] / scale;
                        double spm1 = arrayS[p - 2] / scale;
                        double epm1 = e[p - 2] / scale;
                        double sk = arrayS[k] / scale;
                        double ek = e[k] / scale;
                        double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                        double c = (sp * epm1) * (sp * epm1);
                        double shift = 0.0;
                        if (b != 0.0 || c != 0.0) {
                            shift = Math.sqrt(b * b + c);
                            if (b < 0.0) shift = -shift;
                            shift = c / (b + shift);
                        }
                        double f = (sk + sp) * (sk - sp) + shift;
                        double g = sk * ek;
                        for (j = k; j < p - 1; j++) {
                            double t = ExtraMath.hypot(f, g);
                            double cs = f / t;
                            double sn = g / t;
                            if (j != k) e[j - 1] = t;
                            f = cs * arrayS[j] + sn * e[j];
                            e[j] = cs * e[j] - sn * arrayS[j];
                            g = sn * arrayS[j + 1];
                            arrayS[j + 1] *= cs;
                            for (i = 0; i < N; i++) {
                                t = cs * arrayV[i][j] + sn * arrayV[i][j + 1];
                                arrayV[i][j + 1] = -sn * arrayV[i][j] + cs * arrayV[i][j + 1];
                                arrayV[i][j] = t;
                            }
                            t = ExtraMath.hypot(f, g);
                            cs = f / t;
                            sn = g / t;
                            arrayS[j] = t;
                            f = cs * e[j] + sn * arrayS[j + 1];
                            arrayS[j + 1] = -sn * e[j] + cs * arrayS[j + 1];
                            g = sn * e[j + 1];
                            e[j + 1] *= cs;
                            if (j < Nm1) {
                                for (i = 0; i < N; i++) {
                                    t = cs * arrayU[i][j] + sn * arrayU[i][j + 1];
                                    arrayU[i][j + 1] = -sn * arrayU[i][j] + cs * arrayU[i][j + 1];
                                    arrayU[i][j] = t;
                                }
                            }
                        }
                        e[p - 2] = f;
                        iter++;
                    }
                    break;
                case 4:
                    {
                        if (arrayS[k] <= 0.0) {
                            arrayS[k] = -arrayS[k];
                            for (i = 0; i < p; i++) arrayV[i][k] = -arrayV[i][k];
                        }
                        while (k < p - 1) {
                            if (arrayS[k] >= arrayS[k + 1]) break;
                            double tmp = arrayS[k];
                            arrayS[k] = arrayS[k + 1];
                            arrayS[k + 1] = tmp;
                            if (k < Nm1) {
                                for (i = 0; i < N; i++) {
                                    tmp = arrayU[i][k + 1];
                                    arrayU[i][k + 1] = arrayU[i][k];
                                    arrayU[i][k] = tmp;
                                    tmp = arrayV[i][k + 1];
                                    arrayV[i][k + 1] = arrayV[i][k];
                                    arrayV[i][k] = tmp;
                                }
                            }
                            k++;
                        }
                        iter = 0;
                        p--;
                    }
                    break;
            }
        }
        final DoubleSquareMatrix svd[] = new DoubleSquareMatrix[3];
        svd[0] = new DoubleSquareMatrix(arrayU);
        svd[1] = new DoubleDiagonalMatrix(arrayS);
        svd[2] = new DoubleSquareMatrix(arrayV);
        return svd;
    }
"
14059,21575674,7,"    public void removeRoot(ActuatorContainer root) {
        for (int i = 0; i < acCount; i++) {
            if (acs[i] == root) {
                acs[i] = acs[i + 1];
                root = acs[i];
            }
        }
        acCount--;
    }
"
13845,21122721,7,"    public static BigInteger encrypt(FHEParams fheparams, GHKeyPair key, int b) {
        int i, num = 1;
        int[] bit = new int[1];
        bit[0] = b;
        long n = 1 << (fheparams.logn);
        double p = ((double) fheparams.noise) / n;
        if (p > 0.5) p = 0.5;
        BigInteger[] vals = evalRandPoly(num, n, p, key.root, key.det);
        BigInteger[] out = new BigInteger[num];
        for (i = 0; i < num; i++) {
            out[i] = vals[i + 1];
        }
        for (i = 0; i < num; i++) {
            out[i] = out[i].shiftLeft(1);
            out[i] = out[i].add(new BigInteger(Integer.toString(bit[i])));
            if (out[i].compareTo(key.det) >= 0) out[i] = out[i].subtract(key.det);
        }
        return out[0];
    }
"
4073,4360850,7,"    protected MultipleGradientPaintContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform t, RenderingHints hints, float[] fractions, Color[] colors, MultipleGradientPaint.CycleMethodEnum cycleMethod, MultipleGradientPaint.ColorSpaceEnum colorSpace) throws NoninvertibleTransformException {
        boolean fixFirst = false;
        boolean fixLast = false;
        int len = fractions.length;
        if (fractions[0] != 0f) {
            fixFirst = true;
            len++;
        }
        if (fractions[fractions.length - 1] != 1.0f) {
            fixLast = true;
            len++;
        }
        for (int i = 0; i < fractions.length - 1; i++) if (fractions[i] == fractions[i + 1]) len--;
        this.fractions = new float[len];
        Color[] loColors = new Color[len - 1];
        Color[] hiColors = new Color[len - 1];
        normalizedIntervals = new float[len - 1];
        gradientUnderflow = colors[0].getRGB();
        gradientOverflow = colors[colors.length - 1].getRGB();
        int idx = 0;
        if (fixFirst) {
            this.fractions[0] = 0;
            loColors[0] = colors[0];
            hiColors[0] = colors[0];
            normalizedIntervals[0] = fractions[0];
            idx++;
        }
        for (int i = 0; i < fractions.length - 1; i++) {
            if (fractions[i] == fractions[i + 1]) {
                if (!colors[i].equals(colors[i + 1])) {
                    hasDiscontinuity = true;
                }
                continue;
            }
            this.fractions[idx] = fractions[i];
            loColors[idx] = colors[i];
            hiColors[idx] = colors[i + 1];
            normalizedIntervals[idx] = fractions[i + 1] - fractions[i];
            idx++;
        }
        this.fractions[idx] = fractions[fractions.length - 1];
        if (fixLast) {
            loColors[idx] = hiColors[idx] = colors[colors.length - 1];
            normalizedIntervals[idx] = 1 - fractions[fractions.length - 1];
            idx++;
            this.fractions[idx] = 1;
        }
        AffineTransform tInv = t.createInverse();
        double[] m = new double[6];
        tInv.getMatrix(m);
        a00 = (float) m[0];
        a10 = (float) m[1];
        a01 = (float) m[2];
        a11 = (float) m[3];
        a02 = (float) m[4];
        a12 = (float) m[5];
        this.cycleMethod = cycleMethod;
        this.colorSpace = colorSpace;
        if (cm.getColorSpace() == lrgbmodel_A.getColorSpace()) dataModel = lrgbmodel_A; else if (cm.getColorSpace() == srgbmodel_A.getColorSpace()) dataModel = srgbmodel_A; else throw new IllegalArgumentException(""Unsupported ColorSpace for interpolation"");
        calculateGradientFractions(loColors, hiColors);
        model = GraphicsUtil.coerceColorModel(dataModel, cm.isAlphaPremultiplied());
    }
"
12836,19731645,7,"    public void moveFloor(int from, int to) {
        if (from < 0 || from >= floors.length) throw new IndexOutOfBoundsException(""from"");
        if (to < 0 || to >= floors.length) throw new IndexOutOfBoundsException(""to"");
        if (from == to) return;
        MapFloor mover = floors[from];
        if (from > to) {
            for (int i = from; i > to; i--) floors[i] = floors[i - 1];
            floors[to] = mover;
        } else {
            for (int i = from; i < to; i++) floors[i] = floors[i + 1];
            floors[to] = mover;
        }
    }
"
925,430591,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
13362,20471645,7,"    protected void shiftRight() {
        for (int i = 0; i < DIGITS - 1; i++) mant[i] = mant[i + 1];
        mant[DIGITS - 1] = 0;
        exp++;
    }
"
2157,1236434,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = 0;
        } else items[0] = 0;
        current_item--;
    }
"
13129,20143578,7,"    private void ricompatta() {
        for (int i = 0; i < cardsPresent; i++) {
            if (cards[i] == null && cards[i + 1] != null) {
                cards[i] = cards[i + 1];
                cards[i + 1] = null;
            }
        }
    }
"
3154,2630993,7,"    public void remove(int id) {
        if (id >= 0 && id <= size - 1) {
            for (int i = id; i < size - 1; i++) {
                vector[i] = vector[i + 1];
            }
            vector[size - 1] = null;
            size--;
        }
    }
"
4501,5180407,7,"    }

    /**
   * Sets the default offset amount
   * @param offsetAmount Default offset amount for each parmater in the list
   */
    public void setOffset(float offsetAmount) {
"
1697,789142,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
"
10312,15559784,7,"    public void addPixels(int nArgs, FtsAtom args[]) {
        int startIndex = args[0].intValue;
        int i = 0;
        int j = 0;
        int newp = (int) (nArgs - 1) / 2;
        double[] t_temp = new double[pixelsSize + newp];
        double[] b_temp = new double[pixelsSize + newp];
        if (startIndex == 0) {
            if (isIvec()) {
                for (i = 0; i < (nArgs - 1); i += 2) {
                    t_temp[j] = (double) args[i + 1].intValue;
                    b_temp[j] = (double) args[i + 2].intValue;
                    j++;
                }
            } else {
                for (i = 0; i < (nArgs - 1); i += 2) {
                    t_temp[j] = args[i + 1].doubleValue;
                    b_temp[j] = args[i + 2].doubleValue;
                    j++;
                }
            }
            for (i = newp; i < pixelsSize; i++) {
                t_temp[i] = t_pixels[i - newp];
                b_temp[i] = b_pixels[i - newp];
            }
        } else {
            for (i = 0; (i < pixelsSize - newp) && (i + newp < t_temp.length); i++) {
                t_temp[i] = t_pixels[i + newp];
                b_temp[i] = b_pixels[i + newp];
            }
            j = 1;
            if (isIvec()) for (i = 1; i <= (nArgs - 1); i += 2) {
                t_temp[pixelsSize - newp - 1 + j] = (double) args[i].intValue;
                b_temp[pixelsSize - newp - 1 + j] = (double) args[i + 1].intValue;
                j++;
            } else for (i = 1; (i <= (nArgs - 2)) && (pixelsSize - newp - 1 + j < t_temp.length); i += 2) {
                t_temp[pixelsSize - newp - 1 + j] = args[i].doubleValue;
                b_temp[pixelsSize - newp - 1 + j] = args[i + 1].doubleValue;
                j++;
            }
        }
        t_pixels = t_temp;
        b_pixels = b_temp;
        notifySet();
    }
"
8390,12624126,7,"    public InternalNodeArrayMap split() {
        InternalNodeArrayMap newMap = new InternalNodeArrayMap(keys.length);
        final int mid = currentSize / 2;
        int count = 0;
        newMap.nodes[0] = nodes[mid + 1];
        for (int i = mid + 1; i < currentSize; i++) {
            newMap.keys[count] = keys[i];
            newMap.nodes[++count] = nodes[i + 1];
        }
        for (int i = mid; i < currentSize; i++) {
            nodes[i + 1] = null;
        }
        newMap.currentSize = currentSize - mid - 1;
        currentSize = mid;
        return newMap;
    }
"
4861,5583842,7,"    protected static double[] getTopResidual(double[] maCoef, double[] maseq) {
        int maLevel = maCoef.length - 1;
        if (maLevel > 0) {
            double[] q = new double[maLevel];
            for (int i = 0; i < maLevel; i++) {
                q[i] = maCoef[maLevel - i];
            }
            Matrix Q = new Matrix(q, 1);
            double[][] m = new double[maLevel][maLevel + 1];
            for (int i = 0; i < maLevel; i++) {
                m[i][i] = 1;
            }
            Matrix M = new Matrix(m);
            double[][] k = new double[maLevel][maLevel];
            for (int i = 0; i < k.length; i++) {
                k[i][i] = 1;
            }
            Matrix K = new Matrix(k);
            double[] b = new double[maLevel];
            Matrix B = new Matrix(b, b.length);
            for (int i = 0; i < maseq.length; i++) {
                double[] c = Q.times(-1).times(M).getRowPackedCopy();
                c[maLevel] += maseq[i];
                for (int j = 0; j < maLevel; j++) {
                    b[j] += c[j] * c[maLevel];
                    k[j][j] += c[j] * c[j];
                    for (int l = 0; l < maLevel; l++) {
                        if (l != j) {
                            k[j][l] += c[j] * c[l];
                        }
                    }
                }
                for (int j = 0; j < maLevel - 1; j++) {
                    m[j] = m[j + 1];
                }
                m[maLevel - 1] = c;
            }
            double[] x = null;
            try {
                x = K.inverse().times(B).getRowPackedCopy();
            } catch (Exception e) {
                log.warn(e);
                x = new double[maLevel];
            }
            double[] e = new double[maseq.length];
            for (int i = 0; i < e.length; i++) {
                e[i] = maseq[i];
                for (int j = 0; j < maLevel; j++) {
                    if (i - j - 1 >= 0) {
                        e[i] -= q[maLevel - j - 1] * e[i - j - 1];
                    } else {
                        e[i] -= q[maLevel - j - 1] * x[x.length + i - j - 1];
                    }
                }
            }
            return e;
        } else {
            return maseq;
        }
    }
"
8916,13510716,7,"    public void setup(double[] init_xyz, double[] final_xyz, int n) {
        clear();
        double[] xyz1 = new double[12];
        double[] xyz2 = new double[12];
        int i;
        int j;
        if (n != 0) {
            for (i = 0; i < 3; i++) {
                xyz1[i] = init_xyz[i];
                xyz2[i] = final_xyz[i];
            }
        } else {
            return;
        }
        if (n > 1) {
            double dist;
            double maxdist;
            int id = 1;
            maxdist = 0.0;
            for (i = 1; i < n; i++) {
                for (dist = 0.0, j = 0; j < 3; j++) {
                    dist += ((xyz1[j] - init_xyz[(3 * i) + j]) * (xyz1[j] - init_xyz[(3 * i) + j]));
                }
                dist = Math.sqrt(dist);
                if (dist > maxdist) {
                    maxdist = dist;
                    id = i;
                }
            }
            for (i = 0; i < 3; i++) {
                xyz1[3 + i] = init_xyz[(3 * id) + i];
                xyz2[3 + i] = final_xyz[(3 * id) + i];
            }
        } else {
            double[] euler = new double[3];
            double[] trans = new double[3];
            for (i = 0; i < 3; i++) {
                euler[i] = 0.0f;
                trans[i] = xyz2[i] - xyz1[i];
            }
            setupEulerTranslation(euler, trans);
            return;
        }
        if (n > 2) {
            double mag;
            double maxcross;
            double[] xx = new double[3];
            double[] yy = new double[3];
            double[] cr = new double[3];
            int ic = 1;
            for (j = 0; j < 3; j++) {
                xx[j] = xyz1[3 + j] - xyz1[j];
            }
            maxcross = 0.0f;
            for (i = 1; i < n; i++) {
                for (j = 0; j < 3; j++) {
                    yy[j] = init_xyz[(3 * i) + j] - xyz1[j];
                }
                cr[0] = (xx[1] * yy[2]) - (xx[2] * yy[1]);
                cr[1] = (-xx[0] * yy[2]) + (xx[2] * yy[0]);
                cr[2] = (xx[0] * yy[1]) - (xx[1] * yy[0]);
                mag = Math.sqrt((cr[0] * cr[0]) + (cr[1] * cr[1]) + (cr[2] * cr[2]));
                if (mag > maxcross) {
                    maxcross = mag;
                    ic = i;
                }
            }
            for (i = 0; i < 3; i++) {
                xyz1[6 + i] = init_xyz[(3 * ic) + i];
                xyz2[6 + i] = final_xyz[(3 * ic) + i];
            }
        } else {
            double[] xx = new double[3];
            double[] yy = new double[3];
            xx[0] = xyz1[3 + 0] - xyz1[0];
            xx[1] = xyz1[3 + 1] - xyz1[1];
            xx[2] = xyz1[3 + 2] - xyz1[2];
            yy[0] = xx[2];
            yy[1] = xx[0];
            yy[2] = xx[1];
            xyz1[6 + 0] = yy[0] + xyz1[0];
            xyz1[6 + 1] = yy[1] + xyz1[1];
            xyz1[6 + 2] = yy[2] + xyz1[2];
            xx[0] = xyz2[3 + 0] - xyz2[0];
            xx[1] = xyz2[3 + 1] - xyz2[1];
            xx[2] = xyz2[3 + 2] - xyz2[2];
            yy[0] = xx[2];
            yy[1] = xx[0];
            yy[2] = xx[1];
            xyz2[6 + 0] = yy[0] + xyz2[0];
            xyz2[6 + 1] = yy[1] + xyz2[1];
            xyz2[6 + 2] = yy[2] + xyz2[2];
        }
        double mag;
        double dot;
        double[] xx1 = new double[3];
        double[] yy1 = new double[3];
        double[] zz1 = new double[3];
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            xx1[i] = xyz1[3 + i] - xyz1[i];
        }
        for (i = 0; i < 3; i++) {
            mag += (xx1[i] * xx1[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            xx1[i] /= mag;
            xyz1[3 + i] = xx1[i] + xyz1[i];
        }
        dot = 0.0f;
        for (i = 0; i < 3; i++) {
            yy1[i] = xyz1[6 + i] - xyz1[i];
        }
        for (i = 0; i < 3; i++) {
            dot += (xx1[i] * yy1[i]);
        }
        for (i = 0; i < 3; i++) {
            yy1[i] -= (xx1[i] * dot);
        }
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            mag += (yy1[i] * yy1[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            yy1[i] /= mag;
            xyz1[6 + i] = yy1[i] + xyz1[i];
        }
        zz1[0] = (xx1[1] * yy1[2]) - (xx1[2] * yy1[1]);
        zz1[1] = (-xx1[0] * yy1[2]) + (xx1[2] * yy1[0]);
        zz1[2] = (xx1[0] * yy1[1]) - (xx1[1] * yy1[0]);
        for (i = 0; i < 3; i++) {
            xyz1[9 + i] = zz1[i] + xyz1[i];
        }
        double[] xx2 = new double[3];
        double[] yy2 = new double[3];
        double[] zz2 = new double[3];
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            xx2[i] = xyz2[3 + i] - xyz2[i];
        }
        for (i = 0; i < 3; i++) {
            mag += (xx2[i] * xx2[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            xx2[i] /= mag;
            xyz2[3 + i] = xx2[i] + xyz2[i];
        }
        dot = 0.0f;
        for (i = 0; i < 3; i++) {
            yy2[i] = xyz2[6 + i] - xyz2[i];
        }
        for (i = 0; i < 3; i++) {
            dot += (xx2[i] * yy2[i]);
        }
        for (i = 0; i < 3; i++) {
            yy2[i] -= (xx2[i] * dot);
        }
        mag = 0.0f;
        for (i = 0; i < 3; i++) {
            mag += (yy2[i] * yy2[i]);
        }
        mag = Math.sqrt(mag);
        for (i = 0; i < 3; i++) {
            yy2[i] /= mag;
            xyz2[6 + i] = yy2[i] + xyz2[i];
        }
        zz2[0] = (xx2[1] * yy2[2]) - (xx2[2] * yy2[1]);
        zz2[1] = (-xx2[0] * yy2[2]) + (xx2[2] * yy2[0]);
        zz2[2] = (xx2[0] * yy2[1]) - (xx2[1] * yy2[0]);
        for (i = 0; i < 3; i++) {
            xyz2[9 + i] = zz2[i] + xyz2[i];
        }
        CoordinateTransformation cti = new CoordinateTransformation();
        CoordinateTransformation ctf = new CoordinateTransformation();
        cti.setup(xyz1);
        ctf.setup(xyz2);
        cti.invert();
        this.set(cti.add(ctf));
    }
"
14296,21940171,7,"    public void a52_imdct_256(double[] data, int dataPointer, int delayPointer, double bias) {
        for (int k = 0; k < 64; k++) {
            int p = 2 * (128 - 2 * k - 1);
            int q = 2 * (2 * k);
            buf_1_re[k] = data[p] * xcos2[k] - data[q] * xsin2[k];
            buf_1_im[k] = -1.0f * (data[q] * xcos2[k] + data[p] * xsin2[k]);
            buf_2_re[k] = data[p + 1] * xcos2[k] - data[q + 1] * xsin2[k];
            buf_2_im[k] = -1.0f * (data[q + 1] * xcos2[k] + data[p + 1] * xsin2[k]);
        }
        for (int i = 0; i < 64; i++) {
            int k = bit_reverse_256[i];
            if (k < i) {
                swap_cmplx(buf_1_re, buf_1_im, i, k);
                swap_cmplx(buf_2_re, buf_2_im, i, k);
            }
        }
        int two_m;
        int two_m_plus_one;
        double tmp_a_r, tmp_a_i;
        double tmp_b_r, tmp_b_i;
        for (int m = 0; m < 6; m++) {
            two_m = (1 << m);
            two_m_plus_one = (1 << (m + 1));
            if (m != 0) two_m = (1 << m); else two_m = 1;
            for (int k = 0; k < two_m; k++) {
                for (int i = 0; i < 64; i += two_m_plus_one) {
                    int p = k + i;
                    int q = p + two_m;
                    tmp_a_r = buf_1_re[p];
                    tmp_a_i = buf_1_im[p];
                    tmp_b_r = buf_1_re[q] * w_re[m][k] - buf_1_im[q] * w_im[m][k];
                    tmp_b_i = buf_1_im[q] * w_re[m][k] + buf_1_re[q] * w_im[m][k];
                    buf_1_re[p] = tmp_a_r + tmp_b_r;
                    buf_1_im[p] = tmp_a_i + tmp_b_i;
                    buf_1_re[q] = tmp_a_r - tmp_b_r;
                    buf_1_im[q] = tmp_a_i - tmp_b_i;
                    tmp_a_r = buf_2_re[p];
                    tmp_a_i = buf_2_im[p];
                    tmp_b_r = buf_2_re[q] * w_re[m][k] - buf_2_im[q] * w_im[m][k];
                    tmp_b_i = buf_2_im[q] * w_re[m][k] + buf_2_re[q] * w_im[m][k];
                    buf_2_re[p] = tmp_a_r + tmp_b_r;
                    buf_2_im[p] = tmp_a_i + tmp_b_i;
                    buf_2_re[q] = tmp_a_r - tmp_b_r;
                    buf_2_im[q] = tmp_a_i - tmp_b_i;
                }
            }
        }
        for (int i = 0; i < 64; i++) {
            tmp_a_r = buf_1_re[i];
            tmp_a_i = -buf_1_im[i];
            buf_1_re[i] = (tmp_a_r * xcos2[i]) - (tmp_a_i * xsin2[i]);
            buf_1_im[i] = (tmp_a_r * xsin2[i]) + (tmp_a_i * xcos2[i]);
            tmp_a_r = buf_2_re[i];
            tmp_a_i = -buf_2_im[i];
            buf_2_re[i] = (tmp_a_r * xcos2[i]) - (tmp_a_i * xsin2[i]);
            buf_2_im[i] = (tmp_a_r * xsin2[i]) + (tmp_a_i * xcos2[i]);
        }
        int dataPtr = dataPointer;
        int delayPtr = delayPointer;
        int windowPointer = 0;
        if (debug) System.out.println(""BIAS "" + bias);
        for (int i = 0; i < 64; i++) {
            data[dataPtr++] = -buf_1_im[i] * window[windowPointer++] + data[delayPtr++] + bias;
            data[dataPtr++] = buf_1_re[64 - i - 1] * window[windowPointer++] + data[delayPtr++] + bias;
        }
        for (int i = 0; i < 64; i++) {
            data[dataPtr++] = -buf_1_re[i] * window[windowPointer++] + data[delayPtr++] + bias;
            data[dataPtr++] = buf_1_im[64 - i - 1] * window[windowPointer++] + data[delayPtr++] + bias;
        }
        delayPtr = delayPointer;
        for (int i = 0; i < 64; i++) {
            data[delayPtr++] = -buf_2_re[i] * window[--windowPointer];
            data[delayPtr++] = buf_2_im[64 - i - 1] * window[--windowPointer];
        }
        for (int i = 0; i < 64; i++) {
            data[delayPtr++] = buf_2_im[i] * window[--windowPointer];
            data[delayPtr++] = -buf_2_re[64 - i - 1] * window[--windowPointer];
        }
    }
"
2481,1706198,7,"    @SuppressWarnings(""unchecked"")
    public V remove(char key) {
        char k = key;
        int index = Arrays.binarySearch(keyIndices, k);
        if (index >= 0) {
            V old = (V) (values[index]);
            Object[] newValues = Arrays.copyOf(values, values.length - 1);
            char[] newIndices = Arrays.copyOf(keyIndices, keyIndices.length - 1);
            for (int i = index; i < values.length - 1; ++i) {
                newValues[i] = values[i + 1];
                newIndices[i] = keyIndices[i + 1];
            }
            values = newValues;
            keyIndices = newIndices;
            return old;
        }
        return null;
    }
"
6872,8876558,7,"    public void updateGeometry(Line shape, List<Vector3f> points, int segments, boolean closed, Vector3f up) {
        int np = points.size();
        if (closed) {
            np = np + 3;
        }
        float d[][] = new float[3][np];
        float x[] = new float[np];
        List<Vector3f> path = new ArrayList<Vector3f>();
        for (int i = 0; i < np; i++) {
            Vector3f p;
            if (!closed) {
                p = points.get(i);
            } else {
                if (i == 0) {
                    p = points.get(points.size() - 1);
                } else if (i >= np - 2) {
                    p = points.get(i - np + 2);
                } else {
                    p = points.get(i - 1);
                }
            }
            x[i] = i;
            d[0][i] = p.x;
            d[1][i] = p.y;
            d[2][i] = p.z;
        }
        if (np > 1) {
            float[][] a = new float[3][np];
            float h[] = new float[np];
            for (int i = 1; i <= np - 1; i++) {
                h[i] = x[i] - x[i - 1];
            }
            if (np > 2) {
                float sub[] = new float[np - 1];
                float diag[] = new float[np - 1];
                float sup[] = new float[np - 1];
                for (int i = 1; i <= np - 2; i++) {
                    diag[i] = (h[i] + h[i + 1]) / 3;
                    sup[i] = h[i + 1] / 6;
                    sub[i] = h[i] / 6;
                    for (int dim = 0; dim < 3; dim++) {
                        a[dim][i] = (d[dim][i + 1] - d[dim][i]) / h[i + 1] - (d[dim][i] - d[dim][i - 1]) / h[i];
                    }
                }
                for (int dim = 0; dim < 3; dim++) {
                    solveTridiag(sub.clone(), diag.clone(), sup.clone(), a[dim], np - 2);
                }
            }
            if (!closed) {
                path.add(new Vector3f(d[0][0], d[1][0], d[2][0]));
            }
            float[] point = new float[3];
            for (int i = closed ? 2 : 1; i <= np - 2; i++) {
                for (int j = 1; j <= segments; j++) {
                    for (int dim = 0; dim < 3; dim++) {
                        float t1 = (h[i] * j) / segments;
                        float t2 = h[i] - t1;
                        float v = ((-a[dim][i - 1] / 6 * (t2 + h[i]) * t1 + d[dim][i - 1]) * t2 + (-a[dim][i] / 6 * (t1 + h[i]) * t2 + d[dim][i]) * t1) / h[i];
                        point[dim] = v;
                    }
                    path.add(new Vector3f(point[0], point[1], point[2]));
                }
            }
        }
        this.updateGeometry(shape, path, closed, up);
    }
"
5589,6583869,7,"    public void test2_1() {
        Integer[] arr1 = { 21, 32, 44, 55 };
        int[] arr2 = new int[arr1.length];
        for (int i = 0; i < arr1.length; i++) {
            arr2[i] = arr1[i + 1];
        }
    }
"
2993,2404010,7,"    public Block<?> getTestBlockForCon(Constructor<T> pCon, Expression<?>[] curPlans) {
        notNull(pCon);
        notNull(curPlans);
        final Class<T> testeeType = pCon.getDeclaringClass();
        final Block<?> b = new BlockImpl(testeeType, pCon, testBlockSpaces);
        final BlockStatement<?>[] bs = new BlockStatement[curPlans.length + 1];
        final Variable<?>[] ids = new Variable[curPlans.length];
        Class<?>[] paramsTypes = pCon.getParameterTypes();
        for (int i = 0; i < curPlans.length; i++) {
            ids[i] = b.getNextID(paramsTypes[i]);
            bs[i] = new LocalVariableDeclarationStatement(ids[i], curPlans[i]);
        }
        ConstructorCall<T> conPlan = null;
        if (typeGraph.getWrapper(pCon.getDeclaringClass()).isInnerClass()) {
            Expression[] paramPlans = new Expression[curPlans.length - 1];
            for (int j = 0; j < paramPlans.length; j++) {
                paramPlans[j] = ids[j + 1];
            }
            conPlan = new ConstructorCall<T>(testeeType, pCon, paramPlans, ids[0]);
        } else {
            conPlan = new ConstructorCall<T>(testeeType, pCon, ids);
        }
        bs[curPlans.length] = new ExpressionStatement<T>(conPlan);
        List<BlockStatement> blockStatements = new LinkedList<BlockStatement>();
        for (BlockStatement blockStatement : bs) blockStatements.add(blockStatement);
        b.setBlockStmts(blockStatements);
        return b;
    }
"
1139,534601,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
"
9947,14966555,7,"    public void removeMidiInputListener(MidiInputListener mil) {
        for (int i = 0; i < milCount; i++) {
            if (mils[i] == mil) {
                mils[i] = mils[i + 1];
                mil = mils[i];
            }
        }
        milCount--;
    }
"
12673,19658635,7,"    private static void dualPivotQuicksort(short[] a, int left, int right) {
        int sixth = (right - left + 1) / 6;
        int e1 = left + sixth;
        int e5 = right - sixth;
        int e3 = (left + right) >>> 1;
        int e4 = e3 + sixth;
        int e2 = e3 - sixth;
        short ae1 = a[e1], ae2 = a[e2], ae3 = a[e3], ae4 = a[e4], ae5 = a[e5];
        if (ae1 > ae2) {
            short t = ae1;
            ae1 = ae2;
            ae2 = t;
        }
        if (ae4 > ae5) {
            short t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        if (ae1 > ae3) {
            short t = ae1;
            ae1 = ae3;
            ae3 = t;
        }
        if (ae2 > ae3) {
            short t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae1 > ae4) {
            short t = ae1;
            ae1 = ae4;
            ae4 = t;
        }
        if (ae3 > ae4) {
            short t = ae3;
            ae3 = ae4;
            ae4 = t;
        }
        if (ae2 > ae5) {
            short t = ae2;
            ae2 = ae5;
            ae5 = t;
        }
        if (ae2 > ae3) {
            short t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae4 > ae5) {
            short t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        a[e1] = ae1;
        a[e3] = ae3;
        a[e5] = ae5;
        short pivot1 = ae2;
        a[e2] = a[left];
        short pivot2 = ae4;
        a[e4] = a[right];
        int less = left + 1;
        int great = right - 1;
        boolean pivotsDiffer = (pivot1 != pivot2);
        if (pivotsDiffer) {
            outer: for (int k = less; k <= great; k++) {
                short ak = a[k];
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = a[great];
                        a[great--] = ak;
                    }
                }
            }
        } else {
            for (int k = less; k <= great; k++) {
                short ak = a[k];
                if (ak == pivot1) {
                    continue;
                }
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = pivot1;
                        a[great--] = ak;
                    }
                }
            }
        }
        a[left] = a[less - 1];
        a[less - 1] = pivot1;
        a[right] = a[great + 1];
        a[great + 1] = pivot2;
        doSort(a, left, less - 2);
        doSort(a, great + 2, right);
        if (!pivotsDiffer) {
            return;
        }
        if (less < e1 && great > e5) {
            while (a[less] == pivot1) {
                less++;
            }
            while (a[great] == pivot2) {
                great--;
            }
            outer: for (int k = less; k <= great; k++) {
                short ak = a[k];
                if (ak == pivot2) {
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) {
                        a[k] = a[less];
                        a[less++] = pivot1;
                    } else {
                        a[k] = a[great];
                    }
                    a[great--] = pivot2;
                } else if (ak == pivot1) {
                    a[k] = a[less];
                    a[less++] = pivot1;
                }
            }
        }
        doSort(a, less, great);
    }
"
914,420195,7,"    public boolean delete(long value) {
        int j = find(value);
        if (j == nElems) return false; else {
            for (int k = j; k < nElems; k++) a[k] = a[k + 1];
            nElems--;
            return true;
        }
    }
"
6017,7603475,7,"    private TriangleMesh triangulateCurve() {
        Vec3 v[] = new Vec3[vertex.length], size = getBounds().getSize();
        Vec2 v2[] = new Vec2[vertex.length];
        int i, j, current, count, min;
        int index[] = new int[vertex.length], faces[][] = new int[vertex.length - 2][3];
        double dir, dir2;
        boolean inside;
        if (size.x > size.y) {
            if (size.y > size.z) j = 2; else j = 1;
        } else {
            if (size.x > size.z) j = 2; else j = 0;
        }
        for (i = 0; i < vertex.length; i++) {
            v[i] = vertex[i].r;
            v2[i] = vertex[i].r.dropAxis(j);
        }
        min = 0;
        for (i = 1; i < v2.length; i++) {
            if (v2[i].x < v2[min].x) min = i;
        }
        for (i = 0; i < index.length; i++) index[i] = i;
        current = min;
        do {
            dir = triangleDirection(v2, index, v2.length, current);
            if (dir == 0.0) {
                current = (current + 1) % index.length;
                if (current == min) return null;
            }
        } while (dir == 0.0);
        count = index.length;
        for (i = 0; i < vertex.length - 2; i++) {
            j = current;
            do {
                dir2 = triangleDirection(v2, index, count, current);
                inside = containsPoints(v2, index, count, current);
                if (dir2 * dir < 0.0 || inside) {
                    current = (current + 1) % count;
                    if (current == j) return null;
                }
            } while (dir2 * dir < 0.0 || inside);
            if (current == 0) faces[i][0] = index[count - 1]; else faces[i][0] = index[current - 1];
            faces[i][1] = index[current];
            if (current == count - 1) faces[i][2] = index[0]; else faces[i][2] = index[current + 1];
            for (j = current; j < count - 1; j++) index[j] = index[j + 1];
            count--;
            current = (current + 1) % count;
        }
        TriangleMesh mesh = new TriangleMesh(v, faces);
        TriangleMesh.Vertex vert[] = (TriangleMesh.Vertex[]) mesh.getVertices();
        return mesh;
    }
"
1225,574984,7,"    public void writeln(String s) {
        try {
            if (curRow < height - 1) {
                text[++curRow] = s;
            } else {
                for (int i = 0; i < height - 1; i++) {
                    text[i] = text[i + 1];
                }
                text[height - 1] = s;
            }
            conText.setValue(text);
            curCol = 0;
            cursor(curRow, -2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
"
14708,22737498,7,"        public URIInfo(String uri) {
            m_id = null;
            m_params = null;
            String[] ids = extractID(uri);
            if (ids != null && ids.length >= 1) {
                m_id = ids[0];
                if (ids.length > 1) {
                    m_params = new String[ids.length - 1];
                    for (int i = 0; i < m_params.length; i++) {
                        m_params[i] = ids[i + 1];
                    }
                }
            }
        }
"
5771,7074779,7,"    public void splitEdgeNearPoint(GraphEdgeModel edge, Point2D pt) {
        Point2D edgeControls[] = getActualEdgeControls(edge);
        Point2D ctrls[];
        if (edgeControls.length < 4) {
            ctrls = new Point2D[4];
            lineToBezier(edgeControls, 0, ctrls, 0);
        } else ctrls = NearestPointOnCurve.splitBezierSetNearPoint(pt, edgeControls);
        Point2D newCtrls[] = new Point2D[ctrls.length - 2];
        for (int i = 0; i < newCtrls.length; i++) newCtrls[i] = ctrls[i + 1];
        edge.setControlPoints(newCtrls);
        repaint(edge.getChangeBBox());
    }
"
2099,1077376,7,"    public void paintComponent(final Graphics _g) {
        super.paintComponent(_g);
        if (boite_ == null) {
            return;
        }
        if (vvz_ == null) {
            return;
        }
        if (isRapide()) {
            final TraceGeometrie tg = new TraceGeometrie(getVersEcran());
            tg.setForeground(getForeground());
            tg.dessinePolygone((Graphics2D) _g, boite_, false, true);
            return;
        }
        final GrBoite clip = getClipEcran(_g);
        final GrPolygone r = boite_.applique(getVersEcran());
        final GrBoite b = r.boite();
        if (b.intersectionXY(clip) == null) {
            return;
        }
        BPaletteCouleur ligPalette = palette_;
        if ((surface_ && contour_) || (surface_ && isolignes_) || (isosurfaces_ && contour_) || (isosurfaces_ && isolignes_)) {
            ligPalette = new BPaletteCouleurSimple();
            ((BPaletteCouleurSimple) ligPalette).setCouleurMin(getForeground());
            ((BPaletteCouleurSimple) ligPalette).setCouleurMax(getForeground());
        }
        final TraceIsoLignes isol = new TraceIsoLignes(ecart_, ligPalette);
        final TraceIsoSurfaces isos = new TraceIsoSurfaces(ecart_, palette_);
        Gouraud tg = null;
        if (paramGouraud_ != null) {
            tg = new Gouraud(_g, paramGouraud_.getNiveau(), paramGouraud_.getTaille());
        }
        final GrPoint o = r.sommet(0);
        final GrVecteur pasX = r.sommet(1).soustraction(o).division(vvz_.length - 1);
        final GrVecteur pasY = r.sommet(3).soustraction(o).division(vvz_[0].length - 1);
        final int imin = 0;
        final int imax = vvz_.length - 1;
        final int jmin = 0;
        final int jmax = vvz_[0].length - 1;
        final int[] x = new int[4];
        final int[] y = new int[4];
        final Color[] c = new Color[4];
        final double[] v = new double[4];
        for (int i = imin; i < imax; i++) {
            final GrPoint pi = o.addition(pasX.multiplication(i));
            for (int j = jmin; j < jmax; j++) {
                final GrPoint p0 = pi.addition(pasY.multiplication(j));
                final GrPoint p1 = p0.addition(pasX);
                final GrPoint p2 = p1.addition(pasY);
                final GrPoint p3 = p0.addition(pasY);
                boolean dedans = false;
                if (clip.contientXY(p0)) {
                    dedans = true;
                }
                if (clip.contientXY(p1)) {
                    dedans = true;
                }
                if (clip.contientXY(p2)) {
                    dedans = true;
                }
                if (clip.contientXY(p3)) {
                    dedans = true;
                }
                if (dedans) {
                    x[0] = (int) p0.x_;
                    y[0] = (int) p0.y_;
                    c[0] = vvc_[i][j];
                    v[0] = vvv_[i][j];
                    x[1] = (int) p1.x_;
                    y[1] = (int) p1.y_;
                    c[1] = vvc_[i + 1][j];
                    v[1] = vvv_[i + 1][j];
                    x[2] = (int) p2.x_;
                    y[2] = (int) p2.y_;
                    c[2] = vvc_[i + 1][j + 1];
                    v[2] = vvv_[i + 1][j + 1];
                    x[3] = (int) p3.x_;
                    y[3] = (int) p3.y_;
                    c[3] = vvc_[i][j + 1];
                    v[3] = vvv_[i][j + 1];
                    if (surface_ && (!isosurfaces_)) {
                        if (tg == null) {
                            _g.setColor(c[0]);
                            _g.fillPolygon(x, y, x.length);
                        } else {
                            tg.fillRectangle(x, y, c);
                        }
                    }
                    if (isosurfaces_) {
                        isos.draw(_g, new Polygon(x, y, x.length), v);
                    }
                    if (contour_) {
                        _g.setColor(getBackground());
                        _g.drawPolygon(x, y, x.length);
                    }
                    if (isolignes_) {
                        isol.draw(_g, new Polygon(x, y, x.length), v);
                    }
                }
            }
        }
    }
"
2357,1555915,7,"    private void newCluster() {
        for (int k = 0; k < numClusters; k++) {
            if (k != besti && k != bestj) {
                int ak = alias[k];
                distance[ak][abi] = distance[abi][ak] = updatedDistance(besti, bestj, k);
            }
        }
        distance[abi][abi] = 0.0;
        height[abi] = getDist(besti, bestj) / 2.0;
        oc[abi] += oc[abj];
        NodeUtils.joinChilds(getRoot(), besti, bestj);
        for (int i = bestj; i < numClusters - 1; i++) {
            alias[i] = alias[i + 1];
        }
        numClusters--;
    }
"
47,19546,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
"
4829,5533628,7,"    public Object next(int index) {
        if (index >= N - 2) next(); else {
            int m = Al[index];
            sort(index + 1, N - 1);
            if (m > Al[N - 1]) {
                if (index > 0) return next(index - 1);
                first();
            } else {
                int o;
                for (o = N - 2; Al[o] > m; o--) ;
                Al[index] = Al[o + 1];
                Al[o + 1] = m;
            }
        }
        return this;
    }
"
3269,2874111,7,"    public static Object newMsg(Object[] _p) {
        FooLib.checkClassArgument(Class.class, _p[0], 0);
        Class c = (Class) _p[0];
        if (c.isArray()) {
            int l = _p.length - 1;
            int[] d = new int[l];
            for (int i = 0; i < l; i++) {
                c = c.getComponentType();
                d[i] = FooLib.toInteger(_p[i + 1]).intValue();
            }
            return Array.newInstance(c, d);
        }
        Constructor m = FooLib.getConstructor(c, c.getName(), _p.length - 1);
        if (m == null) {
            StringBuffer s = new StringBuffer(c.getName() + ""("");
            for (int j = 0; j < _p.length; j++) {
                if (j > 0) s.append(',');
                s.append(FooLib.getClassName(_p[j]));
            }
            s.append(')');
            throw new RuntimeException(""constructor not found:"" + s);
        }
        Object[] q = new Object[_p.length - 1];
        for (int i = 0; i < q.length; i++) q[i] = _p[i + 1];
        return FooLib.invokeConstructor(m, q);
    }
"
11844,18369171,7,"    private void processColorCache(RdpPacket_Localised data) throws RdesktopException {
        byte[] palette = null;
        byte[] red = null;
        byte[] green = null;
        byte[] blue = null;
        int j = 0;
        int cache_id = data.get8();
        int n_colors = data.getLittleEndian16();
        palette = new byte[n_colors * 4];
        red = new byte[n_colors];
        green = new byte[n_colors];
        blue = new byte[n_colors];
        data.copyToByteArray(palette, 0, data.getPosition(), palette.length);
        data.incrementPosition(palette.length);
        for (int i = 0; i < n_colors; i++) {
            blue[i] = palette[j];
            green[i] = palette[j + 1];
            red[i] = palette[j + 2];
            j += 4;
        }
        IndexColorModel cm = new IndexColorModel(8, n_colors, red, green, blue);
        cache.put_colourmap(cache_id, cm);
    }
"
11730,18210029,7,"    public Hashtable[] removeArrayElement(Hashtable[] cons, int i) {
        if (cons != null && cons.length > i) {
            Hashtable[] newhash = new Hashtable[cons.length - 1];
            for (int j = 0; j < i; j++) {
                newhash[j] = cons[j];
            }
            for (int j = i + 1; j < newhash.length; j++) {
                newhash[j] = cons[j + 1];
            }
            return newhash;
        }
        return null;
    }
"
9767,14543929,7,"    private void incrementalSortGameObjectsOnXPosition() {
        GameObject tempGameObject;
        for (int i = 0; i < size - 1; i++) {
            if (gameObjects[i].x - gameObjects[i].boundingDimension / 2 > gameObjects[i + 1].x - gameObjects[i + 1].boundingDimension / 2) {
                tempGameObject = gameObjects[i];
                gameObjects[i] = gameObjects[i + 1];
                gameObjects[i + 1] = tempGameObject;
                int j = i;
                while (j > 0 && gameObjects[j].x - gameObjects[j].boundingDimension / 2 < gameObjects[j - 1].x - gameObjects[j - 1].boundingDimension / 2) {
                    tempGameObject = gameObjects[j];
                    gameObjects[j] = gameObjects[j - 1];
                    gameObjects[j - 1] = tempGameObject;
                    j--;
                }
                j = i + 1;
                while (j < size - 1 && gameObjects[j].x - gameObjects[j].boundingDimension / 2 > gameObjects[j + 1].x - gameObjects[j + 1].boundingDimension / 2) {
                    tempGameObject = gameObjects[j];
                    gameObjects[j] = gameObjects[j + 1];
                    gameObjects[j + 1] = tempGameObject;
                    j++;
                }
            }
        }
    }
"
11484,17627330,7,"    public static final void iir_mem2(final float[] x, final int xs, final float[] den, final float[] y, final int ys, final int N, final int ord, final float[] mem) {
        int i, j;
        for (i = 0; i < N; i++) {
            y[ys + i] = x[xs + i] + mem[0];
            for (j = 0; j < ord - 1; j++) {
                mem[j] = mem[j + 1] - den[j + 1] * y[ys + i];
            }
            mem[ord - 1] = -den[ord] * y[ys + i];
        }
    }
"
794,379353,7,"    public void run() {
        VM_Callbacks.notifyStartup();
        VM_Controller.boot();
        String[] mainArgs = null;
        INSTRUCTION[] mainCode = null;
        synchronized (VM_ClassLoader.lock) {
            VM_Class cls = null;
            try {
                cls = VM_Class.forName(args[0]);
            } catch (VM_ResolutionException e) {
                VM.sysWrite(e.getException() + ""\n"");
                return;
            }
            mainMethod = cls.findMainMethod();
            if (mainMethod == null) {
                VM.sysWrite(cls.getName() + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
                return;
            }
            mainArgs = new String[args.length - 1];
            for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
            mainCode = mainMethod.compile();
        }
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainCode);
    }
"
3128,2544499,7,"    private static short[] convertBuffer(final byte[] buf) throws IOException {
        assertTrue(buf.length % 2 == 0);
        byte[] bigEndianBuf = new byte[buf.length];
        for (int i = 0; i < buf.length - 1; i += 2) {
            bigEndianBuf[i] = buf[i + 1];
            bigEndianBuf[i + 1] = buf[i];
        }
        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bigEndianBuf));
        short[] samples = new short[buf.length / 2];
        for (int i = 0; i < samples.length; i++) {
            samples[i] = dis.readShort();
        }
        return samples;
    }
"
5146,5861519,7,"    static ImageProducer Bitmap(byte[] imageData, int offset, int type) {
        if (WORD(imageData, offset + 12) != 1) throw new IllegalArgumentException(""planes!=1"");
        final int width = DWORD(imageData, offset + 4);
        final int h = DWORD(imageData, offset + 8);
        final int height = type != 0 ? h / 2 : h;
        final int bitCount = WORD(imageData, offset + 14);
        final int nColorsUsed = DWORD(imageData, offset + 32);
        final int colorCount = nColorsUsed != 0 ? nColorsUsed : 1 << bitCount;
        final int colorOffset = offset + DWORD(imageData, offset);
        final int compression = DWORD(imageData, offset + 16);
        if (compression != 0 && compression != 3) throw new IllegalArgumentException(""compression!=0 && compression!=3"");
        if (bitCount < 16 || compression == 3) {
            int idx = colorOffset;
            for (int i = 0; i < colorCount; ++i) {
                final byte b = imageData[idx];
                imageData[idx] = imageData[idx + 2];
                imageData[idx + 2] = b;
                imageData[idx + 3] = (byte) 255;
                idx += 4;
            }
        }
        final int[] intData = new int[height * width];
        int dst = 0;
        final int xorBytes = colorOffset + 4 * (bitCount < 16 ? colorCount : nColorsUsed);
        final int xorBytesPerRow = ((width * bitCount / 8) + 3) & ~3;
        final int andBytes = xorBytes + xorBytesPerRow * height;
        int xorOffset = xorBytes;
        int andOffset = andBytes;
        final int xorMask = bitCount < 32 ? (1 << bitCount) - 1 : 0xffffffff;
        final int pixelsPerByte = 8 / bitCount;
        final int bytesPerPixel = bitCount / 8;
        final int extraMaskBytesPerRow = (((width + 31) & ~31) - width) / 8;
        for (int y = 0; y < height; ++y) {
            int xPixel = 0, aPixel = 0;
            byte xData = 0, aData = 0;
            for (int x = 0; x < width; ++x) {
                int argb;
                if (bitCount < 16) {
                    if (--xPixel < 0) {
                        xData = imageData[xorOffset++];
                        xPixel = pixelsPerByte - 1;
                    }
                    argb = TRIPLE(imageData, colorOffset + ((xData >> (xPixel * bitCount)) & xorMask) * 4);
                } else {
                    argb = (imageData[xorOffset] & 0xff) | ((imageData[xorOffset + 1] & 0xff) << 8) | ((imageData[xorOffset + 2] & 0xff) << 16);
                    if (compression == 3) argb = TRIPLE(imageData, colorOffset + argb * 4); else argb |= 0xff000000;
                    xorOffset += bytesPerPixel;
                }
                if (type != 0) {
                    if (--aPixel < 0) {
                        aData = imageData[andOffset++];
                        aPixel = 7;
                    }
                    if ((aData & (1 << aPixel)) != 0) {
                        argb &= 0xffffff;
                    }
                }
                intData[dst++] = argb;
            }
            andOffset += extraMaskBytesPerRow;
        }
        return new MemoryImageSource(width, height, intData, dst - width, -width);
    }
"
3233,2820590,7,"    protected void setData() {
        if (contact == null || !isInited()) return;
        int m_temp_gender = 0;
        String m_temp_spouse = """";
        String[] m_temp_children = new String[10];
        if (contact.hasPersonalIdentity()) {
            PersonalIdentity pid = contact.getPersonalIdentity();
            Date birthDate = pid.getBirthDate();
            if (birthDate != null) {
                Calendar birthCal = new GregorianCalendar();
                birthCal.setTime(birthDate);
                birthdayCB.setCalendar(birthCal);
            }
        }
        if (contact.hasExtensions()) {
            m_Extensions = contact.getExtensions();
            m_SimpleExtension_GN = (SimpleExtension) (m_Extensions.get(""X-WAB-GENDER""));
            if (m_SimpleExtension_GN != null) {
                try {
                    m_temp_gender = Integer.valueOf(m_SimpleExtension_GN.getValue()).intValue();
                } catch (java.lang.NumberFormatException ne) {
                    m_temp_gender = 0;
                }
            }
            m_SimpleExtension_FM = (SimpleExtension) (m_Extensions.get(""X-FAMILY""));
            if (m_SimpleExtension_FM != null) {
                String[] values = m_SimpleExtension_FM.listValues();
                try {
                    m_temp_spouse = values[0];
                    for (int i = 0; i < 10; i++) m_temp_children[i] = values[i + 1];
                } catch (java.lang.IndexOutOfBoundsException ie) {
                }
            }
        }
        if ((m_temp_gender <= 0) && (m_temp_gender >= 2)) m_temp_gender = 0;
        m_cb_gender.setSelectedIndex(m_temp_gender);
        m_f_spouse.setText(m_temp_spouse);
    }
"
13675,20976464,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = new Area();
        } else items[0] = new Area();
        current_item--;
    }
"
9575,14362217,7,"    public static HexCommand fromByteArray(byte[] data) throws RFIDException {
        int actual_size = data.length;
        int data_size = ByteUtils.unsignedByteToInt(data[0]);
        byte[] crc = ByteUtils.range(actual_size - 2, -1, data);
        data = ByteUtils.range(0, actual_size - 3, data);
        if (actual_size > 0xFF) {
            byte[] data_size_bytes = new byte[data_size];
            for (int i = 0; i < data_size; i++) data_size_bytes[i] = data[i + 1];
            data_size = ByteUtils.mergeBytes(data_size_bytes);
        }
        data = ByteUtils.range(1, -1, data);
        if (data_size != actual_size) throw new CommandException(""size mismatch, given: "" + data_size + "", string was: "" + actual_size);
        HexCommand hc = new HexCommand(data);
        byte[] calc_crc = hc.crc16();
        if (!(ByteUtils.sameContents(crc, calc_crc))) throw new CRCException(""checksum (crc16) mismatch, given: "" + ByteUtils.byteArrayToHex(crc) + "", calculated: "" + ByteUtils.byteArrayToHex(calc_crc));
        return hc;
    }
"
13132,20161795,7,"    public void setBigEndian(boolean bigEndian) {
        if (bigEndian != this.bigEndian) {
            byte tmp;
            for (int i = 0; i < data.length; i += 2) {
                tmp = data[i];
                data[i] = data[i + 1];
                data[i + 1] = tmp;
            }
            this.bigEndian = bigEndian;
        }
    }
"
13693,21006642,7,"    public static LevelData loadLevelData(BufferedReader in) throws BadLevelDataException {
        int lineNumber = 0;
        int lastSubjectRelatedLineNumber = 0;
        try {
            String header = in.readLine();
            ++lineNumber;
            if (!header.trim().equals(LEVELFILE_HEADER)) throw new BadLevelDataException(lineNumber);
            LevelData ldata = new LevelData();
            LinkedList<ObjectEntry> entries = new LinkedList<ObjectEntry>();
            while (in.ready()) {
                String currentLine = in.readLine().trim();
                ++lineNumber;
                String[] tokens = currentLine.split(""\\s"");
                if (currentLine.equals("""")) continue; else if (tokens.length > 9 && tokens[0].equalsIgnoreCase(""layer:"")) {
                    int type = Integer.parseInt(tokens[3]);
                    ObjectEntry newEntry;
                    if (tokens.length == 10 && type != SpriteType.DOOR && type != SpriteType.CLOSED_DOOR) newEntry = new ObjectEntry(); else if (tokens.length == 11 && (type == SpriteType.DOOR || type == SpriteType.CLOSED_DOOR)) {
                        DoorEntry de = new DoorEntry();
                        de.nextLevelRelativeFilename = tokens[10];
                        newEntry = de;
                    } else if (tokens.length >= 12 && type == SpriteType.BOX_QUESTION) {
                        LegacyQuestionEntry lqe = new LegacyQuestionEntry();
                        lqe.question = tokens[10].replace('_', ' ');
                        lqe.correctAnswerIndex = Integer.parseInt(tokens[11]);
                        lqe.answers = new String[tokens.length - 12];
                        for (int i = 12; i < tokens.length; i++) lqe.answers[i - 12] = tokens[i].replace('_', ' ');
                        newEntry = lqe;
                    } else throw new BadLevelDataException(lineNumber);
                    newEntry.layer = Integer.parseInt(tokens[1]);
                    newEntry.type = type;
                    newEntry.x = Integer.parseInt(tokens[5]);
                    newEntry.y = Integer.parseInt(tokens[7]);
                    newEntry.imageRelativeFilename = tokens[9];
                    if (tokens[9].trim().equals(""plattform/spikes.png"")) newEntry.loadTranslucent = true; else newEntry.loadTranslucent = false;
                    entries.add(newEntry);
                } else if (tokens.length == 4 && tokens[0].equalsIgnoreCase(""width:"")) {
                    ldata.width = Integer.parseInt(tokens[1]);
                    ldata.height = Integer.parseInt(tokens[3]);
                } else if (tokens.length >= 1 && tokens[0].equalsIgnoreCase(""mathematics:"")) {
                    String[] subjects = new String[tokens.length - 1];
                    for (int i = 0; i < subjects.length; i++) subjects[i] = tokens[i + 1];
                    ldata.subjectNames = subjects;
                    lastSubjectRelatedLineNumber = lineNumber;
                } else if (tokens.length == 5 && tokens[0].equalsIgnoreCase(""player:"")) {
                    ldata.playerx = Integer.parseInt(tokens[2]);
                    ldata.playery = Integer.parseInt(tokens[4]);
                } else if (tokens.length == 3 && (tokens[0].equalsIgnoreCase(""time"") && tokens[1].equalsIgnoreCase(""limit:""))) {
                    ldata.timeLimit = Integer.parseInt(tokens[2]);
                } else if (tokens.length == 3 && (tokens[0].equalsIgnoreCase(""game"") && tokens[1].equalsIgnoreCase(""tune:""))) {
                    ldata.musicFilename = tokens[2];
                } else if (tokens.length == 3 && (tokens[0].equalsIgnoreCase(""key"") && tokens[1].equalsIgnoreCase(""limit:""))) {
                    ldata.keyLimit = Integer.parseInt(tokens[2]);
                } else if (tokens.length >= 2 && (tokens[0].equalsIgnoreCase(""subject"") && tokens[1].equalsIgnoreCase(""weights:""))) {
                    int[] subjWeights = new int[tokens.length - 2];
                    for (int i = 0; i < subjWeights.length; i++) {
                        subjWeights[i] = Integer.parseInt(tokens[i + 2]);
                    }
                    ldata.subjectWeights = subjWeights;
                    lastSubjectRelatedLineNumber = lineNumber;
                } else if (tokens.length == 4 && (tokens[0].equalsIgnoreCase(""degree"") && tokens[1].equalsIgnoreCase(""of"") && tokens[2].equalsIgnoreCase(""difficulty:""))) {
                    ldata.difficultyLevel = Integer.parseInt(tokens[3]);
                } else if (tokens.length == 6 && (tokens[0].equalsIgnoreCase(""distribution"") && tokens[1].equalsIgnoreCase(""of"") && tokens[2].equalsIgnoreCase(""boxes:""))) {
                    int[] parts = new int[3];
                    ldata.questionBoxPercentage = Float.parseFloat(tokens[3]);
                    ldata.pointsBoxPercentage = Float.parseFloat(tokens[4]);
                    ldata.heartBoxPercentage = Float.parseFloat(tokens[5]);
                    if ((ldata.questionBoxPercentage + ldata.pointsBoxPercentage + ldata.heartBoxPercentage) != 100.0) throw new BadLevelDataException(lineNumber);
                } else if (tokens.length == 3 && (tokens[0].equalsIgnoreCase(""force"") && tokens[1].equalsIgnoreCase(""limit:""))) {
                    ldata.forceLimit = Integer.parseInt(tokens[2]);
                } else if (tokens.length == 3 && (tokens[0].equalsIgnoreCase(""force"") && tokens[1].equalsIgnoreCase(""interval:""))) {
                    ldata.forceInterval = Integer.parseInt(tokens[2]);
                } else if (tokens.length == 3 && (tokens[0].equalsIgnoreCase(""background"") && tokens[1].equalsIgnoreCase(""image:""))) {
                    ldata.backgroundImage = tokens[2];
                } else {
                    System.err.println(""tokens.length = "" + tokens.length);
                    for (String s : tokens) System.err.println(""  "" + s);
                    throw new BadLevelDataException(lineNumber);
                }
            }
            if ((ldata.subjectWeights != null && ldata.subjectWeights != null) && (ldata.subjectWeights.length != ldata.subjectWeights.length)) throw new BadLevelDataException(lastSubjectRelatedLineNumber);
            ldata.entries = entries.toArray(new ObjectEntry[entries.size()]);
            return ldata;
        } catch (NumberFormatException nfe) {
            throw new BadLevelDataException(lineNumber);
        } catch (IOException nfe) {
            throw new BadLevelDataException(lineNumber);
        }
    }
"
8452,12767963,7,"    protected double remove(double element) {
        int index = insertionPoint(element);
        double value = getMembership(element);
        if ((index > 0 && support[index] == element) || (index <= 0 && support[0] == element)) {
            for (int i = index; i < size - 1; i++) {
                support[i] = support[i + 1];
                membership[i] = membership[i + 1];
            }
            size--;
        }
        return value;
    }
"
8839,13381059,7,"    public static void main(String[] args) throws Exception {
        if (args == null || args.length < 1) {
            System.err.println(""Usage: java gnu.beanfactory.Startup [class|url] [args...]"");
            System.err.println();
            return;
        }
        String target = args[0];
        String[] shifted = new String[args.length - 1];
        for (int i = 0; i < args.length - 1; i++) {
            shifted[i] = args[i + 1];
        }
        if (target.startsWith(""bean:"")) {
            execRunnableBean(target, shifted);
        } else {
            initializeAndInvokeMain(target, shifted);
        }
    }
"
7583,10313321,7,"    public Expression inline(ApplyExp exp, InlineCalls walker, boolean argsInlined) {
        exp.walkArgs(walker, argsInlined);
        Expression[] args = exp.getArgs();
        int nargs = args.length;
        if (nargs < 2) return exp;
        nargs--;
        Expression proc = args[0];
        boolean procSafeForMultipleEvaluation = !proc.side_effects();
        Expression[] inits1 = new Expression[1];
        inits1[0] = proc;
        LetExp let1 = new LetExp(inits1);
        Declaration procDecl = let1.addDeclaration(""%proc"", Compilation.typeProcedure);
        procDecl.noteValue(args[0]);
        Expression[] inits2 = new Expression[1];
        LetExp let2 = new LetExp(inits2);
        let1.setBody(let2);
        LambdaExp lexp = new LambdaExp(collect ? nargs + 1 : nargs);
        inits2[0] = lexp;
        Declaration loopDecl = let2.addDeclaration(""%loop"");
        loopDecl.noteValue(lexp);
        Expression[] inits3 = new Expression[nargs];
        LetExp let3 = new LetExp(inits3);
        Declaration[] largs = new Declaration[nargs];
        Declaration[] pargs = new Declaration[nargs];
        IsEq isEq = Scheme.isEq;
        for (int i = 0; i < nargs; i++) {
            String argName = ""arg"" + i;
            largs[i] = lexp.addDeclaration(argName);
            pargs[i] = let3.addDeclaration(argName, Compilation.typePair);
            inits3[i] = new ReferenceExp(largs[i]);
            pargs[i].noteValue(inits3[i]);
        }
        Declaration resultDecl = collect ? lexp.addDeclaration(""result"") : null;
        Expression[] doArgs = new Expression[1 + nargs];
        Expression[] recArgs = new Expression[collect ? nargs + 1 : nargs];
        for (int i = 0; i < nargs; i++) {
            doArgs[i + 1] = walker.walkApplyOnly(SlotGet.makeGetField(new ReferenceExp(pargs[i]), ""car""));
            recArgs[i] = walker.walkApplyOnly(SlotGet.makeGetField(new ReferenceExp(pargs[i]), ""cdr""));
        }
        if (!procSafeForMultipleEvaluation) proc = new ReferenceExp(procDecl);
        doArgs[0] = proc;
        Expression doit = walker.walkApplyOnly(new ApplyExp(new ReferenceExp(applyFieldDecl), doArgs));
        Expression rec = walker.walkApplyOnly(new ApplyExp(new ReferenceExp(loopDecl), recArgs));
        if (collect) {
            Expression[] consArgs = new Expression[2];
            consArgs[0] = doit;
            consArgs[1] = new ReferenceExp(resultDecl);
            recArgs[nargs] = Invoke.makeInvokeStatic(Compilation.typePair, ""make"", consArgs);
            lexp.body = rec;
        } else {
            lexp.body = new BeginExp(doit, rec);
        }
        let3.setBody(lexp.body);
        lexp.body = let3;
        Expression[] initArgs = new Expression[collect ? nargs + 1 : nargs];
        QuoteExp empty = new QuoteExp(LList.Empty);
        for (int i = nargs; --i >= 0; ) {
            Expression[] compArgs = new Expression[2];
            compArgs[0] = new ReferenceExp(largs[i]);
            compArgs[1] = empty;
            Expression result = collect ? (Expression) new ReferenceExp(resultDecl) : (Expression) QuoteExp.voidExp;
            lexp.body = new IfExp(walker.walkApplyOnly(new ApplyExp(isEq, compArgs)), result, lexp.body);
            initArgs[i] = args[i + 1];
        }
        if (collect) initArgs[nargs] = empty;
        Expression body = walker.walkApplyOnly(new ApplyExp(new ReferenceExp(loopDecl), initArgs));
        if (collect) {
            Expression[] reverseArgs = new Expression[1];
            reverseArgs[0] = body;
            body = Invoke.makeInvokeStatic(Compilation.scmListType, ""reverseInPlace"", reverseArgs);
        }
        let2.setBody(body);
        if (procSafeForMultipleEvaluation) return let2; else return let1;
    }
"
2678,1981171,7,"    private VisADLineArray makeTrack(float[][] values) {
        float d, xd, yd;
        float x, y, z, x0, y0, x3, y3, x4, y4, x5, y5;
        float sscale = 0.75f * 0.15f;
        x = 0.0f;
        y = 0.0f;
        z = values[2][0];
        x5 = values[0][1] - values[0][0];
        y5 = values[1][1] - values[1][0];
        float xdir = x5 - x;
        float ydir = y5 - y;
        float dist = (float) Math.sqrt(xdir * xdir + ydir * ydir);
        x0 = xdir / dist;
        y0 = ydir / dist;
        int nv = 0;
        float[] vx = new float[NUM];
        float[] vy = new float[NUM];
        float[] vz = new float[NUM];
        int lenv = vx.length;
        vx[nv] = x;
        vy[nv] = y;
        vz[nv] = z;
        nv++;
        vx[nv] = x5;
        vy[nv] = y5;
        vz[nv] = z;
        nv++;
        xd = sscale * x0;
        yd = sscale * y0;
        x3 = x5 - 0.3f * (xd - yd);
        y3 = y5 - 0.3f * (yd + xd);
        x4 = x5 - 0.3f * (xd + yd);
        y4 = y5 - 0.3f * (yd - xd);
        vx[nv] = x5;
        vy[nv] = y5;
        vz[nv] = z;
        nv++;
        vx[nv] = x3;
        vy[nv] = y3;
        vz[nv] = z;
        nv++;
        vx[nv] = x5;
        vy[nv] = y5;
        vz[nv] = z;
        nv++;
        vx[nv] = x4;
        vy[nv] = y4;
        vz[nv] = z;
        nv++;
        float step = getStep(xdir, ydir);
        int nsteps = (int) (dist / step);
        if (nsteps < 1) nsteps = 1;
        int lim = (vx.length - nv) / (2 * NE);
        if (nsteps < 1) nsteps = 1;
        if (nsteps > lim) nsteps = lim;
        float xstep = xdir / nsteps;
        float ystep = ydir / nsteps;
        boolean[] outside = new boolean[NE + 1];
        for (int i = 0; i < NE + 1; i++) {
            float xs = x_ellipse[i] + xstep;
            float ys = y_ellipse[i] + ystep;
            float radius = getStep(xs, ys);
            float len = (float) Math.sqrt(xs * xs + ys * ys);
            outside[i] = (len > radius);
        }
        float[] xe = new float[2 * NE];
        float[] ye = new float[2 * NE];
        int ne = 0;
        for (int i = 0; i < NE; i++) {
            if (outside[i] && outside[i + 1]) {
                xe[ne] = x_ellipse[i];
                ye[ne] = y_ellipse[i];
                ne++;
                xe[ne] = x_ellipse[i + 1];
                ye[ne] = y_ellipse[i + 1];
                ne++;
            }
        }
        float xcenter = x;
        float ycenter = y;
        for (int i = 0; i < NE; i++) {
            vx[nv] = x_ellipse[i];
            vy[nv] = y_ellipse[i];
            vz[nv] = z;
            nv++;
            vx[nv] = x_ellipse[i + 1];
            vy[nv] = y_ellipse[i + 1];
            vz[nv] = z;
            nv++;
        }
        for (int i = 0; i < nsteps; i++) {
            xcenter += xstep;
            ycenter += ystep;
            for (int j = 0; j < ne; j++) {
                vx[nv] = xcenter + xe[j];
                vy[nv] = ycenter + ye[j];
                vz[nv] = z;
                nv++;
            }
        }
        VisADLineArray array = new VisADLineArray();
        array.vertexCount = nv;
        float[] coordinates = new float[3 * nv];
        int m = 0;
        for (int i = 0; i < nv; i++) {
            coordinates[m++] = vx[i];
            coordinates[m++] = vy[i];
            coordinates[m++] = vz[i];
        }
        array.coordinates = coordinates;
        return array;
    }
"
7944,11327460,7,"    private String readString(InputStream input) throws IOException, EOFException {
        int length = EndianUtils.readSwappedUnsignedShort(input);
        length *= 2;
        byte[] data = new byte[length];
        int read = input.read(data);
        if (read != length) throw new EOFException(""Unexpected end of file"");
        for (int i = 0; i < length; i += 2) {
            byte x = data[i];
            data[i] = data[i + 1];
            data[i + 1] = x;
        }
        return new String(data, ""UTF-16"");
    }
"
2150,1214682,7,"    public RPoint[] getSideHandles(int s) {
        RPoint[] sideHandles;
        sideHandles = new RPoint[2];
        if (s != -1) {
            sideHandles[0] = handles[s];
            sideHandles[1] = handles[s + 1];
        }
        return sideHandles;
    }
"
9962,14966556,7,"    public void removeMidiInputListener(MidiNoteListener m) {
        for (int i = 0; i < mnolCount; i++) {
            if (mnol[i] == m) {
                mnol[i] = mnol[i + 1];
                m = mnol[i];
            }
        }
        milCount--;
    }
"
10417,15891740,7,"    public void setAwtRasterPalette(WritableRaster raster, IPalette palette) {
        m_src_index_color_raster = raster;
        if (palette != null) {
            try {
                byte[] colors = palette.getIndexColors();
                int color_count = palette.getIndexColorCount();
                int transparent_color_index = palette.getTransparentColorIndex();
                byte[] ra = new byte[color_count];
                byte[] ga = new byte[color_count];
                byte[] ba = new byte[color_count];
                byte[] ralpha = new byte[color_count];
                for (int i = 0, j = 0; (i < colors.length) && (j < color_count); i += 3, ++j) {
                    ra[j] = colors[i];
                    ga[j] = colors[i + 1];
                    ba[j] = colors[i + 2];
                    ralpha[j] = (byte) ((j == transparent_color_index) ? 0 : 255);
                }
                IndexColorModel icm = new IndexColorModel(8, color_count, ra, ga, ba, ralpha);
                BufferedImage new_image = new BufferedImage(icm, m_src_index_color_raster, icm.isAlphaPremultiplied(), null);
                m_image = createBuffer(new_image);
            } catch (Exception exp) {
                exp.printStackTrace();
            }
        }
    }
"
2662,1972366,7,"    public static byte[] shiftLeft(final byte[] data, final int bits) {
        if (bits <= 0) {
            return data;
        }
        int d = 0;
        if (data.length == 1) {
            if (bits <= 8) {
                d = data[0] & 0xFF;
                d <<= bits;
                data[0] = (byte) d;
            } else {
                data[0] = 0;
            }
        } else if (data.length > 1) {
            int carry = 0;
            if (bits < 8) {
                for (int i = 0; i < data.length - 1; ++i) {
                    carry = data[i + 1] & (1 >>> (8 - bits));
                    d = data[i] & 0xFF;
                    d <<= bits;
                    d |= carry;
                    data[i] = (byte) d;
                }
                d = data[data.length - 1] & 0xFF;
                d <<= bits;
                data[data.length - 1] = (byte) d;
            } else {
                for (int i = 0; i < data.length - 1; ++i) {
                    data[i] = data[i + 1];
                }
                data[data.length - 1] = 0;
                shiftLeft(data, bits - 8);
            }
        }
        return data;
    }
"
11009,16852192,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = 0;
        } else items[0] = 0;
        current_item--;
    }
"
6569,8379914,7,"    private TriangleMesh triangulateCurve() {
        Vec3 v[] = new Vec3[vertex.length], size = getBounds().getSize();
        Vec2 v2[] = new Vec2[vertex.length];
        int i, j, current, count, min;
        int index[] = new int[vertex.length], faces[][] = new int[vertex.length - 2][3];
        double dir, dir2;
        boolean inside;
        if (size.x > size.y) {
            if (size.y > size.z) j = 2; else j = 1;
        } else {
            if (size.x > size.z) j = 2; else j = 0;
        }
        for (i = 0; i < vertex.length; i++) {
            v[i] = vertex[i].r;
            v2[i] = vertex[i].r.dropAxis(j);
        }
        min = 0;
        for (i = 1; i < v2.length; i++) {
            if (v2[i].x < v2[min].x) min = i;
        }
        for (i = 0; i < index.length; i++) index[i] = i;
        current = min;
        do {
            dir = triangleDirection(v2, index, v2.length, current);
            if (dir == 0.0) {
                current = (current + 1) % index.length;
                if (current == min) return null;
            }
        } while (dir == 0.0);
        count = index.length;
        for (i = 0; i < vertex.length - 2; i++) {
            j = current;
            do {
                dir2 = triangleDirection(v2, index, count, current);
                inside = containsPoints(v2, index, count, current);
                if (dir2 * dir < 0.0 || inside) {
                    current = (current + 1) % count;
                    if (current == j) return null;
                }
            } while (dir2 * dir < 0.0 || inside);
            if (current == 0) faces[i][0] = index[count - 1]; else faces[i][0] = index[current - 1];
            faces[i][1] = index[current];
            if (current == count - 1) faces[i][2] = index[0]; else faces[i][2] = index[current + 1];
            for (j = current; j < count - 1; j++) index[j] = index[j + 1];
            count--;
            current = (current + 1) % count;
        }
        TriangleMesh mesh = new TriangleMesh(v, faces);
        TriangleMesh.Vertex vert[] = (TriangleMesh.Vertex[]) mesh.getVertices();
        for (i = 0; i < vert.length; i++) vert[i].smoothness = smoothness[i];
        mesh.setSmoothingMethod(smoothingMethod);
        return mesh;
    }
"
8695,13224904,7,"    public void run(String[] args) {
        initLog4J(args);
        if (args.length < 1) {
            printGlobalUsage();
        }
        String commandName = args[0];
        String[] newArgs = new String[args.length - 1];
        for (int i = 0; i < args.length - 1; i++) {
            newArgs[i] = args[i + 1];
        }
        CommandProcessor commandProcessor = null;
        try {
            commandProcessor = new CommandProcessor(commandName);
            commandProcessor.init(newArgs);
            String result = commandProcessor.execute();
            System.out.println(result);
            System.exit(0);
        } catch (HelpRequiredException e) {
            commandProcessor.getCommand().printUsage();
            System.exit(0);
        } catch (IllegalArgumentException e) {
            System.err.println(""[ERROR] : "" + e.getMessage());
            if ((commandProcessor != null) && (commandProcessor.getCommand() != null)) {
                commandProcessor.getCommand().printUsage();
            } else {
                printGlobalUsage();
            }
            System.exit(1);
        } catch (IOException e) {
            System.err.println(""Could not establish connection to VM via JMX : "");
            e.printStackTrace(System.err);
            System.exit(2);
        } catch (Throwable t) {
            System.err.println(""There occurred a very unexpected error:"");
            t.printStackTrace();
            System.exit(3);
        }
    }
"
7457,10089157,7,"    public static double compute(final Evaluator F, final double a, final double b, final int nstart, final double eps, final int maxiter) throws ConstructionException {
        final double t[] = new double[maxiter];
        int n = nstart;
        double h = (b - a) / n;
        double tlast = t[0] = (F.evaluateF(a) + F.evaluateF(b) + 2 * sumUp(F, a + h, h, n - 2)) * h / 2;
        double old = t[0];
        for (int i = 1; i < maxiter; i++) {
            h = h / 2;
            n = n * 2;
            t[i] = tlast / 2 + sumUp(F, a + h, 2 * h, n / 2 - 1) * h;
            tlast = t[i];
            double q = 4;
            for (int j = i - 1; j >= 0; j--) {
                t[j] = t[j + 1] + (t[j + 1] - t[j]) / (q - 1);
                q = q * 4;
            }
            final double res = t[0];
            if (Math.abs((res - old) / res) < eps) return res;
            old = res;
        }
        return tlast;
    }
"
4342,4948726,7,"    @Override
    public void reload() {
        final TridiagonalOperator L = new TridiagonalOperator(n);
        Array tmp = new Array(n);
        final double[] dx = new double[n];
        final double[] S = new double[n];
        int i = 0;
        dx[i] = vx[i + 1] - vx[i];
        S[i] = (vy[i + 1] - vy[i]) / dx[i];
        for (i = 1; i < n - 1; i++) {
            dx[i] = vx[i + 1] - vx[i];
            S[i] = (vy[i + 1] - vy[i]) / dx[i];
            L.setMidRow(i, dx[i], 2.0 * (dx[i] + dx[i - 1]), dx[i - 1]);
            tmp.set(i, 3.0 * (dx[i] * S[i - 1] + dx[i - 1] * S[i]));
        }
        switch(leftType) {
            case NotAKnot:
                L.setFirstRow(dx[1] * (dx[1] + dx[0]), (dx[0] + dx[1]) * (dx[0] + dx[1]));
                tmp.set(0, S[0] * dx[1] * (2.0 * dx[1] + 3.0 * dx[0]) + S[1] * dx[0] * dx[0]);
                break;
            case FirstDerivative:
                L.setFirstRow(1.0, 0.0);
                tmp.set(0, leftValue);
                break;
            case SecondDerivative:
                L.setFirstRow(2.0, 1.0);
                tmp.set(0, 3.0 * S[0] - leftValue * dx[0] / 2.0);
                break;
            case Periodic:
            case Lagrange:
                throw new UnsupportedOperationException(""this end condition is not implemented yet"");
            default:
                throw new UnsupportedOperationException(""unknown end condition"");
        }
        switch(rightType) {
            case NotAKnot:
                L.setLastRow(-(dx[n - 2] + dx[n - 3]) * (dx[n - 2] + dx[n - 3]), -dx[n - 3] * (dx[n - 3] + dx[n - 2]));
                tmp.set(n - 1, -S[n - 3] * dx[n - 2] * dx[n - 2] - S[n - 2] * dx[n - 3] * (3.0 * dx[n - 2] + 2.0 * dx[n - 3]));
                break;
            case FirstDerivative:
                L.setLastRow(0.0, 1.0);
                tmp.set(n - 1, rightValue);
                break;
            case SecondDerivative:
                L.setLastRow(1.0, 2.0);
                tmp.set(n - 1, 3.0 * S[n - 2] + rightValue * dx[n - 2] / 2.0);
                break;
            case Periodic:
            case Lagrange:
                throw new UnsupportedOperationException(""this end condition is not implemented yet"");
            default:
                throw new UnsupportedOperationException(""unknown end condition"");
        }
        tmp = L.solveFor(tmp);
        if (constrained) {
            double correction;
            double pm, pu, pd, M;
            for (i = 0; i < n; i++) {
                if (i == 0) {
                    if (tmp.get(i) * S[0] > 0.0) {
                        correction = tmp.get(i) / Math.abs(tmp.get(i)) * Math.min(Math.abs(tmp.get(i)), Math.abs(3.0 * S[0]));
                    } else {
                        correction = 0.0;
                    }
                    if (!Closeness.isClose(correction, tmp.get(i))) {
                        tmp.set(i, correction);
                        monotone = true;
                    }
                } else if (i == n - 1) {
                    if (tmp.get(i) * S[n - 2] > 0.0) {
                        correction = tmp.get(i) / Math.abs(tmp.get(i)) * Math.min(Math.abs(tmp.get(i)), Math.abs(3.0 * S[n - 2]));
                    } else {
                        correction = 0.0;
                    }
                    if (!Closeness.isClose(correction, tmp.get(i))) {
                        tmp.set(i, correction);
                        monotone = true;
                    }
                } else {
                    pm = (S[i - 1] * dx[i] + S[i] * dx[i - 1]) / (dx[i - 1] + dx[i]);
                    M = 3.0 * Math.min(Math.min(Math.abs(S[i - 1]), Math.abs(S[i])), Math.abs(pm));
                    if (i > 1) {
                        if ((S[i - 1] - S[i - 2]) * (S[i] - S[i - 1]) > 0.0) {
                            pd = (S[i - 1] * (2.0 * dx[i - 1] + dx[i - 2]) - S[i - 2] * dx[i - 1]) / (dx[i - 2] + dx[i - 1]);
                            if (pm * pd > 0.0 && pm * (S[i - 1] - S[i - 2]) > 0.0) {
                                M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pd)));
                            }
                        }
                    }
                    if (i < n - 2) {
                        if ((S[i] - S[i - 1]) * (S[i + 1] - S[i]) > 0.0) {
                            pu = (S[i] * (2.0 * dx[i] + dx[i + 1]) - S[i + 1] * dx[i]) / (dx[i] + dx[i + 1]);
                            if (pm * pu > 0.0 && -pm * (S[i] - S[i - 1]) > 0.0) {
                                M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pu)));
                            }
                        }
                    }
                    if (tmp.get(i) * pm > 0.0) {
                        correction = tmp.get(i) / Math.abs(tmp.get(i)) * Math.min(Math.abs(tmp.get(i)), M);
                    } else {
                        correction = 0.0;
                    }
                    if (!Closeness.isClose(correction, tmp.get(i))) {
                        tmp.set(i, correction);
                        monotone = true;
                    }
                }
            }
        }
        for (i = 0; i < n - 1; i++) {
            va[i] = tmp.get(i);
            vb[i] = (3.0 * S[i] - tmp.get(i + 1) - 2.0 * tmp.get(i)) / dx[i];
            vc[i] = (tmp.get(i + 1) + tmp.get(i) - 2.0 * S[i]) / (dx[i] * dx[i]);
        }
        vp[0] = 0.0;
        for (i = 1; i < n - 1; i++) {
            vp[i] = vp[i - 1] + dx[i - 1] * (vy[i - 1] + dx[i - 1] * (va[i - 1] / 2.0 + dx[i - 1] * (vb[i - 1] / 3.0 + dx[i - 1] * vc[i - 1] / 4.0)));
        }
    }
"
4355,4997927,7,"    private char shiftAndAppend(char[] buffer, char c) {
        char shifted = buffer[0];
        for (int i = 0; i + 1 < buffer.length; i++) {
            buffer[i] = buffer[i + 1];
        }
        buffer[buffer.length - 1] = c;
        return shifted;
    }
"
1087,518518,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
2271,1336659,7,"    public static Object financialNpv(Object[] args, XelContext ctx) {
        double[] d = UtilFns.toDoubleArray(UtilFns.toList(args, ctx));
        double[] values = new double[d.length - 1];
        for (int i = 0; i < values.length; i++) {
            values[i] = d[i + 1];
        }
        double result = npv(d[0], values);
        return new Double(result);
    }
"
6105,7762106,7,"    @Override
    public void unpack(ByteBuffer b) throws IOException {
        b.position(0);
        b.order(ByteOrder.LITTLE_ENDIAN);
        this.width = b.getShort();
        this.height = b.getShort();
        this.leftoffset = b.getShort();
        this.topoffset = b.getShort();
        this.columnofs = new int[this.width];
        this.columns = new column_t[this.width];
        C2JUtils.initArrayOfObjects(this.columns, column_t.class);
        int[] actualsizes = new int[columns.length];
        for (int i = 0; i < actualsizes.length - 1; i++) {
            actualsizes[i] = columnofs[i + 1] - columnofs[i];
        }
        DoomBuffer.readIntArray(b, this.columnofs, this.columnofs.length);
        for (int i = 0; i < this.width; i++) {
            b.position(this.columnofs[i]);
            try {
                this.columns[i].unpack(b);
            } catch (Exception e) {
                if (i == 0) this.columns[i] = getBadColumn(this.height); else this.columns[i] = this.columns[i - 1];
            }
        }
    }
"
3045,2477024,7,"        public List<Node> neighbours() {
            List<Node> neighbours = new ArrayList<Node>();
            for (int i = 0; i < rows.length - 1; i++) {
                int[] newrows = Arrays.copyOf(rows, rows.length);
                int temp = newrows[i];
                newrows[i] = newrows[i + 1];
                newrows[i + 1] = temp;
                neighbours.add(getNode(newrows));
            }
            return neighbours;
        }
"
10999,16820984,7,"    private static int[] addIndex(final int[] indexes, final int newIndex, final boolean excludeFirstIndex) {
        int[] newIndices = null;
        if (excludeFirstIndex) {
            newIndices = new int[indexes.length];
            for (int i = 0, z = indexes.length - 1; i < z; i++) {
                newIndices[i] = indexes[i + 1];
            }
        } else {
            newIndices = new int[indexes.length + 1];
            for (int i = 0, z = indexes.length; i < z; i++) {
                newIndices[i] = indexes[i];
            }
        }
        newIndices[newIndices.length - 1] = newIndex;
        return newIndices;
    }
"
9513,14273804,7,"    public void cmdProc(Interp interp, TclObject[] objv) throws TclException {
        if (objv.length < 4 || (objv.length % 2) != 0) {
            throw new TclNumArgsException(interp, 1, objv, ""varList list ?varList list ...? command"");
        }
        TclObject[] name = new TclObject[(objv.length - 2) / 2];
        TclObject[] value = new TclObject[(objv.length - 2) / 2];
        int c, i, j, base;
        int maxIter = 0;
        TclObject command = objv[objv.length - 1];
        boolean done = false;
        for (i = 0; i < objv.length - 2; i += 2) {
            int x = i / 2;
            name[x] = objv[i + 1];
            value[x] = objv[i + 2];
            int nSize = TclList.getLength(interp, name[x]);
            int vSize = TclList.getLength(interp, value[x]);
            if (nSize == 0) {
                throw new TclException(interp, ""foreach varlist is empty"");
            }
            int iter = (vSize + nSize - 1) / nSize;
            if (maxIter < iter) {
                maxIter = iter;
            }
        }
        for (c = 0; !done && c < maxIter; c++) {
            for (i = 0; i < objv.length - 2; i += 2) {
                int x = i / 2;
                int nSize = TclList.getLength(interp, name[x]);
                base = nSize * c;
                for (j = 0; j < nSize; j++) {
                    try {
                        if (base + j >= TclList.getLength(interp, value[x])) {
                            interp.setVar(TclList.index(interp, name[x], j), TclString.newInstance(""""), 0);
                        } else {
                            interp.setVar(TclList.index(interp, name[x], j), TclList.index(interp, value[x], base + j), 0);
                        }
                    } catch (TclException e) {
                        throw new TclException(interp, ""couldn't set loop variable: \"""" + TclList.index(interp, name[x], j) + ""\"""");
                    }
                }
            }
            try {
                interp.eval(command, 0);
            } catch (TclException e) {
                switch(e.getCompletionCode()) {
                    case TCL.BREAK:
                        done = true;
                        break;
                    case TCL.CONTINUE:
                        continue;
                    case TCL.ERROR:
                        interp.addErrorInfo(""\n    (\""foreach\"" body line "" + interp.errorLine + "")"");
                        throw e;
                    default:
                        throw e;
                }
            }
        }
        interp.resetResult();
    }
"
542,222982,7,"    public void removerLinha(int row) {
        for (int i = row; i < 1023; i++) {
            memoria[i] = memoria[i + 1];
            instrucao[i] = instrucao[i + 1];
        }
        memoria[1023] = 0;
        instrucao[1023] = """";
    }
"
9843,14665368,7,"    void removeConnectionByIndex(int index) {
        --nConnected;
        for (int i = index; i < nConnected; ++i) {
            connected[i] = connected[i + 1];
        }
    }
"
8794,13358170,7,"    public void put(GML gmlNew, int cursor) {
        if (intPointer < CAPACITY - 1) {
            intPointer++;
            vctGMLs.add(intPointer, gmlNew.clone());
            cursors[intPointer] = cursor;
            if ((vctGMLs.lastElement() != null) && (!vctGMLs.lastElement().equals(gmlNew))) {
                while (vctGMLs.size() > intPointer + 1) vctGMLs.removeElementAt(intPointer + 1);
                for (int i = intPointer + 1; i < cursors.length; i++) cursors[i] = -1;
            }
        } else {
            vctGMLs.remove(0);
            for (int i = 0; i < cursors.length - 1; i++) {
                cursors[i] = cursors[i + 1];
            }
            vctGMLs.add(gmlNew.clone());
            cursors[intPointer] = cursor;
        }
    }
"
1393,657257,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
"
383,13913361,13,"    @Override
    public void crossover(AttributeWeightedExampleSet es1, AttributeWeightedExampleSet es2) {
        LinkedList<AttributeWeightContainer> dummyList1 = new LinkedList<AttributeWeightContainer>();
        LinkedList<AttributeWeightContainer> dummyList2 = new LinkedList<AttributeWeightContainer>();
        int maxSize = Math.max(es1.getAttributes().size(), es2.getAttributes().size());
        if (maxSize < 2) return;
        switch(getType()) {
            case SelectionCrossover.ONE_POINT:
                int splitPoint = 1 + random.nextInt(maxSize - 2);
                Iterator<Attribute> it = es1.getAttributes().iterator();
                int counter = 0;
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (counter > splitPoint) {
                        double weight = es1.getWeight(attribute);
                        it.remove();
                        dummyList1.add(new AttributeWeightContainer(attribute, weight));
                    }
                    counter++;
                }
                it = es2.getAttributes().iterator();
                counter = 0;
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (counter > splitPoint) {
                        double weight = es2.getWeight(attribute);
                        it.remove();
                        dummyList2.add(new AttributeWeightContainer(attribute, weight));
                    }
                    counter++;
                }
                break;
            case SelectionCrossover.UNIFORM:
                it = es1.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextBoolean()) {
                        double weight = es1.getWeight(attribute);
                        dummyList1.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                it = es2.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextBoolean()) {
                        double weight = es2.getWeight(attribute);
                        dummyList2.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                break;
            case SelectionCrossover.SHUFFLE:
                double prob1 = (double) (random.nextInt(es1.getAttributes().size() - 1) + 1) / (double) es1.getAttributes().size();
                it = es1.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextDouble() < prob1) {
                        double weight = es1.getWeight(attribute);
                        dummyList1.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                double prob2 = (double) (random.nextInt(es2.getAttributes().size() - 1) + 1) / (double) es2.getAttributes().size();
                it = es2.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextDouble() < prob2) {
                        double weight = es2.getWeight(attribute);
                        dummyList2.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                break;
            default:
                break;
        }
        mergeAttributes(es1, dummyList2);
        mergeAttributes(es2, dummyList1);
    }
"
422,15375607,13,"    public Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
90,3290612,13,"    private static Color getRandomColor(int minColor, int maxColor) {
        Random random = new Random();
        int red = minColor + random.nextInt(maxColor - minColor);
        int green = minColor + random.nextInt(maxColor - minColor);
        int blue = minColor + random.nextInt(maxColor - minColor);
        return new Color(red, green, blue);
    }
"
472,18357814,13,"        void reset(Random random) {
            rfqAverageNumber = rfqAvgMin + random.nextInt(rfqAvgMax - rfqAvgMin);
        }
"
523,20387184,13,"    private void testListIterator(BitVector v) {
        int size = v.size();
        final BitVector w = new BitVector(size);
        ListIterator<Boolean> i = v.listIterator();
        while (i.hasNext()) {
            w.setBit(i.nextIndex(), i.next());
        }
        assertEquals(v, w);
        final BitVector x = new BitVector(size);
        i = v.listIterator(size);
        while (i.hasPrevious()) {
            x.setBit(i.previousIndex(), i.previous());
        }
        assertEquals(v, x);
        final int a = random.nextInt(size + 1);
        i = v.listIterator(a);
        if (a == size) {
            assertEquals(-1, i.nextIndex());
        } else {
            assertEquals(a, i.nextIndex());
            assertEquals(v.getBit(a), i.next().booleanValue());
        }
        i = v.listIterator(a);
        if (a == 0) {
            assertEquals(-1, i.previousIndex());
        } else {
            assertEquals(a - 1, i.previousIndex());
            assertEquals(v.getBit(a - 1), i.previous().booleanValue());
        }
    }
"
304,10829219,13,"    public Object newValue(Random random) {
        if (random.nextBoolean()) {
            return null;
        }
        StringBuilder strBuilder = new StringBuilder();
        int remainingLength = minLength + random.nextInt(maxLength - minLength);
        boolean endsWithPunctuation = random.nextBoolean();
        if (endsWithPunctuation) {
            remainingLength--;
        }
        String word = getWord(remainingLength, random);
        strBuilder.append(word);
        remainingLength -= word.length();
        while (remainingLength > 1) {
            strBuilder.append(getChar(midPunctuation, random));
            remainingLength--;
            word = getWord(remainingLength, random);
            strBuilder.append(word);
            remainingLength -= word.length();
        }
        if (endsWithPunctuation) {
            strBuilder.append(getChar(endPunctuation, random));
        }
        return strBuilder.toString();
    }
"
110,4409384,13,"        public static <T> int randomizedPartition(T[] array, int startIndex, int endIndex, Comparator<T> comparator) {
            int i = startIndex + random.nextInt(endIndex - startIndex);
            swap(array, i, startIndex);
            return partition(array, startIndex, endIndex, comparator);
        }
"
261,9479943,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
132,5037656,13,"    public static TuringMachine generateTestTuringMachine(char startChar, Random random, int maxCountArray, int maxCountTransition, boolean finiteAutomate, String alphabetIT, String alphabetWT, int maxLengthIT, int maxLengthWT) {
        int lengthIT = random.nextInt(maxLengthIT);
        int lengthWT = random.nextInt(maxLengthWT);
        int ItHead = random.nextInt(lengthIT + 2);
        int WtHead = random.nextInt(lengthWT + 1);
        return generateTestTuringMachine(startChar, new Random(), maxCountArray, maxCountTransition, finiteAutomate, alphabetIT, alphabetWT, lengthIT, lengthWT, ItHead, WtHead);
    }
"
360,12834346,13,"    private static Color getRandColor(int cc, int bb) {
        Random random = new Random();
        if (cc > 255) cc = 255;
        if (bb > 255) bb = 255;
        int r = cc + random.nextInt(bb - cc);
        int g = cc + random.nextInt(bb - cc);
        int b = cc + random.nextInt(bb - cc);
        return new Color(r, g, b);
    }
"
543,21516361,13,"    private void updateDirection() {
        this.direction = random.nextInt(DOWN + 1);
    }
"
70,2884218,13,"    public static XTrace createTrace(int minLength, int maxLength) {
        XTrace trace = factory.createTrace();
        addAttributes(trace, 0.9, 3, 50);
        int length = minLength + random.nextInt(maxLength - minLength);
        for (int i = 0; i < length; i++) {
            trace.add(createEvent());
        }
        NUM_TRACES++;
        return trace;
    }
"
566,22513684,13,"    public static int[] calculateMetals(Solar planet, Random rng) {
        int[] deposits = new int[PlanetResources.Metals.values().length];
        switch(planet.ptype) {
            case BARE_ROCK:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(400) / 100;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(400) / 100;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(200) / 100;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Zinc.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Iron.ordinal()] = rng.nextInt(600) / 100;
                deposits[PlanetResources.Metals.Nickel.ordinal()] = rng.nextInt(500) / 100;
                deposits[PlanetResources.Metals.Mercury.ordinal()] = rng.nextInt(120) / 100;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(101) / 100;
                break;
            case ATM_ROCK:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(250) / 100;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(130) / 100;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(201) / 100;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(330) / 100;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(180) / 100;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(210) / 100;
                deposits[PlanetResources.Metals.Zinc.ordinal()] = rng.nextInt(210) / 100;
                deposits[PlanetResources.Metals.Iron.ordinal()] = rng.nextInt(250) / 100;
                deposits[PlanetResources.Metals.Nickel.ordinal()] = rng.nextInt(250) / 100;
                deposits[PlanetResources.Metals.Mercury.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(101) / 100;
                break;
            case CLOUD:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(200) / 100;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(200) / 100;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(170) / 100;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Zinc.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Iron.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Nickel.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Mercury.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(101) / 100;
                break;
            case EARTH:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = 0;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(12) / 5;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(6) / 5;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(12) / 5;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(6) / 5;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(6) / 5;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(8) / 5;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(12) / 5;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(101) / 100;
                break;
            case ICE:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(201) / 200;
                break;
            default:
        }
        final int promotionFactor = calculateRichness(planet);
        for (int i = 0; i < deposits.length; i++) {
            if (deposits[i] != 0) {
                int rich = rng.nextInt(promotionFactor + 1);
                rich += deposits[i] - 1;
                deposits[i] = rich;
            }
        }
        return deposits;
    }
"
184,6501588,13,"    private Color getRandColor(int fc, int bc) {
        int fc_a = fc;
        int bc_a = bc;
        Random random = new Random();
        if (fc > 255) fc_a = 255;
        if (bc > 255) bc_a = 255;
        int r = fc + random.nextInt(bc_a - fc_a);
        int g = fc + random.nextInt(bc_a - fc_a);
        int b = fc + random.nextInt(bc_a - fc_a);
        return new Color(r, g, b);
    }
"
231,8682225,13,"    @Test
    public void testGrabPixelsWhileRunning() throws IOException, BoblightException {
        final Random random = new Random();
        final int scrWidth = SCREEN_WIDTH_MIN + random.nextInt(SCREEN_WIDTH_MAX - SCREEN_WIDTH_MIN);
        final int scrHeight = SCREEN_HEIGHT_MIN + random.nextInt(SCREEN_HEIGHT_MAX - SCREEN_HEIGHT_MIN);
        testable = spy(new AbstractActiveGrabber(client, false, 100, 80) {

            @Override
            public int[] grabPixelAt(int xpos, int ypos) {
                return null;
            }

            @Override
            protected void updateDimensions() {
            }

            @Override
            protected int getScreenWidth() {
                return scrWidth;
            }

            @Override
            protected int getScreenHeight() {
                return scrHeight;
            }

            @Override
            public void setup(FlagManager flagManager) throws BoblightException {
            }

            @Override
            public void cleanup() {
            }
        });
        int size = 2 + random.nextInt(64 - 2);
        Whitebox.setInternalState(testable, ""width"", size);
        Whitebox.setInternalState(testable, ""height"", size);
        doAnswer(new Answer<Object>() {

            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                Whitebox.setInternalState(testable, ""stop"", true);
                return null;
            }
        }).when(client).sendRgb(false, null);
        System.out.println(""Starting test method."");
        testable.run();
        double cellWidth = (double) scrWidth / (double) size;
        double cellHeight = (double) scrHeight / size;
        System.out.println(""Starting verification."");
        for (int width = 0; width < size; width++) {
            for (int height = 0; height < size; height++) {
                final int xpos = (int) (cellWidth / 2 + cellWidth * width);
                final int ypos = (int) (cellHeight / 2 + cellHeight * height);
                verify(testable).grabPixelAt(xpos, ypos);
            }
        }
    }
"
208,7899786,13,"    private int calcAge(AlbatrossPerson albatrossPerson) {
        int code = albatrossPerson.AGEP;
        int min = 0;
        int max = 0;
        if (code == 0) {
            min = 18;
            max = 35;
        } else if (code == 1) {
            min = 35;
            max = 55;
        } else if (code == 2) {
            min = 55;
            max = 65;
        } else if (code == 3) {
            min = 65;
            max = 75;
        } else if (code == 4) {
            min = 75;
            max = 100;
        }
        int age = min + random.nextInt(max - min);
        return age;
    }
"
104,4301141,13,"    private static Color getRandColor(int color1, int color2) {
        Random random = new Random();
        if (color1 > 255) color1 = 255;
        if (color2 > 255) color2 = 255;
        int r = color1 + random.nextInt(color2 - color1);
        int g = color1 + random.nextInt(color2 - color1);
        int b = color1 + random.nextInt(color2 - color1);
        return new Color(r, g, b);
    }
"
573,22801753,13,"    private void generateRoteRiese(Random rnd) {
        final int BIG = 30;
        final int NORMAL = 30;
        final int LITTLE = 30;
        int wert = rnd.nextInt(100) + 1;
        wert = wert - BIG;
        if (wert <= 0) {
            starclass = STAR_TYP_RIESE_0;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_R0 + 1);
            return;
        }
        wert = wert - NORMAL;
        if (wert <= 0) {
            starclass = STAR_TYP_RIESE_1;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_R1 + 1);
            return;
        }
        wert = wert - LITTLE;
        if (wert <= 0) {
            starclass = STAR_TYP_RIESE_2;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_R2 + 1);
            return;
        }
    }
"
181,6482417,13,"    private static String calc(String exp) {
        if (exp.startsWith(""random"")) {
            int beg = exp.indexOf(""("");
            int end = exp.indexOf("")"");
            String[] ss = exp.substring(beg + 1, end).split("","");
            int rb = Integer.parseInt(ss[0]);
            int re = Integer.parseInt(ss[1]);
            int rr = rb + random.nextInt(re - rb);
            return String.valueOf(rr);
        }
        return exp;
    }
"
355,12750603,13,"    protected void startKeepAliveTimer() {
        keep_alive_ticks = MIN_KEEPALIVE_TICKS + random.nextInt(MAX_KEEPALIVE_TICKS - MIN_KEEPALIVE_TICKS);
    }
"
2,479568,13,"    public DSoCService() {
        Random rand = new Random();
        int RandNum = rand.nextInt(MAX_NUMBER_OF_SES + 1);
        NUMBER_OF_SES = (RandNum < 3) ? 3 : RandNum;
        hx_SES = new SES[NUMBER_OF_SES];
        sx_SES = new SES[NUMBER_OF_SES];
        NumberFormat nf = NumberFormat.getInstance();
        nf.setMinimumIntegerDigits(4);
        nf.setMaximumIntegerDigits(4);
        str_Name = ""Service"" + nf.format((long) NameSec);
        NameSec++;
        init_SESs();
    }
"
556,21977662,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
493,19466131,13,"    private static Color getRandColor(int fc, int bc) {
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + RandomUtil.nextInt(bc - fc);
        int g = fc + RandomUtil.nextInt(bc - fc);
        int b = fc + RandomUtil.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
63,2801895,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        if (!m_dontReplaceMissing) {
            m_ReplaceMissingFilter.setInputFormat(instances);
            instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        }
        m_FullMissingCounts = new int[instances.numAttributes()];
        if (m_displayStdDevs) {
            m_FullStdDevs = new double[instances.numAttributes()];
        }
        m_FullNominalCounts = new int[instances.numAttributes()][0];
        m_FullMeansOrMediansOrModes = moveCentroid(0, instances, false);
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_FullMissingCounts[i] = instances.attributeStats(i).missingCount;
            if (instances.attribute(i).isNumeric()) {
                if (m_displayStdDevs) {
                    m_FullStdDevs[i] = Math.sqrt(instances.variance(i));
                }
                if (m_FullMissingCounts[i] == instances.numInstances()) {
                    m_FullMeansOrMediansOrModes[i] = Double.NaN;
                }
            } else {
                m_FullNominalCounts[i] = instances.attributeStats(i).nominalCounts;
                if (m_FullMissingCounts[i] > m_FullNominalCounts[i][Utils.maxIndex(m_FullNominalCounts[i])]) {
                    m_FullMeansOrMediansOrModes[i] = -1;
                }
            }
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        if (m_PreserveOrder) m_Assignments = clusterAssignments;
        m_DistanceFunction.setInstances(instances);
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        Instances initInstances = null;
        if (m_PreserveOrder) initInstances = new Instances(instances); else initInstances = instances;
        if (m_initializeWithKMeansPlusPlus) {
            kMeansPlusPlusInit(initInstances);
        } else {
            for (int j = initInstances.numInstances() - 1; j >= 0; j--) {
                instIndex = RandomO.nextInt(j + 1);
                hk = new DecisionTableHashKey(initInstances.instance(instIndex), initInstances.numAttributes(), true);
                if (!initC.containsKey(hk)) {
                    m_ClusterCentroids.add(initInstances.instance(instIndex));
                    initC.put(hk, null);
                }
                initInstances.swap(j, instIndex);
                if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                    break;
                }
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        initInstances = null;
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        m_ClusterMissingCounts = new int[m_NumClusters][instances.numAttributes()];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, false, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    moveCentroid(i, tempI[i], true);
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                if (converged) {
                    Instances[] t = new Instances[m_NumClusters];
                    int index = 0;
                    for (int k = 0; k < tempI.length; k++) {
                        if (tempI[k].numInstances() > 0) {
                            t[index++] = tempI[k];
                        }
                    }
                    tempI = t;
                } else {
                    tempI = new Instances[m_NumClusters];
                }
            }
            if (m_Iterations == m_MaxIterations) converged = true;
            if (!converged) {
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        if (!m_FastDistanceCalc) {
            for (i = 0; i < instances.numInstances(); i++) {
                clusterProcessedInstance(instances.instance(i), true, false);
            }
        }
        if (m_displayStdDevs) {
            m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        }
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            if (m_displayStdDevs) {
                double[] vals2 = new double[instances.numAttributes()];
                for (int j = 0; j < instances.numAttributes(); j++) {
                    if (instances.attribute(j).isNumeric()) {
                        vals2[j] = Math.sqrt(tempI[i].variance(j));
                    } else {
                        vals2[j] = Utils.missingValue();
                    }
                }
                m_ClusterStdDevs.add(new DenseInstance(1.0, vals2));
            }
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
"
55,2584059,13,"    public static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
580,23128478,13,"    public static InetSocketAddress getNewInetSocketAddressWithRandomPort(InetAddress addr) {
        int portNum = 1024 + random.nextInt(65535 - 1024);
        InetSocketAddress localAddr = new InetSocketAddress(addr, portNum);
        return localAddr;
    }
"
446,16914987,13,"    private static String getLikeDescription(int likeLow, int likeHigh) {
        int passnum = likeLow;
        if (likeHigh != -1) {
            passnum = likeLow + random.nextInt(likeHigh - likeLow);
        }
        return getPassenger(passnum).getDescription();
    }
"
29,1181594,13,"    public File generate(String rootName, String name) {
        File root = new File(rootName, name);
        if (root.exists()) {
            if (force) {
                FileSystemUtil.deleteDirR(root, FS);
            } else {
                System.out.printf(""%s: such folder already exists!"", root.getName());
                return null;
            }
        }
        int depth = random.nextInt(maxDepth + 1);
        generateDir(new File(rootName), name, depth);
        return root;
    }
"
155,5419710,13,"    public boolean batchFinished() throws Exception {
        Instances data = getInputFormat();
        if (data == null) throw new IllegalStateException(""No input instance format defined"");
        if (m_Converter == null) {
            int[] randomIndices = new int[m_ClassCounts.length];
            for (int i = 0; i < randomIndices.length; i++) {
                randomIndices[i] = i;
            }
            for (int j = randomIndices.length - 1; j > 0; j--) {
                int toSwap = m_Random.nextInt(j + 1);
                int tmpIndex = randomIndices[j];
                randomIndices[j] = randomIndices[toSwap];
                randomIndices[toSwap] = tmpIndex;
            }
            double[] randomizedCounts = new double[m_ClassCounts.length];
            for (int i = 0; i < randomizedCounts.length; i++) {
                randomizedCounts[i] = m_ClassCounts[randomIndices[i]];
            }
            if (m_ClassOrder == RANDOM) {
                m_Converter = randomIndices;
                m_ClassCounts = randomizedCounts;
            } else {
                int[] sorted = Utils.sort(randomizedCounts);
                m_Converter = new int[sorted.length];
                if (m_ClassOrder == FREQ_ASCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[i]];
                    }
                } else if (m_ClassOrder == FREQ_DESCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[sorted.length - i - 1]];
                    }
                } else {
                    throw new IllegalArgumentException(""Class order not defined!"");
                }
                double[] tmp2 = new double[m_ClassCounts.length];
                for (int i = 0; i < m_Converter.length; i++) {
                    tmp2[i] = m_ClassCounts[m_Converter[i]];
                }
                m_ClassCounts = tmp2;
            }
            FastVector values = new FastVector(data.classAttribute().numValues());
            for (int i = 0; i < data.numClasses(); i++) {
                values.addElement(data.classAttribute().value(m_Converter[i]));
            }
            FastVector newVec = new FastVector(data.numAttributes());
            for (int i = 0; i < data.numAttributes(); i++) {
                if (i == data.classIndex()) {
                    newVec.addElement(new Attribute(data.classAttribute().name(), values, data.classAttribute().getMetadata()));
                } else {
                    newVec.addElement(data.attribute(i));
                }
            }
            Instances newInsts = new Instances(data.relationName(), newVec, 0);
            newInsts.setClassIndex(data.classIndex());
            setOutputFormat(newInsts);
            int[] temp = new int[m_Converter.length];
            for (int i = 0; i < temp.length; i++) {
                temp[m_Converter[i]] = i;
            }
            m_Converter = temp;
            for (int xyz = 0; xyz < data.numInstances(); xyz++) {
                Instance datum = data.instance(xyz);
                if (!datum.isMissing(datum.classIndex())) {
                    datum.setClassValue((double) m_Converter[(int) datum.classValue()]);
                }
                push(datum);
            }
        }
        flushInput();
        m_NewBatch = true;
        return (numPendingOutput() != 0);
    }
"
423,15564158,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
83,2988615,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
248,9414360,13,"    private static void testForRemovalStress(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> previousBits = empty(c);
        ExtendedSet<Integer> currentBits = empty(c);
        TreeSet<Integer> currentItems = new TreeSet<Integer>();
        Random rnd = new MersenneTwister();
        currentBits.add((1 << MatrixIntSet.COL_POW) * 5 - 1);
        currentBits.complement();
        currentItems.addAll(currentBits);
        if (currentItems.size() != (1 << MatrixIntSet.COL_POW) * 5 - 1) {
            System.out.println(""Unexpected error!"");
            System.out.println(currentBits.size());
            System.out.println(currentItems.size());
            return;
        }
        for (int i = 0; i < 100000 & !currentBits.isEmpty(); i++) {
            int item = rnd.nextInt(10000 + 1);
            previousBits = currentBits;
            currentBits = currentBits.clone();
            System.out.format(""Removing %d...\n"", item);
            boolean itemExistsBefore = currentItems.contains(item);
            boolean itemRemoved = currentItems.remove(item);
            boolean itemExistsAfter = currentItems.contains(item);
            boolean bitExistsBefore = currentBits.contains(item);
            boolean bitRemoved = currentBits.remove(item);
            boolean bitExistsAfter = currentBits.contains(item);
            if (itemRemoved ^ bitRemoved) {
                System.out.println(""wrong remove() result"");
                return;
            }
            if (itemExistsBefore ^ bitExistsBefore) {
                System.out.println(""wrong contains() before"");
                return;
            }
            if (itemExistsAfter ^ bitExistsAfter) {
                System.out.println(""wrong contains() after"");
                return;
            }
            if (!checkContent(currentBits, currentItems)) {
                System.out.println(""remove() error"");
                System.out.println(""Same elements: "" + (currentItems.toString().equals(currentBits.toString())));
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> otherBits = empty(c);
            otherBits.addAll(currentItems);
            if (otherBits.hashCode() != currentBits.hashCode()) {
                System.out.println(""Representation error"");
                System.out.println(currentBits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> singleBitSet = empty(c);
            singleBitSet.add(item);
            if (currentItems.size() != currentBits.differenceSize(singleBitSet)) {
                System.out.println(""Size error"");
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
        }
        System.out.println(""Final"");
        System.out.println(currentBits.debugInfo());
        System.out.println();
        System.out.println(IntSetStatistics.summary());
    }
"
319,11071921,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
416,15102847,13,"        void reset(Random random) {
            rfqAverageNumber = rfqAvgMin + random.nextInt(rfqAvgMax - rfqAvgMin);
        }
"
371,13146082,13,"    public static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
452,17057125,13,"    public static void generate(int seed) throws SlickException {
        if (!initDone) throw new SlickException(""Use init() first."");
        Random rnd = new Random(seed);
        int rocks = 11;
        for (int i = 0; i < rocks; i++) {
            int x = 46 + rnd.nextInt(W - 46);
            int y = 46 + rnd.nextInt(H - 46);
            Disc(x, y, 8, Properties.ids.get(""stone""));
        }
        int trees = 10;
        int tree_height = 50;
        int tree_width = 50;
        int branches_height = 50;
        int branches_width = 50;
        for (int i = 0; i < trees; i++) {
            int y = tree_height + branches_height + rnd.nextInt(H - tree_height - branches_height);
            int x = tree_width + branches_width + rnd.nextInt(W - tree_width - branches_width);
            int tree_top = y - tree_height;
            for (int a = y - tree_height; a < y; a++) {
                map[x][a] = Properties.ids.get(""wood"");
                map[x - 1][a] = Properties.ids.get(""wood"");
                map[x + 1][a] = Properties.ids.get(""wood"");
            }
            Disc(x, y - (tree_height + 16), 32, Properties.ids.get(""plant""));
        }
        int lakes = 1;
        for (int i = 0; i < lakes; i++) {
            int x = 46 + rnd.nextInt(W - 46);
            int y = 46 + rnd.nextInt(H - 46);
            Circle(x, y, 64, Properties.ids.get(""stone""));
            Circle(x + 1, y, 64, Properties.ids.get(""stone""));
            Disc(x, y, 60, Properties.ids.get(""water""));
        }
        int house_width = 50;
        int house_height = 50;
        int x = 4 + rnd.nextInt(46);
        int y = 4 + rnd.nextInt(H - 4);
        for (int i = x; i < x + house_width; i++) {
            for (int a = y; a < y + house_height; a++) {
                map[i][a] = Properties.ids.get(""house"");
            }
        }
    }
"
548,21561478,13,"    public void mutate(Permutation tomutate, int sl) {
        if (len == 2) tomutate.swap(0, 1);
        int from = rand.nextInt(len);
        int subsegmentlength = -1;
        if (sl == -1) subsegmentlength = 2 + rand.nextInt(len - 2); else {
            if (sl < 2) subsegmentlength = 2; else if (sl >= len) subsegmentlength = sl - 1; else subsegmentlength = sl;
        }
        int to = (from + subsegmentlength) % len;
        int elems;
        if (from < to) elems = to - from + 1; else elems = to + len - from + 1;
        int cut = (from + 1 + rand.nextInt(elems - 2)) % len;
        tomutate.invert(from, cut);
        tomutate.invert((cut + 1) % len, to);
    }
"
210,7981579,13,"        public Layer(int num, ALayer pl, int inputs_per_neuron) {
            prevLayer = pl;
            index = num;
            ANeuron[] copyN;
            ANeuron[] inputsChoosen;
            g = new Genome[maxNeuronsInLayer];
            prevLayer = pl;
            ALayer aLayer = prevLayer;
            ANeuron choosen;
            Dimension pos;
            new Dimension();
            layerProgress = 0;
            boolean tryAgain;
            inputsToNeuron = inputs_per_neuron;
            logger.info(""New layer "" + num + "", max inputs:"" + inputs_per_neuron);
            inumber = c.getLayerInitialNeuronsNumber(num);
            logger.info(""Number of neurons in the population:"" + inumber);
            number = inumber;
            if (number > inumber) {
                number = inumber;
            }
            int actInput, golayer, which, s;
            inputsPossible = 0;
            while (aLayer != null) {
                inputsPossible += aLayer.getNumber();
                aLayer = aLayer.getPreviousLayer();
            }
            if (c.isJustTwo()) {
                inputs_per_neuron = inputsToNeuron = inputsPossible;
            }
            inputsChoosen = new ANeuron[inputs_per_neuron];
            mode = PASSIVE;
            prevLayer.computeOutputs();
            for (int i = 0; i < inumber; i++) {
                copyN = prevLayer.getRandomNeurons(1);
                aLayer = prevLayer;
                ALayer al;
                inputsChoosen[0] = copyN[0];
                int inputsPN;
                if (c.isJustTwo()) {
                    inputsPN = myRandom.nextInt(inputs_per_neuron);
                    inputsPN++;
                } else {
                    inputsPN = inputs_per_neuron;
                }
                if (c.isEmployPrevious()) {
                    actInput = 1;
                } else {
                    actInput = 0;
                }
                int full;
                while (actInput < inputsPN) {
                    do {
                        aLayer = prevLayer;
                        switch(c.getParents()) {
                            case NetworkConfiguration.YOUNG:
                                full = aLayer.getNumber();
                                while (actInput >= full) {
                                    aLayer = aLayer.getPreviousLayer();
                                    if (aLayer != null) {
                                        full += aLayer.getNumber();
                                    } else {
                                        break;
                                    }
                                }
                                break;
                            case NetworkConfiguration.YOUNGER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= j--) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.MIDDLE:
                                s = myRandom.nextInt(num + 1);
                                for (int j = 0; j < s; j++) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLDER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= (num - (--j))) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLD:
                                full = 0;
                                do {
                                    al = getPreviousLayer();
                                    while (al.getPreviousLayer() != null) {
                                        al = al.getPreviousLayer();
                                    }
                                    aLayer = al;
                                    full += aLayer.getNumber();
                                } while (actInput >= full);
                                break;
                        }
                        choosen = aLayer.getNeuron(myRandom.nextInt(aLayer.getNumber()));
                        tryAgain = false;
                        for (int j = 0; j < actInput; j++) {
                            if (inputsChoosen[j].equals(choosen)) {
                                tryAgain = true;
                            }
                        }
                    } while (tryAgain);
                    inputsChoosen[actInput] = choosen;
                    actInput++;
                }
                g[i] = new Genome(iNum, inputsPossible, inputsPN);
                inputsToNeuron = inputsPN;
                do {
                    which = myRandom.nextInt(u.getNeuronsNumber());
                } while (!c.neuronTypeAllowed(which));
                int train;
                do {
                    train = myRandom.nextInt(u.getTrainersNumber());
                } while (!c.neuronTrainerAllowed(train));
                do {
                    n[i] = newNeuron(which, train, inputsChoosen);
                } while (n[i] == null);
                logger.trace(""New neuron "" + i + "", type id:"" + which + "", trainer id:"" + train);
                for (int j = 0; j < inputsPN; j++) {
                    pos = getNeuronParentPosition(n[i], j);
                    if (pos == null) {
                        int h = 0;
                    }
                    int ipos = (int) pos.getWidth();
                    int layerDist = (int) pos.getHeight();
                    ALayer pLay = this;
                    for (int k = 0; k < layerDist; k++) {
                        if (pLay != null) {
                            pLay = pLay.getPreviousLayer();
                        }
                    }
                    if (pLay != null) {
                        pLay = pLay.getPreviousLayer();
                    }
                    while (pLay != null) {
                        ipos += pLay.getNumber();
                        pLay = pLay.getPreviousLayer();
                    }
                    g[i].setInput(ipos, 1);
                }
                if (n[i].getClass().getName().compareTo(""game.neurons.CombiNeuron"") == 0) {
                    g[i] = new CombiGenome((CombiNeuron) n[i], g[i]);
                    ((CombiNeuron) n[i]).readGenome(((CombiGenome) g[i]));
                }
                logger.trace(""Neuron input connections:"" + g[i].toString());
            }
            mode = ACTIVE;
            inputsToNeuron = inputs_per_neuron;
        }
"
176,6416636,13,"    private void generateClassifierForNode(Instances data, Range classes, Random rand, Classifier classifier, Hashtable table, double[] instsNumAllClasses) throws Exception {
        int[] indices = classes.getSelection();
        for (int j = indices.length - 1; j > 0; j--) {
            int randPos = rand.nextInt(j + 1);
            int temp = indices[randPos];
            indices[randPos] = indices[j];
            indices[j] = temp;
        }
        double total = 0;
        for (int j = 0; j < indices.length; j++) {
            total += instsNumAllClasses[indices[j]];
        }
        double halfOfTotal = total / 2;
        double sumLeft = 0, sumRight = 0;
        int i = 0, j = indices.length - 1;
        do {
            if (i == j) {
                if (rand.nextBoolean()) {
                    sumLeft += instsNumAllClasses[indices[i++]];
                } else {
                    sumRight += instsNumAllClasses[indices[j--]];
                }
            } else {
                sumLeft += instsNumAllClasses[indices[i++]];
                sumRight += instsNumAllClasses[indices[j--]];
            }
        } while (Utils.sm(sumLeft, halfOfTotal) && Utils.sm(sumRight, halfOfTotal));
        int first = 0, second = 0;
        if (!Utils.sm(sumLeft, halfOfTotal)) {
            first = i;
        } else {
            first = j + 1;
        }
        second = indices.length - first;
        int[] firstInds = new int[first];
        int[] secondInds = new int[second];
        System.arraycopy(indices, 0, firstInds, 0, first);
        System.arraycopy(indices, first, secondInds, 0, second);
        int[] sortedFirst = Utils.sort(firstInds);
        int[] sortedSecond = Utils.sort(secondInds);
        int[] firstCopy = new int[first];
        int[] secondCopy = new int[second];
        for (int k = 0; k < sortedFirst.length; k++) {
            firstCopy[k] = firstInds[sortedFirst[k]];
        }
        firstInds = firstCopy;
        for (int k = 0; k < sortedSecond.length; k++) {
            secondCopy[k] = secondInds[sortedSecond[k]];
        }
        secondInds = secondCopy;
        if (firstInds[0] > secondInds[0]) {
            int[] help = secondInds;
            secondInds = firstInds;
            firstInds = help;
            int help2 = second;
            second = first;
            first = help2;
        }
        m_Range = new Range(Range.indicesToRangeList(firstInds));
        m_Range.setUpper(data.numClasses() - 1);
        Range secondRange = new Range(Range.indicesToRangeList(secondInds));
        secondRange.setUpper(data.numClasses() - 1);
        MakeIndicator filter = new MakeIndicator();
        filter.setAttributeIndex("""" + (data.classIndex() + 1));
        filter.setValueIndices(m_Range.getRanges());
        filter.setNumeric(false);
        filter.setInputFormat(data);
        m_FilteredClassifier = new FilteredClassifier();
        if (data.numInstances() > 0) {
            m_FilteredClassifier.setClassifier(Classifier.makeCopies(classifier, 1)[0]);
        } else {
            m_FilteredClassifier.setClassifier(new weka.classifiers.rules.ZeroR());
        }
        m_FilteredClassifier.setFilter(filter);
        m_classifiers = table;
        if (!m_classifiers.containsKey(getString(firstInds) + ""|"" + getString(secondInds))) {
            m_FilteredClassifier.buildClassifier(data);
            m_classifiers.put(getString(firstInds) + ""|"" + getString(secondInds), m_FilteredClassifier);
        } else {
            m_FilteredClassifier = (FilteredClassifier) m_classifiers.get(getString(firstInds) + ""|"" + getString(secondInds));
        }
        m_FirstSuccessor = new DataNearBalancedND();
        if (first == 1) {
            m_FirstSuccessor.m_Range = m_Range;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(m_Range.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances firstSubset = Filter.useFilter(data, rwv);
            m_FirstSuccessor.generateClassifierForNode(firstSubset, m_Range, rand, classifier, m_classifiers, instsNumAllClasses);
        }
        m_SecondSuccessor = new DataNearBalancedND();
        if (second == 1) {
            m_SecondSuccessor.m_Range = secondRange;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(secondRange.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances secondSubset = Filter.useFilter(data, rwv);
            m_SecondSuccessor = new DataNearBalancedND();
            m_SecondSuccessor.generateClassifierForNode(secondSubset, secondRange, rand, classifier, m_classifiers, instsNumAllClasses);
        }
    }
"
10,682291,13,"    public static void main(String[] args) {
        Dice Di = new Dice();
        Scanner Scan1 = new Scanner(System.in);
        Scanner Scan3 = new Scanner(System.in);
        Random randomNumbers = new Random();
        int sum1 = 0;
        int sum2 = 0;
        int lng;
        int s;
        String player1;
        String player2;
        System.out.println(""Please, write the name of the first player: "");
        player1 = Scan1.nextLine();
        System.out.println(""Please, write the name of the second player: "");
        player2 = Scan1.nextLine();
        System.out.println(""Please, type the \""Length\"" of the dice: "");
        lng = Scan3.nextInt();
        System.out.println(""It is your turn now "" + player1 + "" you'll throw 5 times 'pray to get the highest score :P'.\n"");
        for (int i = 0; i < 5; i++) {
            s = 0 + randomNumbers.nextInt(100 - 0);
            System.out.println(""You got: "" + s);
            sum1 = sum1 + s;
        }
        System.out.println(""It is your turn now "" + player2 + "" you'll throw 5 times 'pray to get the highest score :P'.\n"");
        for (int j = 0; j < 5; j++) {
            s = 0 + randomNumbers.nextInt(100 - 0);
            System.out.println(""You got: "" + s);
            sum2 = sum2 + s;
        }
        System.out.println(player1 + "", you got a sum of "" + sum1 + "" and "" + player2 + "", got a sum of "" + sum2);
        if (sum1 > sum2) {
            System.out.println(player1 + "", Congratulation! you won :D."");
        } else if (sum2 > sum1) {
            System.out.println(player2 + "", Congratulation! you won :D."");
        } else if (sum2 == sum1) {
            System.out.println(player2 + "", and "" + player2 + "" you both played a nice game, you two equal in the luck :P."");
        }
    }
"
357,12831746,13,"    public void crossover(int c1, int c2, float[] kid) {
        int i, cut1;
        cut1 = 1 + r.nextInt(CHROMOSOME_SIZE - 1);
        for (i = 0; i < cut1; i++) kid[i] = pop[c1][i];
        for (i = cut1; i < CHROMOSOME_SIZE; i++) kid[i] = pop[c2][i];
    }
"
6,479570,13,"    public DSoCService(int MaximumNumberOfSegmentation, String ServiceName) {
        MAX_NUMBER_OF_SES = MaximumNumberOfSegmentation;
        Random rand = new Random();
        int RandNum = rand.nextInt(MAX_NUMBER_OF_SES + 1);
        NUMBER_OF_SES = (RandNum < 3) ? 3 : RandNum;
        hx_SES = new SES[NUMBER_OF_SES];
        sx_SES = new SES[NUMBER_OF_SES];
        str_Name = ServiceName;
        init_SESs();
    }
"
487,19137253,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
497,19569166,13,"    public Object newValue(Random random) {
        if (random.nextBoolean()) {
            return null;
        }
        StringBuilder strBuilder = new StringBuilder();
        int remainingLength = minLength + random.nextInt(maxLength - minLength);
        boolean endsWithPunctuation = random.nextBoolean();
        if (endsWithPunctuation) {
            remainingLength--;
        }
        String word = getWord(remainingLength, random);
        strBuilder.append(word);
        remainingLength -= word.length();
        while (remainingLength > 1) {
            strBuilder.append(getChar(midPunctuation, random));
            remainingLength--;
            word = getWord(remainingLength, random);
            strBuilder.append(word);
            remainingLength -= word.length();
        }
        if (endsWithPunctuation) {
            strBuilder.append(getChar(endPunctuation, random));
        }
        return strBuilder.toString();
    }
"
490,19406526,13,"        void doMovements() {
            Random r = new Random();
            int x = 0;
            int y = 0;
            int v = 0;
            String retstr = new String(executeAndGetResponse(""c"", rm.out, rm.in));
            System.out.println(retstr);
            while (rm.keepOn) {
                while (isInMotion(rm.out, rm.in)) {
                    try {
                        Thread.sleep(1200);
                        System.out.print('.');
                    } catch (InterruptedException e) {
                    }
                }
                System.out.println();
                x = r.nextInt(XMAX - XMIN + 1) + XMIN;
                y = r.nextInt(YMAX - YMIN + 1) + YMIN;
                v = r.nextInt(VMAX + 1);
                System.out.printf(""   x: %5d     y: %5d     v: %2d\n"", x, y, v);
                retstr = new String(executeAndGetResponse(""x"" + x, rm.out, rm.in));
                System.out.println(retstr);
                retstr = new String(executeAndGetResponse(""y"" + y, rm.out, rm.in));
                System.out.println(retstr);
                retstr = new String(executeAndGetResponse(""v"" + v, rm.out, rm.in));
                System.out.println(retstr);
                retstr = new String(executeAndGetResponse(""m"", rm.out, rm.in));
                System.out.println(retstr);
            }
        }
"
101,4243051,13,"    @Override
    public IGenome mutate(IGenome genome) {
        double mutationRate = getMutationRate();
        if (s_rnd.nextDouble() < mutationRate) {
            int maxDelta = Math.abs(getMaxDelta());
            int delta = s_rnd.nextInt(maxDelta + 1);
            if (delta == 0) {
                return genome;
            }
            if (s_rnd.nextBoolean()) {
                delta = -delta;
            }
            List<IGene> genes = genome.getGenes();
            if (delta % genes.size() == 0) {
                return genome;
            }
            List<IGene> childGenes = Collections.synchronizedList(new ArrayList<IGene>(genes));
            Collections.rotate(childGenes, delta);
            IGenome childGenome = genome.createClone(true);
            childGenome.setGenes(childGenes);
            if (s_log.isDebugEnabled()) {
                s_log.debug(""[MUTATE]  Shifted "" + genome + "" ["" + delta + ""] --> "" + childGenome);
            }
            return childGenome;
        } else {
            return genome;
        }
    }
"
165,6036290,13,"    public static String getRandomDocId() throws XMLDBException {
        String randomDocId = """";
        Integer objNum = null;
        java.util.Random rand = new java.util.Random();
        int max = 1000;
        for (int i = 0; i < 3; i++) {
            objNum = rand.nextInt(max + 1);
        }
        if (null != objNum) {
            String xquery = ""xquery version \""1.0\"";"" + ""  let $col := collection('"" + forumDB + ""')["" + objNum + ""],"" + ""  $docName := item-at($col, 1)"" + ""  return replace(util:document-name($docName), \"".xml\"", \""\"")"";
            XQueryService service = (XQueryService) vobs.dbaccess.CollectionsManager.getService(rootDB, true, ""XQueryService"");
            ResourceSet result = service.query(xquery);
            if (result.getSize() > 0) {
                XMLResource resource = (XMLResource) result.getResource(0);
                randomDocId = resource.getContent().toString();
            }
        }
        return randomDocId;
    }
"
72,2884219,13,"    public static XLog createLog(int minTraces, int maxTraces, int minTraceLength, int maxTraceLength) {
        XLog log = factory.createLog();
        addAttributes(log, 0.9, 3, 50);
        int length = minTraces + random.nextInt(maxTraces - minTraces);
        for (int i = 0; i < length; i++) {
            log.add(createTrace(minTraceLength, maxTraceLength));
        }
        return log;
    }
"
177,6476018,13,"    public List<Regla> planificar(IBaseConocimientos bc) {
        List<Regla> reglas = bc.getReglas();
        Collections.sort(reglas);
        Collection<Sensor> estado = bc.getEstadoActual();
        DefaultMutableTreeNode nodo = null;
        Iterator i = reglas.iterator();
        while (i.hasNext() && nodo == null) {
            Regla regla = (Regla) i.next();
            DefaultMutableTreeNode root = armarArbol(regla.getPredicciones(), reglas);
            nodo = buscarNodo(root, estado);
        }
        if (nodo == null) {
            List<Regla> plan = new ArrayList<Regla>();
            int count = reglas.size();
            Random r = new Random();
            int number = r.nextInt(count + 1);
            Regla regla = reglas.get(number);
            plan.add(regla);
            return plan;
        } else {
            return armarCamino(nodo, reglas);
        }
    }
"
196,7231842,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
228,8498047,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
407,14809923,13,"    private void populateRandomWalksC(int number, int maxLength) {
        int counter = 0, unsucc = 0;
        FSMStructure fsm = WMethod.getGraphData(g);
        Random length = new Random(0);
        while (counter < number) {
            List<String> path = new ArrayList<String>(maxLength);
            String current = fsm.init;
            if (unsucc > 100) return;
            int randomLength = 0;
            while (randomLength == 0) randomLength = length.nextInt(maxLength + 1);
            for (int i = 0; i < randomLength; i++) {
                Map<String, String> row = fsm.trans.get(current);
                if (row.isEmpty()) break;
                String nextInput = (String) pickRandom(row.keySet());
                path.add(nextInput);
                current = row.get(nextInput);
            }
            int oldSize = sPlus.size();
            sPlus.add(new ArrayList<String>(path));
            if (sPlus.size() > oldSize) {
                counter++;
                unsucc = 0;
            } else {
                unsucc++;
            }
        }
    }
"
437,16216215,13,"    public void CreatePopulation(int popSize) throws Exception {
        InitPopulation(popSize);
        int segmentation = m_numAttribs / 2;
        for (int i = 0; i < m_popSize; i++) {
            List<Subset> attributeRankingCopy = new ArrayList<Subset>();
            for (int j = 0; j < m_attributeRanking.size(); j++) attributeRankingCopy.add(m_attributeRanking.get(j));
            double last_evaluation = -999;
            double current_evaluation = 0;
            boolean doneAnew = true;
            while (true) {
                int random_number = m_random.nextInt(segmentation + 1);
                if (doneAnew && i <= segmentation) random_number = i;
                doneAnew = false;
                Subset s1 = ((Subset) attributeRankingCopy.get(random_number)).clone();
                Subset s2 = ((Subset) m_population.get(i)).clone();
                Subset joiners = joinSubsets(s1, s2);
                current_evaluation = joiners.merit;
                if (current_evaluation > last_evaluation) {
                    m_population.set(i, joiners);
                    last_evaluation = current_evaluation;
                    try {
                        attributeRankingCopy.set(random_number, attributeRankingCopy.get(segmentation + 1));
                        attributeRankingCopy.remove(segmentation + 1);
                    } catch (IndexOutOfBoundsException ex) {
                        attributeRankingCopy.set(random_number, new Subset(new BitSet(m_numAttribs), 0));
                        continue;
                    }
                } else {
                    break;
                }
            }
        }
    }
"
76,2948282,13,"        private void calcCurrentDrop() {
            currentDrop = minDropRate + RANDOM.nextInt(maxDropRate - minDropRate);
        }
"
227,8227926,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
334,11367479,13,"    @Override
    public void neighbor(PermutationGenotype<?> genotype) {
        int size = genotype.size();
        if (size > 1) {
            int a = random.nextInt(size - 1);
            int b;
            do {
                b = a + random.nextInt(size - a);
            } while (b == a);
            while (a < b) {
                Collections.swap(genotype, a, b);
                a++;
                b--;
            }
        }
    }
"
30,1181596,13,"    private boolean generateSubElements(File root, int depth) {
        int subElementsNumber = random.nextInt(maxSubElements + 1);
        if (depth > 0) {
            for (int i = 1; i <= subElementsNumber; i++) {
                if (random.nextInt(100) >= 50) {
                    if (!generateFile(root)) {
                        return false;
                    }
                    if (--elementsNumber <= 0) {
                        return true;
                    }
                } else {
                    if (!generateDir(root, generateName(), depth - 1)) {
                        return false;
                    }
                }
            }
        } else {
            for (int i = 1; i <= subElementsNumber; i++) {
                if (!generateFile(root)) {
                    return false;
                }
                if (--elementsNumber <= 0) {
                    return true;
                }
            }
        }
        return true;
    }
"
298,10685284,13,"    private static Color getRandColor(int fc, int bc) {
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + RandomUtil.nextInt(bc - fc);
        int g = fc + RandomUtil.nextInt(bc - fc);
        int b = fc + RandomUtil.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
249,9414363,13,"    private static void testForSubSetRemovalStress() {
        IntegerSet previousBits = new IntegerSet(new ConciseSet());
        IntegerSet currentBits = new IntegerSet(new ConciseSet());
        TreeSet<Integer> currentItems = new TreeSet<Integer>();
        currentBits.add(10001);
        currentBits.complement();
        currentItems.addAll(currentBits);
        if (currentItems.size() != 10001) {
            System.out.println(""Unexpected error!"");
            return;
        }
        Random rnd = new MersenneTwister();
        for (int j = 0; j < 100000; j++) {
            previousBits = currentBits;
            currentBits = currentBits.clone();
            int min = rnd.nextInt(10000);
            int max = min + 1 + rnd.nextInt(10000 - (min + 1) + 1);
            int item = rnd.nextInt(10000 + 1);
            System.out.println(""Removing "" + item + "" from the subview from "" + min + "" to "" + max + "" - 1"");
            SortedSet<Integer> subBits = currentBits.subSet(min, max);
            SortedSet<Integer> subItems = currentItems.subSet(min, max);
            boolean subBitsResult = subBits.remove(item);
            boolean subItemsResult = subItems.remove(item);
            if (subBitsResult != subItemsResult || subBits.size() != subItems.size() || !subBits.toString().equals(subItems.toString())) {
                System.out.println(""Subset error!"");
                return;
            }
            if (!checkContent(currentBits, currentItems)) {
                System.out.println(""Subview not correct!"");
                System.out.println(""Same elements: "" + (currentItems.toString().equals(currentBits.toString())));
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            IntegerSet otherBits = new IntegerSet(new ConciseSet());
            otherBits.addAll(currentItems);
            if (otherBits.hashCode() != currentBits.hashCode()) {
                System.out.println(""Representation not correct!"");
                System.out.println(currentBits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
        }
        System.out.println(currentBits.debugInfo());
        System.out.println(IntSetStatistics.summary());
    }
"
419,15294077,13,"    private static Color getRandColor(int min, int max) {
        if (min > 255) {
            min = 255;
        }
        if (max > 255) {
            max = 255;
        }
        Random random = new Random();
        int r = min + random.nextInt(max - min);
        int g = min + random.nextInt(max - min);
        int b = min + random.nextInt(max - min);
        return new Color(r, g, b);
    }
"
338,11372483,13,"    private TObjectIntHashMap<Vertex> generateDegreeSequence(Graph graph, int maxDegree) {
        TObjectIntHashMap<Vertex> kMap = new TObjectIntHashMap<Vertex>();
        for (Vertex vertex : graph.getVertices()) {
            boolean accept = false;
            while (!accept) {
                try {
                    int k = random.nextInt(maxDegree + 1);
                    double p = degreeDistribution.value(k);
                    if (p >= random.nextDouble()) {
                        kMap.put(vertex, k);
                        accept = true;
                    }
                } catch (FunctionEvaluationException e) {
                    e.printStackTrace();
                }
            }
        }
        return kMap;
    }
"
39,1928246,13,"    protected void makeNewInterval() {
        Random randNumber = new Random();
        int string = randNumber.nextInt(6);
        int fret = randNumber.nextInt(13);
        rootMidi = FretboardObject.convertPostionToMidiNote(fret, string);
        intervalMidi = 0;
        while ((rootMidi + currentInterval) > 76) {
            string = randNumber.nextInt(6);
            fret = randNumber.nextInt(13);
            rootMidi = FretboardObject.convertPostionToMidiNote(fret, string);
        }
        switch(string) {
            case 0:
                fretboardG.positionDot(FretboardObject.convertIntToFret(fret), FretboardObject.convertIntToString(string));
                fretboardG.positionSecondDot(FretboardObject.convertIntToFret(fret + currentInterval), FretboardObject.convertIntToString(string));
                intervalMidi = rootMidi + currentInterval;
                break;
            default:
                int string2 = randNumber.nextInt(string + 1);
                String intervalNote = FretboardObject.convertPostionToString(fret + currentInterval, string);
                int fret2 = 0;
                while (!(FretboardObject.convertPostionToString(fret2, string2).equals(intervalNote)) || (FretboardObject.convertPostionToMidiNote(fret2, string2) < rootMidi)) {
                    fret2++;
                    if (fret2 > 12) {
                        string2--;
                        fret2 = 0;
                    }
                }
                intervalMidi = FretboardObject.convertPostionToMidiNote(fret2, string2);
                fretboardG.positionDot(FretboardObject.convertIntToFret(fret), FretboardObject.convertIntToString(string));
                fretboardG.positionSecondDot(FretboardObject.convertIntToFret(fret2), FretboardObject.convertIntToString(string2));
                break;
        }
        playNotes(rootMidi, intervalMidi);
    }
"
145,5272381,13,"    public void generate(int SEsize, int type) throws Exception {
        this.createDatabase();
        int[] quotas = new int[QuotaScheduler.NUMBER_OF_USERS];
        int quota = SEsize / QuotaScheduler.NUMBER_OF_USERS;
        int newQuota = quota + (quota * 70) / 100;
        int diffQuota = quota - (quota * 30) / 100;
        int id = 1;
        int count = 0;
        int dataId = 1;
        try {
            while (true) {
                random = new Random(System.nanoTime());
                int userId = 1 + random.nextInt(QuotaScheduler.NUMBER_OF_USERS);
                int tasks = MIN_TASKS + random.nextInt(MAX_TASKS - MIN_TASKS);
                int submitTime = 0 + random.nextInt(90000);
                int dataSize = MIN_DATA_SIZE + random.nextInt(MAX_DATA_SIZE - MIN_DATA_SIZE);
                taskfor: for (int i = 0; i < tasks; i++) {
                    int userQuota = quotas[userId - 1];
                    switch(type) {
                        case 1:
                            if (userQuota < quota && quota - userQuota >= dataSize) {
                                this.addStat(id++, submitTime, dataId, dataSize, userId);
                            } else {
                                break taskfor;
                            }
                            break;
                        case 2:
                            if (userQuota < newQuota && newQuota - userQuota >= dataSize) {
                                this.addStat(id++, submitTime, dataId, dataSize, userId);
                            } else {
                                break taskfor;
                            }
                            break;
                        case 3:
                            if (userId == 1) {
                                if (userQuota < newQuota && newQuota - userQuota >= dataSize) {
                                    this.addStat(id++, submitTime, dataId, dataSize, userId);
                                } else {
                                    break taskfor;
                                }
                            } else if (userQuota < diffQuota && diffQuota - userQuota >= dataSize) {
                                this.addStat(id++, submitTime, dataId, dataSize, userId);
                            } else {
                                break taskfor;
                            }
                            break;
                    }
                }
                if (count++ >= 1024) {
                    stat.executeBatch();
                    conn.commit();
                    count = 0;
                }
                quotas[userId - 1] += dataSize;
                dataId++;
                boolean finished = true;
                finishFor: for (int i = 0; i < QuotaScheduler.NUMBER_OF_USERS; i++) {
                    switch(type) {
                        case 1:
                            if (quotas[i] < quota - MIN_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            }
                            break;
                        case 2:
                            if (quotas[i] < newQuota - MIN_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            }
                            break;
                        case 3:
                            if (i == 0 && quotas[0] < newQuota - MAX_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            } else if (quotas[i] < diffQuota - MAX_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            }
                            break;
                    }
                }
                if (finished) {
                    break;
                }
            }
        } catch (SQLException sqlException) {
            sqlException.printStackTrace();
        }
        this.close();
    }
"
332,11355676,13,"    public void init() {
        Random random = new Random();
        for (int i = 0; i < numPlayers; ++i) {
            int x;
            int y;
            do {
                x = 1 + random.nextInt(size - 1);
                y = 1 + random.nextInt(size - 1);
            } while (alreadyPicked(i, x, y));
            playerCoords[i] = new SectorCoords(x, y);
        }
    }
"
158,5540027,13,"    private static int buildDeadEnds(int x0, int maxLength) {
        int floor = height - 2 - globalRandom.nextInt(2);
        int length = 0;
        int preDeadEndLength = 7 + globalRandom.nextInt(10);
        int rHeight = floor - 1;
        int separatorY = 3 + globalRandom.nextInt(rHeight - 7);
        length += buildStraight(x0, preDeadEndLength, true, floor, INFINITE_FLOOR_HEIGHT);
        if (globalRandom.nextInt(3) == 0 && isLadder) {
            int ladderX = x0 + globalRandom.nextInt(length - 1) + 1;
            if (ladderX > x0 + length) ladderX = x0 + length;
            buildLadder(ladderX, floor, floor - separatorY);
        } else buildBlocks(x0, x0 + preDeadEndLength, floor, true, 0, 0, true, true);
        globalRandom.nextInt();
        int k = globalRandom.nextInt(5);
        boolean direction = globalRandom.nextInt(k + 1) != 1;
        int separatorHeight = 2 + globalRandom.nextInt(2);
        int nx = x0 + length;
        int depth = globalRandom.nextInt(levelDifficulty + 1) + 2 * (1 + levelDifficulty);
        if (depth + length > maxLength) {
            while (depth + length > maxLength - 1) {
                depth--;
            }
        }
        int tLength = 0;
        int bSpace = floor - (separatorY + separatorHeight);
        if (bSpace < 4) {
            while (bSpace < 4) {
                separatorY -= 1;
                bSpace = floor - (separatorY + separatorHeight);
            }
        }
        int wallWidth = 2 + globalRandom.nextInt(3);
        while (tLength < depth) {
            tLength += buildZone(nx + tLength, depth - tLength, separatorY - 1, separatorY, separatorHeight);
        }
        tLength = 0;
        while (tLength < depth) {
            tLength += buildZone(nx + tLength, depth - tLength, bSpace, floor, INFINITE_FLOOR_HEIGHT);
        }
        boolean wallFromBlocks = false;
        for (int x = nx; x < nx + depth; x++) {
            for (int y = 0; y < height; y++) {
                if (x - nx >= depth - wallWidth) {
                    if (direction) {
                        if (y <= separatorY) {
                            if (wallFromBlocks) level.setBlock(x, y, (byte) (0 + 1 * 16)); else level.setBlock(x, y, (byte) (1 + 9 * 16));
                        }
                    } else {
                        if (y >= separatorY) {
                            if (wallFromBlocks) level.setBlock(x, y, (byte) (0 + 1 * 16)); else level.setBlock(x, y, (byte) (1 + 9 * 16));
                        }
                    }
                }
            }
        }
        return length + tLength;
    }
"
403,14744159,13,"    public E next() {
        if (cursor < 1) {
            cursor = size - 1;
            return (E) data[0];
        }
        int grab = gen.nextInt(cursor + 1);
        E temp = (E) data[grab];
        data[grab] = data[cursor];
        data[cursor] = temp;
        cursor--;
        return temp;
    }
"
60,2670867,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
78,2973245,13,"    public static long[][] getBinomialDistribution(int min, int max, long total) {
        Random rand = new Random(System.currentTimeMillis());
        int n = max - min;
        long[][] ret = new long[2][n + 1];
        int mean = (n + 1) / 2;
        float p = 1;
        if (n > 0) {
            p = (float) mean / (float) n;
        }
        long count = 0;
        for (int i = 0; i <= n; i++) {
            double p_i = MathUtil.combination(n, i) * Math.pow(p, i) * Math.pow((1 - p), (n - i));
            long count_i = (long) (total * p_i);
            ret[0][i] = i + min;
            ret[1][i] = count_i;
            count += count_i;
        }
        while (count < total) {
            int i = rand.nextInt(n + 1);
            ret[1][i]++;
            count++;
        }
        return ret;
    }
"
204,7635076,13,"    public static int getRndInt(int beginRange, int endRange) {
        int result = 0;
        if (endRange > beginRange && beginRange > 0) {
            result = beginRange + _rnd.nextInt(endRange - beginRange);
        }
        return result;
    }
"
408,14823678,13,"    public void testRandomlyAgainstJavaList() {
        PVector<Integer> pvec = TreePVector.empty();
        List<Integer> list = new LinkedList<Integer>();
        Random r = new Random();
        for (int i = 0; i < 1000; i++) {
            if (pvec.size() == 0 || r.nextBoolean()) {
                if (r.nextBoolean()) {
                    Integer v = r.nextInt();
                    assertEquals(list.contains(v), pvec.contains(v));
                    list.add(v);
                    pvec = pvec.plus(v);
                } else {
                    int k = r.nextInt(pvec.size() + 1);
                    Integer v = r.nextInt();
                    assertEquals(list.contains(v), pvec.contains(v));
                    if (k < pvec.size()) assertEquals(list.get(k), pvec.get(k));
                    list.add(k, v);
                    pvec = pvec.plus(k, v);
                }
            } else if (r.nextBoolean()) {
                int k = r.nextInt(pvec.size());
                Integer v = r.nextInt();
                list.set(k, v);
                pvec = pvec.with(k, v);
            } else {
                int j = r.nextInt(pvec.size()), k = 0;
                for (Integer e : pvec) {
                    assertTrue(list.contains(e));
                    assertTrue(pvec.contains(e));
                    assertEquals(e, pvec.get(k));
                    assertEquals(list.get(k), pvec.get(k));
                    UtilityTest.assertEqualsAndHash(pvec, pvec.minus(k).plus(k, pvec.get(k)));
                    UtilityTest.assertEqualsAndHash(pvec, pvec.plus(k, 10).minus(k));
                    if (k == j) {
                        list.remove(k);
                        pvec = pvec.minus(k);
                        k--;
                        j = -1;
                    }
                    k++;
                }
            }
            Integer v = r.nextInt();
            assertEquals(list.contains(v), pvec.contains(v));
            list.remove(v);
            pvec = pvec.minus(v);
            String s = Integer.toString(v);
            assertFalse(pvec.contains(v));
            pvec = pvec.minus(s);
            assertEquals(list.size(), pvec.size());
            UtilityTest.assertEqualsAndHash(list, pvec);
            UtilityTest.assertEqualsAndHash(pvec, TreePVector.from(pvec));
            UtilityTest.assertEqualsAndHash(TreePVector.empty(), pvec.minusAll(pvec));
            UtilityTest.assertEqualsAndHash(pvec, TreePVector.empty().plusAll(pvec));
            UtilityTest.assertEqualsAndHash(pvec, TreePVector.singleton(10).plusAll(1, pvec).minus(0));
            int end = r.nextInt(pvec.size() + 1), start = r.nextInt(end + 1);
            UtilityTest.assertEqualsAndHash(pvec.subList(start, end), list.subList(start, end));
        }
    }
"
86,3000636,13,"    public static int generateRandomNumber(int maxSize) {
        Random rand = new Random();
        int randnum = rand.nextInt();
        randnum = rand.nextInt(maxSize + 1);
        return randnum;
    }
"
352,12628703,13,"    public static Graph stressTest(int numFields, int numNodes, int numEdges) {
        final MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
        final Random random = new Random(System.currentTimeMillis());
        final Graph graph = new Graph();
        final Attributes attr = new Attributes(""TestNodeType"");
        final EdgeType et = new EdgeType(""TestEdgeType"", ""TestNodeType"", ""TestNodeType"");
        long timer;
        long[] mem, mem2;
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        attr.add(new AttributeKey(""Name""));
        for (int f = 0; f < numFields; f++) attr.add(new AttributeContinuous(""Field"" + f));
        graph.addAttributes(attr);
        graph.addEdgeType(et);
        mem2 = getMemory(mbean);
        log.info(""Constructed Attributes container: "" + attr + lineSeparator + ""Attribute setup took: "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        final double[] results = new double[attr.attributeCount()];
        for (int n = 0; n < numNodes; n++) {
            final Node node = graph.addNode(""Node"" + n, attr);
            for (int r = 0; r < results.length; r++) results[r] = random.nextDouble();
            node.setValues(results);
            if (STRESS_DEBUG) System.err.println(""Created node <"" + node + '>');
            if (n % 200000 == 0 && n > 0) log.config(""Created "" + n + "" Nodes in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"");
        }
        mem2 = getMemory(mbean);
        log.info(""Created "" + numNodes + "" Nodes in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        for (int e = 0; e < numEdges; e++) {
            final Node n1 = graph.getNode(random.nextInt(numNodes));
            final Node n2 = graph.getNode(random.nextInt(numNodes));
            graph.addEdge(et, n1, n2, 1.0);
            if (STRESS_DEBUG) System.err.println(""Connected         ["" + n1.getName() + ""]["" + n2.getName() + ""] weight+=1.0"" + "" edgeType="" + et.getName());
            if (e % 250000 == 0 && e > 0) log.config(""Created "" + e + "" Edges in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"");
        }
        mem2 = getMemory(mbean);
        log.info(""Created "" + numEdges + "" Edges in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        final int[] nodeIndexes = new int[numNodes];
        for (int i = 0; i < nodeIndexes.length; i++) nodeIndexes[i] = i;
        for (int i = nodeIndexes.length; --i > 0; ) {
            final int swapidx = random.nextInt(i + 1);
            final int tmp = nodeIndexes[i];
            if (false) System.err.println(""Swapping nodeIndexes["" + i + ""]="" + nodeIndexes[i] + "" and NodeIndexes["" + swapidx + ""]="" + nodeIndexes[swapidx]);
            nodeIndexes[i] = nodeIndexes[swapidx];
            nodeIndexes[swapidx] = tmp;
        }
        if (false) {
            System.err.print(""Getting Nodes in order:"");
            for (int i : nodeIndexes) System.err.print("" "" + i);
            System.err.println();
        }
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        final int maxIter = 100;
        for (int count = 0; count < maxIter; count++) {
            for (int i = 0; i < numNodes; i++) {
                final Node node = graph.getNode(nodeIndexes[i]);
                final Edge[] neighborEdges = node.getEdges();
                for (int f = 0; f < numFields; f++) {
                    double result = node.getValue(f);
                    for (final Edge edge : neighborEdges) {
                        result += edge.getDest().getValue(f);
                        result += edge.getWeight();
                    }
                }
            }
            log.config(""Completed loop "" + count + "" in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"");
        }
        mem2 = getMemory(mbean);
        log.info(""Completed ("" + maxIter + ""x) accessing "" + numNodes + "" Nodes in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        log.info(""SUCCESS: Graph got "" + graph.numNodes() + "" Nodes and "" + graph.numEdges() + "" (actual) Edges"");
        return graph;
    }
"
453,17498236,13,"    public boolean batchFinished() throws Exception {
        Instances data = getInputFormat();
        if (data == null) throw new IllegalStateException(""No input instance format defined"");
        if (m_Converter == null) {
            int[] randomIndices = new int[m_ClassCounts.length];
            for (int i = 0; i < randomIndices.length; i++) {
                randomIndices[i] = i;
            }
            for (int j = randomIndices.length - 1; j > 0; j--) {
                int toSwap = m_Random.nextInt(j + 1);
                int tmpIndex = randomIndices[j];
                randomIndices[j] = randomIndices[toSwap];
                randomIndices[toSwap] = tmpIndex;
            }
            double[] randomizedCounts = new double[m_ClassCounts.length];
            for (int i = 0; i < randomizedCounts.length; i++) {
                randomizedCounts[i] = m_ClassCounts[randomIndices[i]];
            }
            if (m_ClassOrder == RANDOM) {
                m_Converter = randomIndices;
                m_ClassCounts = randomizedCounts;
            } else {
                int[] sorted = Utils.sort(randomizedCounts);
                m_Converter = new int[sorted.length];
                if (m_ClassOrder == FREQ_ASCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[i]];
                    }
                } else if (m_ClassOrder == FREQ_DESCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[sorted.length - i - 1]];
                    }
                } else {
                    throw new IllegalArgumentException(""Class order not defined!"");
                }
                double[] tmp2 = new double[m_ClassCounts.length];
                for (int i = 0; i < m_Converter.length; i++) {
                    tmp2[i] = m_ClassCounts[m_Converter[i]];
                }
                m_ClassCounts = tmp2;
            }
            FastVector values = new FastVector(data.classAttribute().numValues());
            for (int i = 0; i < data.numClasses(); i++) {
                values.addElement(data.classAttribute().value(m_Converter[i]));
            }
            FastVector newVec = new FastVector(data.numAttributes());
            for (int i = 0; i < data.numAttributes(); i++) {
                if (i == data.classIndex()) {
                    newVec.addElement(new Attribute(data.classAttribute().name(), values, data.classAttribute().getMetadata()));
                } else {
                    newVec.addElement(data.attribute(i));
                }
            }
            Instances newInsts = new Instances(data.relationName(), newVec, 0);
            newInsts.setClassIndex(data.classIndex());
            setOutputFormat(newInsts);
            int[] temp = new int[m_Converter.length];
            for (int i = 0; i < temp.length; i++) {
                temp[m_Converter[i]] = i;
            }
            m_Converter = temp;
            for (int xyz = 0; xyz < data.numInstances(); xyz++) {
                Instance datum = data.instance(xyz);
                if (!datum.isMissing(datum.classIndex())) {
                    datum.setClassValue((double) m_Converter[(int) datum.classValue()]);
                }
                push(datum);
            }
        }
        flushInput();
        m_NewBatch = true;
        return (numPendingOutput() != 0);
    }
"
469,18088116,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
439,16442937,13,"    private Color getRandColor(int min, int max) {
        Random random = new Random();
        if (min > 255) min = 255;
        if (max > 255) max = 255;
        int r = min + random.nextInt(max - min);
        int g = min + random.nextInt(max - min);
        int b = min + random.nextInt(max - min);
        return new Color(r, g, b);
    }
"
274,9708829,13,"    private static short approxMaxOppVal(int atOpp, int activeOpps, Card cards[], int communityShortcut, MersenneTwisterFast rand) {
        if (atOpp >= activeOpps) {
            return Short.MIN_VALUE;
        }
        int holeDestA = OPP_A - atOpp * 2;
        int holeDestB = holeDestA - 1;
        int xOppA = rand.nextInt(holeDestA + 1);
        int xOppB = rand.nextInt(holeDestB + 1);
        swap(cards, xOppA, holeDestA);
        swap(cards, xOppB, holeDestB);
        Card oppA = cards[holeDestA];
        Card oppB = cards[holeDestB];
        short oppVal = Eval7Faster.fastValueOf(communityShortcut, oppA, oppB);
        short maxOtherOppVal = approxMaxOppVal(atOpp + 1, activeOpps, cards, communityShortcut, rand);
        swap(cards, xOppB, holeDestB);
        swap(cards, xOppA, holeDestA);
        return (short) Math.max(oppVal, maxOtherOppVal);
    }
"
277,9900366,13,"    private int getNumberBetween(int low, int high) {
        Random rand = new Random();
        int retInt = low - 1;
        while (retInt < low) retInt = rand.nextInt(high + 1);
        return retInt;
    }
"
140,5093132,13,"    public static int getRandomNum(int startNum, int endNum) {
        int randomNum = 0;
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomNum = rnd.nextInt(endNum + 1);
            } while (randomNum < startNum);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return randomNum;
    }
"
199,7279295,13,"    public StringBuffer createUserKey(String username, String password) {
        StringBuffer sb = new StringBuffer();
        String rvalue = ""no"";
        String sql = """";
        String rusername = """";
        String ruserfullname = """";
        String rkey = """";
        String tkey = """";
        int userid = 0;
        Random rand = new Random();
        for (int i = 0; i < 5; i++) {
            int j = rand.nextInt();
            int n = 30;
            j = rand.nextInt(n + 1);
            tkey = tkey + j;
        }
        try {
            con = getConnection();
            if (con != null) {
                stmt = con.createStatement();
                Statement stmt1 = con.createStatement();
                sql = ""SELECT userid, firstname, lastname FROM usdms_users WHERE email='"" + username + ""' AND password = '"" + password + ""'"";
                rs = stmt.executeQuery(sql);
                String key1 = """";
                if (rs.next()) {
                    rusername = username;
                    ruserfullname = rs.getString(""firstname"") + "" "" + rs.getString(""lastname"");
                    userid = rs.getInt(""userid"");
                    sql = ""SELECT userid FROM usdms_user_keys WHERE userid ="" + userid;
                    rs = stmt.executeQuery(sql);
                    if (rs.next()) {
                        rkey = tkey;
                        sql = ""UPDATE usdms_user_keys SET userkey='"" + rkey + ""' WHERE userid ="" + userid;
                    } else {
                        rkey = tkey;
                        sql = ""INSERT INTO usdms_user_keys VALUES ("" + userid + "",'"" + rkey + ""')"";
                    }
                    stmt1.executeUpdate(sql);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } catch (NullPointerException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (rkey.length() > 0) rvalue = ""yes"";
        sb.append(""<username>"");
        sb.append(rusername);
        sb.append(""</username>"");
        sb.append(""<key>"");
        sb.append(rkey);
        sb.append(""</key>"");
        sb.append(""<rvalue>"");
        sb.append(rvalue);
        sb.append(""</rvalue>"");
        sb.append(""<usernamefullname>"");
        sb.append(ruserfullname);
        sb.append(""</usernamefullname>"");
        return sb;
    }
"
399,14574135,13,"    private IndianSettlement placeIndianSettlement(Player player, boolean capital, Position position, Map map) {
        final Tile tile = map.getTile(position);
        String name = (capital) ? player.getCapitalName() : player.getSettlementName();
        if (Player.ASSIGN_SETTLEMENT_NAME.equals(name)) {
            player.installSettlementNames(Messages.getSettlementNames(player), random);
            name = (capital) ? player.getCapitalName() : player.getSettlementName();
        }
        UnitType skill = generateSkillForLocation(map, tile, player.getNationType());
        IndianSettlement settlement = new ServerIndianSettlement(map.getGame(), player, name, tile, capital, skill, new HashSet<Player>(), null);
        player.addSettlement(settlement);
        logger.fine(""Generated skill: "" + settlement.getLearnableSkill());
        int low = settlement.getType().getMinimumSize();
        int high = settlement.getType().getMaximumSize();
        int unitCount = low + random.nextInt(high - low);
        for (int i = 0; i < unitCount; i++) {
            UnitType unitType = map.getSpecification().getUnitType(""model.unit.brave"");
            Unit unit = new ServerUnit(map.getGame(), settlement, player, unitType, unitType.getDefaultEquipment());
            unit.setIndianSettlement(settlement);
            if (i == 0) {
                unit.setLocation(tile);
            } else {
                unit.setLocation(settlement);
            }
        }
        settlement.placeSettlement(true);
        if (FreeCol.isInDebugMode()) {
            for (GoodsType goodsType : map.getSpecification().getGoodsTypeList()) {
                if (goodsType.isNewWorldGoodsType()) settlement.addGoods(goodsType, 150);
            }
        }
        return settlement;
    }
"
302,10816274,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
340,11658920,13,"    private void shuffleNeighborOffsets() {
        for (int i = 0; i < 8; i++) {
            int j = i + rnd.nextInt(8 - i);
            int t = neighborOffsets[i];
            neighborOffsets[i] = neighborOffsets[j];
            neighborOffsets[j] = t;
            t = neighborXYOffsets[i][0];
            neighborXYOffsets[i][0] = neighborXYOffsets[j][0];
            neighborXYOffsets[j][0] = t;
            t = neighborXYOffsets[i][1];
            neighborXYOffsets[i][1] = neighborXYOffsets[j][1];
            neighborXYOffsets[j][1] = t;
        }
    }
"
525,20387187,13,"    public void testFirstInRange() {
        for (int i = 0; i < 1000; i++) {
            BitVector v = new BitVector(1000);
            int vSize = v.size();
            int a = random.nextInt(vSize + 1);
            int b = a + random.nextInt(vSize + 1 - a);
            BitVector w = v.rangeView(a, b);
            int c;
            int wSize = w.size();
            if (wSize == 0) {
                c = -1;
            } else {
                c = random.nextInt(wSize);
                w.setBit(c, true);
            }
            if (c >= 0) {
                assertEquals(c, w.firstOne());
                assertEquals(c, w.lastOne());
                assertEquals(c, w.nextOne(c));
                assertEquals(-1, w.previousOne(c));
                if (c > 0) assertEquals(c, w.nextOne(c - 1));
                if (c < wSize) assertEquals(c, w.previousOne(c + 1));
                assertEquals(c, w.nextOne(0));
                assertEquals(c, w.previousOne(wSize));
            } else {
                assertEquals(0, w.firstOne());
                assertEquals(-1, w.lastOne());
            }
            w.flip();
            if (c >= 0) {
                assertEquals(c, w.firstZero());
                assertEquals(c, w.lastZero());
                assertEquals(c, w.nextZero(c));
                assertEquals(-1, w.previousZero(c));
                if (c > 0) assertEquals(c, w.nextZero(c - 1));
                if (c < wSize) assertEquals(c, w.previousZero(c + 1));
                assertEquals(c, w.nextZero(0));
                assertEquals(c, w.previousZero(wSize));
            } else {
                assertEquals(0, w.firstZero());
                assertEquals(-1, w.lastZero());
            }
        }
    }
"
571,22697396,13,"    private static void resetLocalPRNG() {
        if (Configuration.DEBUG) log.entering(ICMRandomSpi.class.getName(), ""resetLocalPRNG"");
        HashMap attributes = new HashMap();
        attributes.put(ICMGenerator.CIPHER, Registry.AES_CIPHER);
        byte[] key = new byte[128 / 8];
        Random rand = new Random(System.currentTimeMillis());
        rand.nextBytes(key);
        attributes.put(IBlockCipher.KEY_MATERIAL, key);
        int aesBlockSize = 128 / 8;
        byte[] offset = new byte[aesBlockSize];
        rand.nextBytes(offset);
        attributes.put(ICMGenerator.OFFSET, offset);
        int ndxLen = 0;
        int limit = aesBlockSize / 2;
        while (ndxLen < 1 || ndxLen > limit) ndxLen = rand.nextInt(limit + 1);
        attributes.put(ICMGenerator.SEGMENT_INDEX_LENGTH, Integer.valueOf(ndxLen));
        byte[] index = new byte[ndxLen];
        rand.nextBytes(index);
        attributes.put(ICMGenerator.SEGMENT_INDEX, new BigInteger(1, index));
        prng.setup(attributes);
        if (Configuration.DEBUG) log.exiting(ICMRandomSpi.class.getName(), ""resetLocalPRNG"");
    }
"
245,9414359,13,"    private static void testForAdditionStress(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> previousBits = empty(c);
        ExtendedSet<Integer> currentBits = empty(c);
        TreeSet<Integer> currentItems = new TreeSet<Integer>();
        Random rnd = new MersenneTwister();
        for (int i = 0; i < 100000; i++) {
            int item = rnd.nextInt(10000 + 1);
            previousBits = currentBits;
            currentBits = currentBits.clone();
            System.out.format(""Adding %d...\n"", item);
            boolean itemExistsBefore = currentItems.contains(item);
            boolean itemAdded = currentItems.add(item);
            boolean itemExistsAfter = currentItems.contains(item);
            boolean bitExistsBefore = currentBits.contains(item);
            boolean bitAdded = currentBits.add(item);
            boolean bitExistsAfter = currentBits.contains(item);
            if (itemAdded ^ bitAdded) {
                System.out.println(""wrong add() result"");
                return;
            }
            if (itemExistsBefore ^ bitExistsBefore) {
                System.out.println(""wrong contains() before"");
                return;
            }
            if (itemExistsAfter ^ bitExistsAfter) {
                System.out.println(""wrong contains() after"");
                return;
            }
            if (!checkContent(currentBits, currentItems)) {
                System.out.println(""add() error"");
                System.out.println(""Same elements: "" + (currentItems.toString().equals(currentBits.toString())));
                System.out.println(""\tcorrect: "" + currentItems.toString());
                System.out.println(""\twrong:   "" + currentBits.toString());
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> otherBits = previousBits.convert(currentItems);
            if (otherBits.hashCode() != currentBits.hashCode()) {
                System.out.println(""Representation error"");
                System.out.println(currentBits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> singleBitSet = empty(c);
            singleBitSet.add(item);
            if (currentItems.size() != currentBits.unionSize(singleBitSet)) {
                System.out.println(""Size error"");
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
        }
        System.out.println(""Final"");
        System.out.println(currentBits.debugInfo());
        System.out.println();
        System.out.println(IntSetStatistics.summary());
    }
"
500,19752106,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
234,8811298,13,"    static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
137,5037689,13,"    private void workForRandomPeriod(int minDuration, int maxDuration) {
        Random random = new Random();
        int period = minDuration + random.nextInt(maxDuration - minDuration);
        long start = Process.getElapsedCpuTime();
        while (Process.getElapsedCpuTime() - start < period) {
            for (int i = 0, temp = 0; i < 50; i++) {
                temp += i;
            }
        }
    }
"
148,5272382,13,"    private void addStat(int id, int submitTime, int dataId, int dataSize, int userId) throws SQLException {
        int runTime = MIN_RUNTIME + random.nextInt(MAX_RUNTIME - MIN_RUNTIME);
        stat.setInt(1, id);
        stat.setInt(2, submitTime);
        stat.setInt(3, runTime);
        stat.setInt(4, dataId);
        stat.setInt(5, dataSize);
        stat.setInt(6, userId);
        stat.addBatch();
    }
"
296,10489284,13,"    private int getRandomNumber(int lowerLimit, int upperLimit) {
        int randomNumber;
        while (true) {
            randomNumber = random.nextInt(upperLimit + 1);
            if (randomNumber >= lowerLimit) {
                break;
            }
        }
        return randomNumber;
    }
"
561,22485235,13,"    private static String calc(String exp) {
        if (exp.startsWith(""random"")) {
            int beg = exp.indexOf(""("");
            int end = exp.indexOf("")"");
            String[] ss = exp.substring(beg + 1, end).split("","");
            int rb = Integer.parseInt(ss[0]);
            int re = Integer.parseInt(ss[1]);
            int rr = rb + random.nextInt(re - rb);
            return String.valueOf(rr);
        }
        return exp;
    }
"
560,22230122,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        if (!m_dontReplaceMissing) {
            m_ReplaceMissingFilter.setInputFormat(instances);
            instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        }
        m_FullMeansOrModes = new double[instances.numAttributes()];
        m_FullMissingCounts = new int[instances.numAttributes()];
        if (m_displayStdDevs) {
            m_FullStdDevs = new double[instances.numAttributes()];
        }
        m_FullNominalCounts = new int[instances.numAttributes()][0];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_FullMissingCounts[i] = instances.attributeStats(i).missingCount;
            m_FullMeansOrModes[i] = instances.meanOrMode(i);
            if (instances.attribute(i).isNumeric()) {
                if (m_displayStdDevs) {
                    m_FullStdDevs[i] = Math.sqrt(instances.variance(i));
                }
                if (m_FullMissingCounts[i] == instances.numInstances()) {
                    m_FullMeansOrModes[i] = Double.NaN;
                }
            } else {
                m_FullNominalCounts[i] = instances.attributeStats(i).nominalCounts;
                if (m_FullMissingCounts[i] > m_FullNominalCounts[i][Utils.maxIndex(m_FullNominalCounts[i])]) {
                    m_FullMeansOrModes[i] = -1;
                }
            }
        }
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTableHashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        m_ClusterMissingCounts = new int[m_NumClusters][instances.numAttributes()];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                double[] vals = new double[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterMissingCounts[i][j] = tempI[i].attributeStats(j).missingCount;
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                        if (tempI[i].attribute(j).isNominal()) {
                            if (m_ClusterMissingCounts[i][j] > m_ClusterNominalCounts[i][j][Utils.maxIndex(m_ClusterNominalCounts[i][j])]) {
                                vals[j] = Instance.missingValue();
                            }
                        } else {
                            if (m_ClusterMissingCounts[i][j] == tempI[i].numInstances()) {
                                vals[j] = Instance.missingValue();
                            }
                        }
                    }
                    m_ClusterCentroids.add(new Instance(1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                if (converged) {
                    Instances[] t = new Instances[m_NumClusters];
                    int index = 0;
                    for (int k = 0; k < tempI.length; k++) {
                        if (tempI[k].numInstances() > 0) {
                            t[index++] = tempI[k];
                        }
                    }
                    tempI = t;
                } else {
                    tempI = new Instances[m_NumClusters];
                }
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        if (m_displayStdDevs) {
            m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        }
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            if (m_displayStdDevs) {
                double[] vals2 = new double[instances.numAttributes()];
                for (int j = 0; j < instances.numAttributes(); j++) {
                    if (instances.attribute(j).isNumeric()) {
                        vals2[j] = Math.sqrt(tempI[i].variance(j));
                    } else {
                        vals2[j] = Instance.missingValue();
                    }
                }
                m_ClusterStdDevs.add(new Instance(1.0, vals2));
            }
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
"
192,7106275,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
290,10274234,13,"    private void inintCluster(TextBasedDataSet dataSet) throws Exception {
        dataSet.generatePKList();
        m_Iterations = 0;
        m_ClusterCentroids = new ArrayList<TextBasedData>(m_NumClusters);
        m_ClusterCentroidsOwner = new TextBasedDataSet();
        m_ClusterCentroidsOwner.setAttrMeta(dataSet.getAttrMeta());
        m_clusterAssignments = new int[dataSet.getTextNumber()];
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap<String, Object> initC = new HashMap<String, Object>();
        String textKey = null;
        for (int j = dataSet.getTextNumber() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            textKey = dataSet.getKeyByPosition(instIndex);
            if (!initC.containsKey(textKey)) {
                m_ClusterCentroids.add(dataSet.getByListPosition(instIndex));
                initC.put(textKey, null);
            }
            try {
                dataSet.swap(j, instIndex);
            } catch (Exception e) {
                e.printStackTrace();
            }
            if (m_ClusterCentroids.size() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.size();
    }
"
131,5024007,13,"    public synchronized net.sourceforge.huntforgold.model.Ship createShip(int index, int nationality) {
        net.sourceforge.huntforgold.xml.Ship result = (net.sourceforge.huntforgold.xml.Ship) shipMap.get(new Integer(index));
        if (result != null) {
            counter = counter + 1;
            int uniqueId = counter;
            String name = result.getName();
            String pngImage = result.getPngImage();
            int typicalCrew = result.getTypicalCrew();
            int maxCrew = result.getMaxCrew();
            int maxCargo = result.getMaxCargo();
            int maxHitPoints = result.getMaxHitPoints();
            int maxSpeed = result.getMaxSpeed();
            int typicalCannons = result.getTypicalCannons();
            int maxCannons = result.getMaxCannons();
            double turnSpeed = result.getTurnSpeed();
            net.sourceforge.huntforgold.model.Ship ship = new net.sourceforge.huntforgold.model.Ship(uniqueId, name, pngImage, typicalCrew, maxCrew, maxCargo, maxHitPoints, maxSpeed, typicalCannons, maxCannons, turnSpeed, nationality);
            int crew = random.nextInt(maxCrew + 1);
            if (crew < 8) {
                crew = 8;
            }
            ship.setCrew(crew);
            ship.setCaptain(""Enemy captain"");
            ship.setFood(0);
            ship.setGoods(0);
            ship.setSugar(0);
            int cannons = random.nextInt(maxCannons + 1);
            if (cannons % 2 == 1) {
                cannons -= 1;
            }
            ship.setCannons(cannons);
            int gold = random.nextInt(51) * 20;
            ship.setGold(gold);
            return ship;
        } else {
            return null;
        }
    }
"
268,9708818,13,"    private Odds computePreflop(int flops, long holes, int activeOpponents, Card cards[], MersenneTwisterFast rand) {
        Odds odds = new Odds();
        for (int i = 0; i < flops; i++) {
            int xComA = rand.nextInt(COM_A + 1);
            swap(cards, xComA, COM_A);
            int xComB = rand.nextInt(COM_B + 1);
            swap(cards, xComB, COM_B);
            int xComC = rand.nextInt(COM_C + 1);
            swap(cards, xComC, COM_C);
            int xComD = rand.nextInt(COM_D + 1);
            swap(cards, xComD, COM_D);
            int xComE = rand.nextInt(COM_E + 1);
            swap(cards, xComE, COM_E);
            odds = odds.plus(computeOppOdds(activeOpponents, cards, holes, rand));
            swap(cards, xComE, COM_E);
            swap(cards, xComD, COM_D);
            swap(cards, xComC, COM_C);
            swap(cards, xComB, COM_B);
            swap(cards, xComA, COM_A);
        }
        return odds;
    }
"
577,22801754,13,"    private void generateHauptlinie(Random rnd) {
        final int O = 3;
        final int B = 10;
        final int A = 17;
        final int F = 21;
        final int G = 21;
        final int K = 17;
        final int M = 10;
        final int L = 1;
        int wert = rnd.nextInt(100) + 1;
        wert = wert - L;
        if (wert <= 0) {
            starclass = STAR_TYP_L;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_L + 1);
            return;
        }
        wert = wert - O;
        if (wert <= 0) {
            starclass = STAR_TYP_O;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_O + 1);
            return;
        }
        wert = wert - B;
        if (wert <= 0) {
            starclass = STAR_TYP_B;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_B + 1);
            return;
        }
        wert = wert - A;
        if (wert <= 0) {
            starclass = STAR_TYP_A;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_A + 1);
            return;
        }
        wert = wert - F;
        if (wert <= 0) {
            starclass = STAR_TYP_F;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_F + 1);
            return;
        }
        wert = wert - G;
        if (wert <= 0) {
            starclass = STAR_TYP_G;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_G + 1);
            return;
        }
        wert = wert - K;
        if (wert <= 0) {
            starclass = STAR_TYP_K;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_K + 1);
            return;
        }
        wert = wert - M;
        if (wert <= 0) {
            starclass = STAR_TYP_M;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_M + 1);
            return;
        }
    }
"
118,4482794,13,"    public int removeRandom(Forest f, int nEntries) {
        int nRemoved = 0;
        for (Node root : f.getTrees()) {
            for (int i = 0; i < nEntries; i++) {
                int nNodes = traverseTreePreorder(root, 0);
                if (nNodes <= 1) {
                    break;
                }
                int idx = 1 + randomIdx.nextInt(nNodes - 1);
                Node n = getNodeByPreorderIdx(root, new int[] { idx });
                Node parent = getParentOfPreorderIdx(root, null, new int[] { idx });
                if ((n != null) && (parent != null)) {
                    if (parent.getLeft() == n) {
                        parent.setLeft(null);
                    } else {
                        parent.setRight(null);
                    }
                    nRemoved++;
                }
            }
        }
        return nRemoved;
    }
"
286,10163526,13,"    public void testForward() throws IOException {
        System.out.println(""\nforward"");
        SimpleBufferTransformer bufferTransformer = new SimpleBufferTransformer();
        MyTransformer myTransformer = new MyTransformer();
        bufferTransformer.setNextTransformer(myTransformer);
        System.out.println(""one input - one forward"");
        ByteBuffer input = createRandomBuffer(100);
        int size = input.remaining();
        bufferTransformer.transform(input);
        ByteBuffer result = myTransformer.getInput();
        assertNull(result);
        bufferTransformer.forward(size);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""one input - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        bufferTransformer.transform(input);
        result = myTransformer.getInput();
        int firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        int secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
        System.out.println(""two inputs - one forward"");
        input = createRandomBuffer(100);
        size = input.remaining();
        bufferTransformer.transform(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        bufferTransformer.transform(input);
        bufferTransformer.forward(size);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""two inputs - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        bufferTransformer.transform(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        bufferTransformer.transform(input);
        firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
    }
"
68,2884214,13,"    public static String generateString(int minLength, int maxLength) {
        StringBuilder sb = new StringBuilder();
        int length = minLength + random.nextInt(maxLength - minLength);
        for (int i = 0; i < length; i++) {
            sb.append(CHARACTERS[random.nextInt(CHARACTERS.length)]);
        }
        return sb.toString();
    }
"
15,749901,13,"    private InputStream dataInStreamCommand(String cmd) {
        InputStream dataStream;
        if (passiveMode) {
            printCommand(""PASV"");
            waitForResult();
            getLastResult();
            int[] i = parsePassiveParentheses((String) lastlines.get(lastlines.size() - 1));
            String datahost = i[0] + ""."" + i[1] + ""."" + i[2] + ""."" + i[3];
            int dataport = (i[4] * 256) + i[5];
            try {
                dataPassiveConnection = new FTPPassiveConnection(datahost, dataport);
                dataStream = dataPassiveConnection.getIn();
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(cmd);
            waitForResult();
            getLastResult();
        } else {
            int port = portrange_lower + random.nextInt(portrange_upper - portrange_lower);
            System.out.println(""port "" + port);
            try {
                dataPortConnection = new FTPPortConnection(port);
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(""PORT "" + localip + "","" + port2ascii(port));
            waitForResult();
            getLastResult();
            printCommand(cmd);
            waitForResult();
            getLastResult();
            try {
                dataPortConnection.waitForConnection();
            } catch (InterruptedException e) {
                System.out.println(""Interrupted in join(): "" + e);
            }
            try {
                dataStream = dataPortConnection.getIn();
            } catch (IOException e) {
                System.out.println(""Can not establish connection :"" + e);
                return null;
            }
        }
        return dataStream;
    }
"
163,5805315,13,"    @Override
    public void mutate(PermutationGenotype<?> genotype, double p) {
        int size = genotype.size();
        if (size > 1) {
            for (int a = 0; a < size - 1; a++) {
                if (random.nextDouble() < p) {
                    int b;
                    do {
                        b = a + random.nextInt(size - a);
                    } while (b == a);
                    while (a < b) {
                        Collections.swap(genotype, a, b);
                        a++;
                        b--;
                    }
                }
            }
        }
    }
"
188,6944380,13,"        void doMovements() {
            Random r = new Random();
            int x = 0;
            int y = 0;
            int v = 0;
            executeAndWait(""c"", rm.out);
            while (rm.keepOn) {
                x = r.nextInt(XMAX - XMIN + 1) + XMIN;
                y = r.nextInt(YMAX - YMIN + 1) + YMIN;
                v = r.nextInt(VMAX + 1);
                v = VMAX;
                String command = ""x"" + x + ""y"" + y + ""v"" + v + ""m\r"";
                System.out.printf(""   x: %5d     y: %5d \n"", x, y);
                executeAndWait(command, rm.out);
            }
        }
"
88,3206815,13,"    public Operator addRandomValidOperatorTo(OperatorChain chain, RandomGenerator random) throws UndefinedParameterError, NoValidOperatorException {
        int which = random.nextInt(MAX_VALID_TYPE + 1);
        Operator vsOp = createValidOperator(which, random);
        addOperator(chain, vsOp, random);
        return vsOp;
    }
"
479,18515074,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        m_ReplaceMissingFilter.setInputFormat(instances);
        instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTable.hashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTable.hashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                double[] vals = new double[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                    }
                    m_ClusterCentroids.add(new Instance(1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                tempI = new Instances[m_NumClusters];
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            double[] vals2 = new double[instances.numAttributes()];
            for (int j = 0; j < instances.numAttributes(); j++) {
                if (instances.attribute(j).isNumeric()) {
                    vals2[j] = Math.sqrt(tempI[i].variance(j));
                } else {
                    vals2[j] = Instance.missingValue();
                }
            }
            m_ClusterStdDevs.add(new Instance(1.0, vals2));
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
"
390,14259881,13,"    private List<InetSocketAddressInfo> getPeerList(Hash fileId, Peer peer, int numNeighbors) {
        Map<InetSocketAddressInfo, Peer> peerMap = fileIdToPeerMap.get(fileId);
        int numSharers = peerMap.size();
        int missingNeighbors = ((int) Math.ceil(Math.log(numSharers))) + peerListAnswerConst - numNeighbors;
        List<InetSocketAddressInfo> peerListAnswer = new ArrayList<InetSocketAddressInfo>();
        if (peerMap == null) {
            return peerListAnswer;
        }
        Object[] peerList = peerMap.values().toArray();
        int lastPeer = peerList.length - 1;
        while (peerListAnswer.size() < missingNeighbors && lastPeer >= 0) {
            int randomPeer = random.nextInt(lastPeer + 1);
            Peer neighbor = (Peer) peerList[randomPeer];
            InetSocketAddressInfo address = neighbor.getAddress();
            if (!peer.neighbor(neighbor)) {
                peer.addNeighbor(neighbor);
                neighbor.addNeighbor(peer);
                peerListAnswer.add(neighbor.getAddress());
            }
            peerList[randomPeer] = peerList[lastPeer];
            peerList[lastPeer] = neighbor;
            lastPeer--;
        }
        return peerListAnswer;
    }
"
33,1410386,13,"    public static String getRandomStr(char startChr, char endChr) {
        int randomInt;
        String randomStr = null;
        int startInt = Integer.valueOf(startChr);
        int endInt = Integer.valueOf(endChr);
        if (startInt > endInt) {
            throw new IllegalArgumentException(""Start String: "" + startChr + "" End String: "" + endChr);
        }
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomInt = rnd.nextInt(endInt + 1);
            } while (randomInt < startInt);
            randomStr = (char) randomInt + """";
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return randomStr;
    }
"
322,11191280,13,"    public static Integer generateRandomInt(int upperLimit, boolean unique) {
        Integer randomInteger = null;
        if (unique) {
            do {
                randomInteger = generator.nextInt(upperLimit + 1);
            } while (set.contains(randomInteger));
            set.add(randomInteger);
        } else {
            randomInteger = generator.nextInt(upperLimit + 1);
        }
        return randomInteger;
    }
"
280,10048471,13,"    private TravellerChromosome algorithm(TravellerChromosome f, TravellerChromosome m) {
        MersenneTwister mt = MersenneTwister.getTwister();
        int genomeLength = f.getNumCities();
        f.canonicalize();
        m.canonicalize();
        TravellerChromosome fatherOffspring = new TravellerChromosome(f);
        TravellerChromosome motherOffspring = new TravellerChromosome(m);
        fatherOffspring.invalidateCities();
        motherOffspring.invalidateCities();
        int segmentLength = 2 + mt.nextInt(genomeLength - 3);
        int fatherStart = mt.nextInt(genomeLength);
        int motherOffset = mt.nextInt(genomeLength);
        boolean reverseMother = mt.nextBoolean();
        int mcx_to = 0;
        int fcx_to = 0;
        int mcx_from = 0;
        int fcx_from = 0;
        int mcnx = segmentLength;
        int fcnx = segmentLength;
        for (int i = 0; i < genomeLength; i++) {
            int fatherCity = f.getCity(i + fatherStart);
            int motherCity = m.getCity(i, motherOffset + fatherStart, reverseMother);
            int fatherCityIndexInMother = m.findCity(fatherCity, motherOffset, reverseMother);
            int motherCityIndexInFather = f.findCity(motherCity);
            if (m.indexIsInSegment(fatherCityIndexInMother, fatherStart, segmentLength, motherOffset, reverseMother)) {
                fatherOffspring.setCity(fcx_to, m.getCity(mcx_from, motherOffset + fatherStart, reverseMother));
                fcx_to++;
                mcx_from++;
            } else {
                fatherOffspring.setCity(fcnx, fatherCity);
                fcnx++;
            }
            if (f.indexIsInSegment(motherCityIndexInFather, fatherStart, segmentLength, 0, false)) {
                motherOffspring.setCity(mcx_to, f.getCity(fcx_from + fatherStart));
                mcx_to++;
                fcx_from++;
            } else {
                motherOffspring.setCity(mcnx, motherCity);
                mcnx++;
            }
        }
        TravellerChromosome child = null;
        if ((Population.areMinimizing() && (motherOffspring.testFitness() < fatherOffspring.testFitness())) || ((!Population.areMinimizing()) && (motherOffspring.testFitness() > fatherOffspring.testFitness()))) {
            child = motherOffspring;
        } else {
            child = fatherOffspring;
        }
        return child;
    }
"
22,868920,13,"    public TestThread(int minRunTime, int maxRunTime) {
        Random r = new Random();
        int min = minRunTime;
        int max = maxRunTime;
        actualRunTime = min + r.nextInt(max - min);
    }
"
116,4477236,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
346,11866933,13,"    public void doSomething() {
        String clientIdentifier = this.getClientIdentifier();
        if (!this.isRegisteredAtCoordinator()) {
            try {
                this.registerAtCoordinator();
            } catch (ParticipantException e) {
                System.out.println(""ConcreteService1 exception: "" + e.getLocalizedMessage());
            }
        }
        Random randomGenerator = new Random();
        int r = randomGenerator.nextInt(PROCESSINGTIME_MAX + 1);
        long sleepTimeMilli = 1000;
        if (r < PROCESSINGTIME_MIN) {
            sleepTimeMilli *= PROCESSINGTIME_MIN;
        } else {
            sleepTimeMilli *= r;
        }
        try {
            Thread.sleep(sleepTimeMilli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        r = randomGenerator.nextInt(101);
        if (r <= FAILURE_PROBABILITY) {
            System.out.println(""Concrete Service 1 - Request failed: "" + clientIdentifier);
            try {
                MessageContext messageContext = MessageContext.getCurrentContext();
                Message request = messageContext.getRequestMessage();
                AttributedURI messageID = HeaderProcessing.getMessageID(request);
                this.sendFault(""Internal service error. The request could not be processed correctly."", messageID);
            } catch (Exception e) {
                System.out.println(""ConcreteService1 exception: "" + e.getLocalizedMessage());
            }
            StatisticsManager.getInstance().addFinishedService(false);
        } else {
            StatisticsManager.getInstance().addFinishedService(true);
        }
    }
"
348,12409601,13,"    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context = new ContextStack();
        List<String> randomStrings = new ArrayList<String>();
        Random random = new Random();
        for (int i = 0, num = random.nextInt(100); i < num; ++i) {
            int minChar = 32, maxChar = 126;
            int stringSize = random.nextInt(30);
            StringBuilder buf = new StringBuilder();
            for (int j = 0; j < stringSize; ++j) {
                int charId = minChar + random.nextInt(maxChar - minChar);
                buf.append((char) charId);
            }
            randomStrings.add(buf.toString());
        }
        context.put(""name"", ""Tom"");
        context.put(""randomStrings"", randomStrings);
        context.put(""intArray"", intArray);
        context.put(""intList"", TemplateUtils.objectToCollection(intArray));
        context.put(""doubleArray"", doubleArray);
        context.put(""doubleList"", TemplateUtils.objectToCollection(doubleArray));
    }
"
18,802699,13,"    @Override
    void parseLine(String strLine) {
        String dest = strLine;
        int groupID = _randMemId.nextInt(_totNumOfTeams + 1);
        _missionID++;
        int month = _randDateMonth.nextInt(10);
        int day = _randDateDay.nextInt(26);
        String startDate = gerateDate(month, day);
        String endDate = gerateDate(month + 1, day + 1);
        _cols.clear();
        _vals.clear();
        _cols.add(""MissionID"");
        _cols.add(""GroupID"");
        _cols.add(""StartDate"");
        _cols.add(""EndDate"");
        _cols.add(""Location"");
        _cols.add(""State"");
        _vals.add(""'"" + _missionID + ""'"");
        _vals.add(""'"" + groupID + ""'"");
        _vals.add(""'"" + startDate + ""'"");
        _vals.add(""'"" + endDate + ""'"");
        _vals.add(""'"" + dest + ""'"");
        _vals.add(""'"" + ""NA"" + ""'"");
        genSQLInsertForTable(""missions"", _cols, _vals);
    }
"
272,9708819,13,"    private Odds computeFlop(int flops, long holes, int activeOpponents, Card cards[], MersenneTwisterFast rand) {
        Odds odds = new Odds();
        if (flops >= 1081) {
            int unknownCount = 52 - 2 - 3;
            FastIntCombiner fc = new FastIntCombiner(Card.INDEXES, unknownCount);
            TurnCommunityVisitor turn = new TurnCommunityVisitor(activeOpponents, cards, holes, rand);
            fc.combine(turn);
            odds = turn.odds();
        } else {
            for (int i = 0; i < flops; i++) {
                int xComD = rand.nextInt(COM_D + 1);
                swap(cards, xComD, COM_D);
                int xComE = rand.nextInt(COM_E + 1);
                swap(cards, xComE, COM_E);
                odds = odds.plus(computeOppOdds(activeOpponents, cards, holes, rand));
                swap(cards, xComE, COM_E);
                swap(cards, xComD, COM_D);
            }
        }
        return odds;
    }
"
310,10969249,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
528,20635236,13,"    private FuncionPorTramosVectorial creaFuncionColoresBandas(int minColores, int maxColores, Vector3d[] colores, Vector3d colorExtremos, Random random) {
        FuncionPorTramosVectorial funcionColores = new FuncionPorTramosVectorial();
        int numColores = minColores + random.nextInt(maxColores - minColores);
        if (numColores > 0) {
            if (colorExtremos != null) {
                funcionColores.nuevoPunto(0.0d, colorExtremos);
            } else {
                funcionColores.nuevoPunto(0.0d, colorBanda(colores, random));
            }
            if (numColores > 1) {
                funcionColores.nuevoPunto(1.0d, colorBanda(colores, random));
                if (numColores > 2) {
                    double lat = 0.0d;
                    double dLat = 1.0d / (numColores - 2);
                    for (int i = 2; i < numColores - 1; i++) {
                        lat += dLat + random.nextDouble() * 4.0d;
                        funcionColores.nuevoPunto(lat, colorBanda(colores, random));
                    }
                    lat += dLat + random.nextDouble() * 4.0d;
                    if (colorExtremos != null) {
                        funcionColores.nuevoPunto(lat, colorExtremos);
                    } else {
                        funcionColores.nuevoPunto(lat, colorBanda(colores, random));
                    }
                }
            }
            funcionColores.normalizarX();
        }
        return funcionColores;
    }
"
238,8896155,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
255,9414368,13,"    private static void testForPosition(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> bits = empty(c);
        Random rnd = new MersenneTwister(31);
        for (int i = 0; i < 1000; i++) {
            bits.clear();
            final int size = 1 + rnd.nextInt(10000);
            final int min = 1 + rnd.nextInt(10000 - 1);
            final int max = min + rnd.nextInt(10000 - min + 1);
            for (int j = 0; j < size; j++) {
                int item = min + rnd.nextInt(max - min + 1);
                bits.add(item);
            }
            String good = bits.toString();
            StringBuilder other = new StringBuilder();
            int s = bits.size();
            other.append('[');
            for (int j = 0; j < s; j++) {
                other.append(bits.get(j));
                if (j < s - 1) other.append("", "");
            }
            other.append(']');
            if (good.equals(other.toString())) {
                System.out.println(i + "") OK"");
            } else {
                System.out.println(""ERROR"");
                System.out.println(bits.debugInfo());
                System.out.println(bits);
                System.out.println(other);
                return;
            }
            int pos = 0;
            for (Integer x : bits) {
                if (bits.indexOf(x) != pos) {
                    System.out.println(""ERROR! "" + pos + "" != "" + bits.indexOf(x) + "" for element "" + x);
                    System.out.println(bits.debugInfo());
                    return;
                }
                pos++;
            }
        }
    }
"
533,20765197,13,"        public MyGamePanel() {
            font = new Font(""lucida sans regular"", Font.PLAIN, 16);
            Random rand = new Random();
            me = new Player();
            me.x = 10 + rand.nextInt(300 - 20);
            me.y = 10 + rand.nextInt(300 - 20);
            me.latestKey = (char) ('A' + rand.nextInt(26));
            players.put(""me"", me);
        }
"
218,8001809,13,"    public Simulator(String[] args) {
        super(""simulator"" + theirPopulation);
        int numpoints = Integer.parseInt(args[0]);
        int minseconds = Integer.parseInt(args[1]);
        int maxseconds = Integer.parseInt(args[2]);
        System.out.println(""Simulator: Will create "" + numpoints + "" dummy points"");
        for (int i = 0; i < numpoints; i++) {
            String[] names = { ""dummy."" + i };
            String[] empty = { ""-"" };
            String[] transaction = { ""Generic-\""simulator"" + theirPopulation + ""\"""" };
            String[] translation = { ""NumDecimals-\""2\"""" };
            String[] arch = { ""-"" };
            int period = minseconds + itsRandom.nextInt(maxseconds - minseconds);
            PointDescription pd = PointDescription.factory(names, ""Dummy "" + i, ""Dummy"" + i, """", ""sim"" + theirPopulation, transaction, empty, translation, empty, arch, """" + period + ""000000"", ""-1"", true);
            pd.populateServerFields();
        }
        theirPopulation++;
    }
"
46,2408138,13,"    public static int getRandomNum(int startNum, int endNum) {
        int randomNum = 0;
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomNum = rnd.nextInt(endNum + 1);
            } while (randomNum < startNum);
        } catch (Exception e) {
            Logger.getLogger(EgovStringUtil.class).debug(e);
        }
        return randomNum;
    }
"
93,3475974,13,"    private void addRandomApple() {
        Coordinate newCoord = null;
        boolean found = false;
        while (!found) {
            int newX = 1 + RNG.nextInt(mXTileCount - 2);
            int newY = 1 + RNG.nextInt(mYTileCount - 2);
            newCoord = new Coordinate(newX, newY);
            boolean collision = false;
            int snakelength = mSnakeTrail.size();
            for (int index = 0; index < snakelength; index++) {
                if (mSnakeTrail.get(index).equals(newCoord)) {
                    collision = true;
                }
            }
            found = !collision;
        }
        if (newCoord == null) {
            Log.e(TAG, ""Somehow ended up with a null newCoord!"");
        }
        mAppleList.add(newCoord);
    }
"
265,9598420,13,"    public static Integer generateRandomInt(int upperLimit, boolean unique) {
        Integer randomInteger = null;
        if (unique) {
            do {
                randomInteger = generator.nextInt(upperLimit + 1);
            } while (set.contains(randomInteger));
            set.add(randomInteger);
        } else {
            randomInteger = generator.nextInt(upperLimit + 1);
        }
        return randomInteger;
    }
"
584,23303673,13,"    protected void doSingle(int maxSize) {
        int sz = rand.nextInt(maxSize + 1);
        int sz2 = rand.nextInt(maxSize);
        OpenBitSet bs1 = getRandomSet(sz, rand.nextInt(sz + 1));
        OpenBitSet bs2 = getRandomSet(sz, rand.nextInt(sz2 + 1));
        DocSet a1 = new BitDocSet(bs1);
        DocSet a2 = new BitDocSet(bs2);
        DocSet b1 = getDocSet(bs1);
        DocSet b2 = getDocSet(bs2);
        checkEqual(bs1, b1);
        checkEqual(bs2, b2);
        iter(a1, b1);
        iter(a2, b2);
        OpenBitSet a_and = (OpenBitSet) bs1.clone();
        a_and.and(bs2);
        OpenBitSet a_or = (OpenBitSet) bs1.clone();
        a_or.or(bs2);
        OpenBitSet a_andn = (OpenBitSet) bs1.clone();
        a_andn.andNot(bs2);
        checkEqual(a_and, b1.intersection(b2));
        checkEqual(a_or, b1.union(b2));
        checkEqual(a_andn, b1.andNot(b2));
        assertEquals(a_and.cardinality(), b1.intersectionSize(b2));
        assertEquals(a_or.cardinality(), b1.unionSize(b2));
        assertEquals(a_andn.cardinality(), b1.andNotSize(b2));
    }
"
462,17800886,13,"    public void testIsSameBits() {
        Random rand = new Random(0L);
        for (int size = 0; size < 100; size++) {
            int[] ints = new int[(size + 7) / 8];
            IntArrayBitWriter w = new IntArrayBitWriter(ints, size);
            for (int i = 0; i < size; i++) w.writeBoolean(rand.nextBoolean());
            IntArrayBitReader r = new IntArrayBitReader(ints, size);
            IntArrayBitReader s = new IntArrayBitReader(ints, size);
            assertTrue(BitStreams.isSameBits(r, s));
            r.setPosition(0);
            s.setPosition(0);
            assertTrue(BitStreams.isSameBits(r, s));
            if (size > 0) {
                s.setPosition(0);
                int[] tints = ints.clone();
                int bit = rand.nextInt(size);
                int index = bit >> 5;
                int mask = 1 << (31 - (bit & 31));
                tints[index] ^= mask;
                IntArrayBitReader t = new IntArrayBitReader(tints, size);
                assertFalse(BitStreams.isSameBits(s, t));
                s.setPosition(0);
                t.setPosition(0);
                assertFalse(BitStreams.isSameBits(t, s));
                if (size > 2) {
                    int sub = 1 + rand.nextInt(size - 1);
                    s.setPosition(0);
                    t = new IntArrayBitReader(ints, size - sub);
                    assertFalse(BitStreams.isSameBits(s, t));
                    s.setPosition(0);
                    t.setPosition(0);
                    assertFalse(BitStreams.isSameBits(t, s));
                }
            }
        }
    }
"
367,12999076,13,"        void reset(Random random) {
            rfqAverageNumber = rfqAvgMin + random.nextInt(rfqAvgMax - rfqAvgMin);
        }
"
521,20336961,13,"    private void generateClassifierForNode(Instances data, Range classes, Random rand, Classifier classifier, Hashtable table) throws Exception {
        int[] indices = classes.getSelection();
        for (int j = indices.length - 1; j > 0; j--) {
            int randPos = rand.nextInt(j + 1);
            int temp = indices[randPos];
            indices[randPos] = indices[j];
            indices[j] = temp;
        }
        int first = indices.length / 2;
        int second = indices.length - first;
        int[] firstInds = new int[first];
        int[] secondInds = new int[second];
        System.arraycopy(indices, 0, firstInds, 0, first);
        System.arraycopy(indices, first, secondInds, 0, second);
        int[] sortedFirst = Utils.sort(firstInds);
        int[] sortedSecond = Utils.sort(secondInds);
        int[] firstCopy = new int[first];
        int[] secondCopy = new int[second];
        for (int i = 0; i < sortedFirst.length; i++) {
            firstCopy[i] = firstInds[sortedFirst[i]];
        }
        firstInds = firstCopy;
        for (int i = 0; i < sortedSecond.length; i++) {
            secondCopy[i] = secondInds[sortedSecond[i]];
        }
        secondInds = secondCopy;
        if (firstInds[0] > secondInds[0]) {
            int[] help = secondInds;
            secondInds = firstInds;
            firstInds = help;
            int help2 = second;
            second = first;
            first = help2;
        }
        m_Range = new Range(Range.indicesToRangeList(firstInds));
        m_Range.setUpper(data.numClasses() - 1);
        Range secondRange = new Range(Range.indicesToRangeList(secondInds));
        secondRange.setUpper(data.numClasses() - 1);
        MakeIndicator filter = new MakeIndicator();
        filter.setAttributeIndex("""" + (data.classIndex() + 1));
        filter.setValueIndices(m_Range.getRanges());
        filter.setNumeric(false);
        filter.setInputFormat(data);
        m_FilteredClassifier = new FilteredClassifier();
        if (data.numInstances() > 0) {
            m_FilteredClassifier.setClassifier(Classifier.makeCopies(classifier, 1)[0]);
        } else {
            m_FilteredClassifier.setClassifier(new weka.classifiers.rules.ZeroR());
        }
        m_FilteredClassifier.setFilter(filter);
        m_classifiers = table;
        if (!m_classifiers.containsKey(getString(firstInds) + ""|"" + getString(secondInds))) {
            m_FilteredClassifier.buildClassifier(data);
            m_classifiers.put(getString(firstInds) + ""|"" + getString(secondInds), m_FilteredClassifier);
        } else {
            m_FilteredClassifier = (FilteredClassifier) m_classifiers.get(getString(firstInds) + ""|"" + getString(secondInds));
        }
        m_FirstSuccessor = new ClassBalancedND();
        if (first == 1) {
            m_FirstSuccessor.m_Range = m_Range;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(m_Range.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances firstSubset = Filter.useFilter(data, rwv);
            m_FirstSuccessor.generateClassifierForNode(firstSubset, m_Range, rand, classifier, m_classifiers);
        }
        m_SecondSuccessor = new ClassBalancedND();
        if (second == 1) {
            m_SecondSuccessor.m_Range = secondRange;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(secondRange.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances secondSubset = Filter.useFilter(data, rwv);
            m_SecondSuccessor = new ClassBalancedND();
            m_SecondSuccessor.generateClassifierForNode(secondSubset, secondRange, rand, classifier, m_classifiers);
        }
    }
"
537,21135057,13,"    private static List<BitSet> makeRandomBitSetList(final long randomSeed, final int listSize, final int minBitsSize, final int maxBitsSize) {
        Random r = new Random(randomSeed);
        List<BitSet> resultList = new ArrayList<BitSet>(listSize);
        for (int i = 0; i < listSize; i++) {
            int arraySize = minBitsSize + r.nextInt(maxBitsSize - minBitsSize);
            resultList.add(makeRandomBitSet(r, arraySize));
        }
        return resultList;
    }
"
442,16451700,13,"    public static String getBestMove(String movesList) {
        if (movesList.length() > MAX_VARIANTS_LENGTH) {
            return """";
        }
        int i = 0;
        while (i < size && (!variantes[i].startsWith(movesList) || variantes[i].equals(movesList))) {
            i++;
        }
        if (i >= size) {
            return """";
        }
        int j = i;
        while (j < size && variantes[j].startsWith(movesList)) j++;
        int choice = i + rdm.nextInt(j - i);
        int lengthMoves = movesList.length();
        return variantes[choice].substring(lengthMoves, lengthMoves + 4);
    }
"
388,14121891,13,"    protected int getRandomValue(int min, int max) {
        int v = min + rand.nextInt(max - min);
        return rand.nextBoolean() ? v : -v;
    }
"
506,19862707,13,"    public static Agent createRandomAgent(final World world) {
        Position anywhere = world.getPlaces().get(0).getPos();
        Agent a = new Agent(anywhere, ""HumanGreen"", world);
        boolean hasCar = false;
        if (rand.nextFloat() < PROB_HAS_CAR) {
            hasCar = true;
        }
        int age = MIN_AGE + rand.nextInt(MAX_AGE - MIN_AGE);
        EasyTime workStart = new EasyTime(AVG_WORK_START, 0);
        EasyTime sleepEnd = new EasyTime(workStart).shift(-1, 0);
        EasyTime sleepStart = new EasyTime(sleepEnd).shift(-AVG_SLEEP_TIME, 0);
        workStart.blur(TWO_HOUR_BLUR);
        sleepEnd.blur(HALF_HOUR_BLUR);
        sleepStart.blur(TWO_HOUR_BLUR);
        a.set(AGE, new IntegerNumber(age));
        a.set(CUISINE, getRandomType(CUISINE_TYPES));
        a.set(LANGUAGE, getRandomType(LANGUAGE_TYPES));
        a.set(GENDER, getRandomType(GENDER_TYPES));
        a.set(PARTY_ANIMAL, getRandomType(PARTY_ANIMAL_TYPES));
        a.set(WORKAHOLIC, getRandomType(WORKAHOLIC_TYPES));
        a.set(HAS_CAR, new BooleanType(hasCar));
        a.set(ACTIVITY, Activity.ASLEEP);
        a.set(WORK_START, workStart);
        a.set(WORK_END, new EasyTime(workStart).shift(AVG_WORK_TIME, 0));
        a.set(SLEEP_PERIOD, new TimePeriod(sleepStart, sleepEnd));
        try {
            a.set(HOME, world.getRandomPlaceOfType(""Homes""));
        } catch (PlaceNotFoundException e) {
            throw new RuntimeException(""Can't find any homes Places. Did u create them?"");
        }
        try {
            a.set(OFFICE, world.getRandomPlaceOfType(""Offices""));
        } catch (PlaceNotFoundException e) {
            throw new RuntimeException(""Can't find any offices. Did u create them?"");
        }
        a.setPos(((Place) a.get(HOME)).getPos());
        return a;
    }
"
552,21668962,13,"    private static String calc(String exp) {
        if (exp.startsWith(""random"")) {
            int beg = exp.indexOf(""("");
            int end = exp.indexOf("")"");
            String[] ss = exp.substring(beg + 1, end).split("","");
            int rb = Integer.parseInt(ss[0]);
            int re = Integer.parseInt(ss[1]);
            int rr = rb + random.nextInt(re - rb);
            return String.valueOf(rr);
        }
        return exp;
    }
"
124,4925096,13,"    public static void main(String[] args) throws IOException {
        File dir = new File(""e:/algorithm/url"");
        int FILE_COUNT = 100;
        int FILE_SIZE = 10000000;
        int MAX_URL_LENGTH = 7;
        String[] words = { ""word1"", ""word2"", ""word3"", ""word4"", ""word5"", ""word6"", ""word7"" };
        Random rnd = new Random();
        for (int fileIndex = 0; fileIndex < FILE_COUNT; fileIndex++) {
            File file = new File(dir, ""url_"" + fileIndex + "".data"");
            file.createNewFile();
            PrintWriter writer = new PrintWriter(new FileOutputStream(file));
            for (int i = 0; i < FILE_SIZE; i++) {
                StringBuilder sb = new StringBuilder();
                int urlLen = rnd.nextInt(MAX_URL_LENGTH + 1);
                for (int len = 0; len < urlLen; len++) {
                    sb.append(words[rnd.nextInt(words.length)]);
                }
                writer.println(sb.toString());
            }
            writer.close();
            System.out.println(file.getName() + "" has been written ."");
        }
    }
"
412,15066658,13,"    public void crossOver(Object ao, Object bo, Object a1o, Object b1o) {
        Gene a = (Gene) ao;
        Gene b = (Gene) bo;
        Gene a1 = (Gene) a1o;
        Gene b1 = (Gene) b1o;
        int point = MyRandom.nextInt(bitsPerGene + 1);
        for (int j = 0; j < bitsPerGene; j++) {
            if (j < point) {
                a1.bits[j] = a.bits[j];
                b1.bits[j] = b.bits[j];
            } else {
                a1.bits[j] = b.bits[j];
                b1.bits[j] = a.bits[j];
            }
        }
    }
"
449,17048141,13,"    private void qSort(int[] a, int i, int j) {
        if (i >= j - 1) return;
        int rand = i + r.nextInt(j - i);
        if (rand < j - 1) {
            a[rand] += a[j - 1];
            a[j - 1] = a[rand] - a[j - 1];
            a[rand] -= a[j - 1];
        }
        int p = i;
        for (int k = i; k < j - 1; k++) {
            if (a[k] <= a[j - 1]) {
                if (p < k) {
                    a[p] = a[p] + a[k];
                    a[k] = a[p] - a[k];
                    a[p] = a[p] - a[k];
                }
                p++;
            }
        }
        if (p < j - 1) {
            a[p] += a[j - 1];
            a[j - 1] = a[p] - a[j - 1];
            a[p] -= a[j - 1];
        }
        qSort(a, i, p);
        qSort(a, p + 1, j);
    }
"
515,20253121,13,"    private void generateRandomPack2(BitSet pack) {
        pack.set(0, N, true);
        pack.set(N, C, false);
        for (int i = 0; i < N; i++) {
            int j = i + random.nextInt(C - i);
            if (i != j) {
                boolean temp = pack.get(i);
                pack.set(i, pack.get(j));
                pack.set(j, temp);
            }
        }
    }
"
481,18570252,13,"    public TravellerChromosome(TravellerWorld world, String originatorName) {
        super();
        m_world = world;
        m_originator = new String(originatorName);
        if (m_mt == null) {
            m_mt = MersenneTwister.getTwister();
        }
        m_fitness = Double.MAX_VALUE;
        m_fitnessValid = false;
        m_cityList = new Codon[m_world.getNumberOfCities()];
        for (int i = 0; i < m_cityList.length; i++) {
            m_cityList[i] = new Codon(t_model.nodeIndex[i]);
        }
        for (int currentSlot = m_cityList.length - 1; currentSlot > 0; currentSlot--) {
            int swapSlot = m_mt.nextInt(currentSlot + 1);
            int temp = m_cityList[swapSlot].get();
            m_cityList[swapSlot].set(m_cityList[currentSlot].get());
            m_cityList[currentSlot].set(temp);
        }
    }
"
536,20867230,13,"    public void testForward() throws IOException {
        System.out.println(""\nforward"");
        BufferForwarder bufferTransformer = new BufferForwarder(ByteBufferForwardingMode.DIRECT);
        byteBufferToArrayTransformer.setNextForwarder(bufferTransformer);
        MyByteBufferCopyForwarder myByteBufferCopyForwarder = new MyByteBufferCopyForwarder();
        bufferTransformer.setNextForwarder(myByteBufferCopyForwarder);
        System.out.println(""one input - one forward"");
        ByteBuffer input = createRandomBuffer(100);
        int size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        ByteBuffer result = myByteBufferCopyForwarder.getInput();
        assertNull(result);
        bufferTransformer.forward(size);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""one input - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        result = myByteBufferCopyForwarder.getInput();
        int firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        int secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
        System.out.println(""two inputs - one forward"");
        input = createRandomBuffer(100);
        size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        byteBufferToArrayTransformer.forward(input);
        bufferTransformer.forward(size);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""two inputs - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        byteBufferToArrayTransformer.forward(input);
        firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
    }
"
203,7305283,13,"    public Vector makeCorridor(int x, int y, byte direction, int max_length) throws Exception {
        Vector v = new Vector();
        int r;
        v.x = x;
        v.y = y;
        if (direction == Individual.EAST) {
            if (x + max_length > SIZE - 1) {
                max_length = SIZE - x - 1;
            }
        } else if (direction == Individual.SOUTH) {
            if (y + max_length > SIZE - 1) {
                max_length = SIZE - y - 1;
            }
        } else if (direction == Individual.WEST) {
            if (x - max_length < 0) {
                max_length = x - 1;
            }
        } else if (direction == Individual.NORTH) {
            if (y - max_length < 0) {
                max_length = y - 1;
            }
        }
        if (direction == Individual.EAST) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.x += 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (direction == Individual.WEST) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.x -= 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (direction == Individual.NORTH) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.y -= 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (direction == Individual.SOUTH) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.y += 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (v.y == SIZE - 2) {
            v.y += 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        } else if (v.x == SIZE - 2) {
            v.x += 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        } else if (v.y == 1) {
            v.y -= 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        } else if (v.x == 1) {
            v.x -= 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        }
        return v;
    }
"
141,5272380,13,"    public void generate(int numOfJobs, double reuse) throws Exception {
        this.createDatabase();
        int submitTime = 0;
        int threshold = numOfJobs - (int) (numOfJobs * (reuse / 100));
        int reuseLimit = numOfJobs - threshold;
        System.out.println(""-- LIMIAR: "" + threshold);
        System.out.println(""-- REUSE LIMIT: "" + reuseLimit);
        int[] datas = new int[threshold];
        for (int i = 0; i < threshold; i++) {
            random = new Random(System.nanoTime());
            datas[i] = MIN_DATA_SIZE + random.nextInt(MAX_DATA_SIZE - MIN_DATA_SIZE);
        }
        int id = 1;
        int count = 0;
        int dataId = 1;
        for (int i = 0; i < threshold; i++) {
            try {
                random = new Random(System.nanoTime());
                int userId = 1 + random.nextInt(QuotaScheduler.NUMBER_OF_USERS);
                this.addStat(id++, submitTime, dataId, datas[dataId - 1], userId);
                if (count++ == 1024) {
                    stat.executeBatch();
                    conn.commit();
                    count = 0;
                }
                submitTime += SUBMISSION_DELAY;
                dataId++;
            } catch (SQLException sqlException) {
                sqlException.printStackTrace();
            }
        }
        for (int i = 0; i < reuseLimit; ) {
            random = new Random(System.nanoTime());
            dataId = 1 + random.nextInt(threshold);
            int randomSubmitTime = random.nextInt(submitTime);
            int tasks = MIN_TASKS + random.nextInt(MAX_TASKS - MIN_TASKS);
            int userId = 1 + random.nextInt(QuotaScheduler.NUMBER_OF_USERS);
            for (int j = 0; j < tasks && i < reuseLimit; j++, i++) {
                this.addStat(id++, randomSubmitTime, dataId, datas[dataId - 1], userId);
                if (count++ == 1024) {
                    stat.executeBatch();
                    conn.commit();
                    count = 0;
                }
            }
        }
        this.close();
    }
"
328,11256091,13,"    private long getIdealLocation(IntervalSet neededBytes, long blockSize) {
        int fragmentCount = neededBytes.getNumberOfIntervals();
        if (fragmentCount >= MAX_FRAGMENTS) {
            int randomFragmentNumber = pseudoRandom.nextInt(fragmentCount + 1);
            if (randomFragmentNumber == fragmentCount) return neededBytes.getLast().getHigh() + 1; else return (neededBytes.getAllIntervalsAsList().get(randomFragmentNumber)).getLow();
        } else {
            return getRandomLocation(neededBytes.getFirst().getLow(), neededBytes.getLast().getHigh(), blockSize);
        }
    }
"
507,20010244,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
172,6353292,13,"    private Color getRandColor(int fc, int bc) {
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
291,10275021,13,"    public static String getRandomStr(char startChr, char endChr) {
        int randomInt;
        String randomStr = null;
        int startInt = Integer.valueOf(startChr);
        int endInt = Integer.valueOf(endChr);
        if (startInt > endInt) {
            throw new IllegalArgumentException(""Start String: "" + startChr + "" End String: "" + endChr);
        }
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomInt = rnd.nextInt(endInt + 1);
            } while (randomInt < startInt);
            randomStr = (char) randomInt + """";
        } catch (Exception e) {
            Logger.getLogger(EgovStringUtil.class).debug(e);
        }
        return randomStr;
    }
"
432,16204711,13,"    private void addRandomApple() {
        Coordinate newCoord = null;
        boolean found = false;
        while (!found) {
            int newX = 1 + RNG.nextInt(mXTileCount - 2);
            int newY = 1 + RNG.nextInt(mYTileCount - 2);
            newCoord = new Coordinate(newX, newY);
            boolean collision = false;
            int snakelength = mSnakeTrail.size();
            for (int index = 0; index < snakelength; index++) {
                if (mSnakeTrail.get(index).equals(newCoord)) {
                    collision = true;
                }
            }
            found = !collision;
        }
        if (newCoord == null) {
            Log.e(TAG, ""Somehow ended up with a null newCoord!"");
        }
        mAppleList.add(newCoord);
    }
"
312,11039579,13,"    public void doSomething() {
        if (!this.isRegisteredAtCoordinator()) {
            try {
                this.registerAtCoordinator();
            } catch (ParticipantException e) {
                System.out.println(""ConcreteService2 exception: "" + e.getLocalizedMessage());
            }
        }
        Random randomGenerator = new Random();
        int r = randomGenerator.nextInt(PROCESSINGTIME_MAX + 1);
        long sleepTimeMilli = 1000;
        if (r < PROCESSINGTIME_MIN) {
            sleepTimeMilli *= PROCESSINGTIME_MIN;
        } else {
            sleepTimeMilli *= r;
        }
        try {
            Thread.sleep(sleepTimeMilli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        StatisticsManager.getInstance().addFinishedService(true);
    }
"
49,2446339,13,"    private static double getMinimumDistanceBetweenHubSubMangersForHub(StringMatrix matrix, int targetHubId) {
        double minimumDistance = Double.MAX_VALUE;
        int minIndex = -1;
        int maxIndex = -1;
        for (int i = 0; i < matrix.getNumberOfRows(); i++) {
            int currentHub = matrix.convertDoubleToInteger(i, 0);
            if (currentHub == targetHubId) {
                if (minIndex == -1) {
                    minIndex = i;
                }
                maxIndex = i;
            }
        }
        if (minIndex == maxIndex) {
            return -1.0;
        }
        Random random = new Random();
        for (int i = 0; i < 100; i++) {
            int rowFirstHubSubManager = minIndex + random.nextInt(maxIndex - minIndex);
            int rowSecondHubSubManager = minIndex + random.nextInt(maxIndex - minIndex);
            if (rowFirstHubSubManager == rowSecondHubSubManager) {
                continue;
            }
            Coord coordinateFirstHubSubManager = new CoordImpl(matrix.getDouble(rowFirstHubSubManager, 1), matrix.getDouble(rowFirstHubSubManager, 2));
            Coord coordinateSecondHubSubManager = new CoordImpl(matrix.getDouble(rowSecondHubSubManager, 1), matrix.getDouble(rowSecondHubSubManager, 2));
            if (GeneralLib.getDistance(coordinateFirstHubSubManager, coordinateSecondHubSubManager) < minimumDistance) {
                minimumDistance = GeneralLib.getDistance(coordinateFirstHubSubManager, coordinateSecondHubSubManager);
            }
        }
        while (minimumDistance == Double.MAX_VALUE) {
            return -1.0;
        }
        return minimumDistance;
    }
"
259,9414369,13,"    private static void testForSkip(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> bits = empty(c);
        Random rnd = new MersenneTwister(31);
        for (int i = 0; i < 10000; i++) {
            int max = rnd.nextInt(10000);
            bits = bits.convert(new RandomNumbers.Uniform(rnd.nextInt(1000), rnd.nextDouble() * 0.999, rnd.nextInt(100)).generate());
            for (int j = 0; j < 100; j++) {
                int skip = rnd.nextInt(max + 1);
                boolean reverse = rnd.nextBoolean();
                System.out.format(""%d) size=%d, skip=%d, reverse=%b ---> "", (i * 100) + j + 1, bits.size(), skip, reverse);
                ExtendedIterator<Integer> itr1, itr2;
                if (!reverse) {
                    itr1 = bits.iterator();
                    itr2 = bits.iterator();
                    while (itr1.hasNext() && itr1.next() < skip) {
                    }
                } else {
                    itr1 = bits.descendingIterator();
                    itr2 = bits.descendingIterator();
                    while (itr1.hasNext() && itr1.next() > skip) {
                    }
                }
                if (!itr1.hasNext()) {
                    System.out.println(""Skipped!"");
                    continue;
                }
                itr2.skipAllBefore(skip);
                itr2.next();
                Integer i1, i2;
                if (!(i1 = itr1.next()).equals(i2 = itr2.next())) {
                    System.out.println(""Error!"");
                    System.out.println(""i1 = "" + i1);
                    System.out.println(""i2 = "" + i2);
                    System.out.println(bits.debugInfo());
                    return;
                }
                System.out.println(""OK!"");
            }
        }
        System.out.println(""Done!"");
    }
"
25,914783,13,"    private InputStream dataInStreamCommand(String cmd) {
        InputStream dataStream;
        if (passiveMode) {
            printCommand(""PASV"");
            waitForResult();
            getLastResult();
            int[] i = parsePassiveParentheses((String) lastlines.get(lastlines.size() - 1));
            String datahost = i[0] + ""."" + i[1] + ""."" + i[2] + ""."" + i[3];
            int dataport = (i[4] * 256) + i[5];
            try {
                dataPassiveConnection = new FTPPassiveConnection(datahost, dataport);
                dataStream = dataPassiveConnection.getIn();
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(cmd);
            waitForResult();
            getLastResult();
        } else {
            int port = portrange_lower + random.nextInt(portrange_upper - portrange_lower);
            System.out.println(""port "" + port);
            try {
                dataPortConnection = new FTPPortConnection(port);
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(""PORT "" + localip + "","" + port2ascii(port));
            waitForResult();
            getLastResult();
            printCommand(cmd);
            waitForResult();
            getLastResult();
            try {
                dataPortConnection.waitForConnection();
            } catch (InterruptedException e) {
                System.out.println(""Interrupted in join(): "" + e);
            }
            try {
                dataStream = dataPortConnection.getIn();
            } catch (IOException e) {
                System.out.println(""Can not establish connection :"" + e);
                return null;
            }
        }
        return dataStream;
    }
"
426,15666494,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
220,8008369,13,"    private Object generateValue(int parentLevel) {
        int maxValueType = V_ARRAY;
        if (parentLevel >= maxLevel && nodeCount >= minNodeCount) maxValueType = V_NULL;
        int valueType = random.nextInt(maxValueType + 1);
        nodeCount++;
        switch(valueType) {
            case V_STRING:
                return generateString();
            case V_INT:
                return generateInt();
            case V_DOUBLE:
                return generateDouble();
            case V_BOOLEAN:
                return generateBoolean();
            case V_NULL:
                return null;
            case V_OBJECT:
                return generateObjectMeta(parentLevel + 1);
            case V_ARRAY:
                return generateArrayMeta(parentLevel + 1);
        }
        return null;
    }
"
42,2407324,13,"    @Override
    public Bitmap apply(Bitmap source) {
        Bitmap dest = source.clone();
        int w = dest.getWidth();
        int h = dest.getHeight();
        for (int x = 0; x < w; x++) for (int y = 0; y < h; y++) {
            int px = dest.getPixel(x, y);
            int l = mRand.nextInt(mLevel + 1);
            int nx = x + l;
            if (nx >= w) nx = w - 1;
            int ny = y + l;
            if (ny >= h) ny = h - 1;
            dest.setPixel(nx, ny, px);
        }
        return dest;
    }
"
542,21360254,13,"    public Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
365,12883936,13,"    public void testFuzz() throws Exception {
        Model model = getTestModel();
        StackEvaluator eval = new LazyStackEvaluator();
        PrintStream errStream = new PrintStream(new NullOutputStream());
        QueryEngine qe = new QueryEngine(model, eval, System.out, errStream);
        Collector<RippleList, RippleException> expected = new Collector<RippleList, RippleException>();
        Collector<RippleList, RippleException> results = new Collector<RippleList, RippleException>();
        QueryPipe qp = new QueryPipe(qe, results);
        ModelConnection mc = qe.getConnection();
        RippleValue five = mc.value(5);
        byte[] bytes = new byte[128];
        for (int i = 0; i < bytes.length; i++) {
            bytes[i] = (i >= 32) ? (byte) i : (i >= 16) ? (byte) '\n' : (byte) '\t';
        }
        for (int i = 0; i < REPEAT; i++) {
            int len = MAX_EXPR_LENGTH + rand.nextInt(MAX_EXPR_LENGTH - MIN_EXPR_LENGTH);
            byte[] expr = new byte[len];
            for (int j = 0; j < len; j++) {
                expr[j] = bytes[rand.nextInt(bytes.length)];
            }
            String s = new String(expr);
            qp.put(new String(expr));
            qp.put("".\n"");
            qp.put("".\n"");
            qp.put("".\n"");
            results.clear();
            qp.put(""2 3 add >> .\n"");
            expected.clear();
            expected.put(createStack(mc, five));
            assertCollectorsEqual(expected, results);
        }
        qp.close();
        mc.close();
    }
"
126,4987113,13,"    private static Color _GetRandColor(int fc, int bc) {
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
429,16136108,13,"    public Map<Id, List<Id>> run() {
        int cliqueSize = minCliqueSize + randomGen.nextInt(maxCliqueSize - minCliqueSize);
        List<Person> clique = new ArrayList<Person>(maxCliqueSize);
        int count = 0;
        this.cliques.clear();
        for (Person person : this.population.getPersons().values()) {
            if (count < cliqueSize) {
                count++;
                clique.add(person);
            } else {
                processClique(clique);
                cliqueSize = minCliqueSize + randomGen.nextInt(maxCliqueSize - minCliqueSize);
                clique.clear();
                clique.add(person);
                count = 1;
            }
        }
        return this.cliques;
    }
"
113,4409393,13,"        public static <T> int randomizedPartition(List<T> array, int startIndex, int endIndex, Comparator<T> comparator) {
            int i = startIndex + random.nextInt(endIndex - startIndex);
            swap(array, i, startIndex);
            return partition(array, startIndex, endIndex, comparator);
        }
"
57,2655635,13,"    public static Color getRandColor(int fc, int bc) {
        fc = Math.min(fc, 255);
        bc = Math.min(bc, 255);
        final int r = fc + random.nextInt(bc - fc);
        final int g = fc + random.nextInt(bc - fc);
        final int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
222,8206774,13,"    private TravellerChromosome algorithm(TravellerChromosome parent) {
        MersenneTwister mt = MersenneTwister.getTwister();
        TravellerChromosome offspring = new TravellerChromosome(parent);
        offspring.canonicalize();
        double startingFitness = offspring.testFitness();
        int genomeLength = TravellerWorld.getTravellerWorld().getNumberOfCities();
        int permuteGlobalLimit = PermutationController.getGlobalPermuteLimit();
        int permuteStartingLimit = PermutationController.getStartingPermuteLimit();
        int permuteCurrentLimit = PermutationController.getCurrentPermuteLimit();
        double selectionChance = 0.0D;
        if (genomeLength > permuteGlobalLimit) {
            selectionChance = ((double) permuteCurrentLimit) / ((double) (permuteStartingLimit + permuteGlobalLimit));
        } else {
            selectionChance = ((double) permuteGlobalLimit) / 100.0D;
        }
        int selectees[] = new int[genomeLength];
        boolean selected[] = new boolean[genomeLength];
        for (int i = 0; i < genomeLength; i++) {
            selectees[i] = -1;
            selected[i] = false;
        }
        int offset = mt.nextInt(genomeLength);
        int selectionCount = 0;
        for (int i = 0; i < genomeLength; i++) {
            if (mt.nextDouble() < selectionChance) {
                selectees[selectionCount] = parent.getCity(i + offset);
                selected[(i + offset) % genomeLength] = true;
                selectionCount++;
            }
            if (selectionCount >= permuteCurrentLimit) {
                break;
            }
        }
        if (selectionCount != 0) {
            int unselectedIndex = 0;
            int copiedCount = 0;
            int lefties = mt.nextInt(genomeLength - selectionCount);
            while (copiedCount < lefties) {
                while (selected[unselectedIndex]) {
                    unselectedIndex++;
                }
                offspring.setCity(copiedCount, parent.getCity(unselectedIndex));
                unselectedIndex++;
                copiedCount++;
            }
            for (int currentSlot = selectionCount - 1; currentSlot > 0; currentSlot--) {
                int swapSlot = mt.nextInt(currentSlot + 1);
                int temp = selectees[swapSlot];
                selectees[swapSlot] = selectees[currentSlot];
                selectees[currentSlot] = temp;
            }
            for (int i = 0; i < selectionCount; i++) {
                offspring.setCity(copiedCount, selectees[i]);
                copiedCount++;
            }
            while (copiedCount < genomeLength) {
                while (selected[unselectedIndex]) {
                    unselectedIndex++;
                }
                offspring.setCity(copiedCount, parent.getCity(unselectedIndex));
                unselectedIndex++;
                copiedCount++;
            }
        }
        offspring.canonicalize();
        double finalFitness = offspring.testFitness();
        if (adaptPermutation) {
            if ((finalFitness > startingFitness) || (Math.abs(finalFitness - startingFitness) < TravellerStatus.LITTLE_FUZZ)) {
                PermutationController.reportFailure();
            } else {
                PermutationController.reportSuccess();
            }
        }
        return offspring;
    }
"
396,14485003,13,"        private ZoomInfo createRandomZoomInfo() {
            int angle = MIN_ROTATION + RANDOM.nextInt(MAX_ROTATION - MIN_ROTATION);
            if (RANDOM.nextBoolean()) {
                angle = -angle;
            }
            final float offsetX = MIN_OFFSET + RANDOM.nextFloat() * (MAX_OFFSET - MIN_OFFSET);
            final float offsetY = MIN_OFFSET + RANDOM.nextFloat() * (MAX_OFFSET - MIN_OFFSET);
            int driftAngle = (int) (Math.atan2(offsetY, offsetX) * 180 / Math.PI);
            return new ZoomInfo(MIN_SCALE + RANDOM.nextFloat() * (MAX_SCALE - MIN_SCALE), offsetX, offsetY, angle, RANDOM.nextBoolean(), DRIFT_AMOUNT, DRIFT_TIME, driftAngle);
        }
"
518,20277574,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
190,6979194,13,"    Geometry createGeometry() {
        double center_x = meansize + (rand.nextDouble() * (xrange - (2 * meansize)));
        double center_y = meansize + (rand.nextDouble() * (yrange - (2 * meansize)));
        double size = rand.nextDouble() * 2 * meansize;
        int n_vertices = 3 + rand.nextInt(max_vertices - 3);
        double[] angles = new double[n_vertices];
        double[] distances = new double[n_vertices];
        for (int k = 0; k < n_vertices; k++) {
            angles[k] = rand.nextDouble() * 2 * Math.PI;
            distances[k] = rand.nextDouble() * size;
        }
        sort(angles);
        Coordinate[] coords = new Coordinate[n_vertices + 1];
        for (int k = 0; k < n_vertices; k++) {
            double x = center_x + (distances[k] * Math.cos(angles[k]));
            double y = center_y + (distances[k] * Math.sin(angles[k]));
            coords[k] = new Coordinate(x, y);
        }
        coords[n_vertices] = coords[0];
        CoordinateSequence cs = new CoordinateArraySequence(coords);
        return new LineString(cs, gfact);
    }
"
569,22513686,13,"    public static int[] calculateMinerals(Solar planet, Random rng) {
        int[] deposits = new int[PlanetResources.Minerals.values().length];
        switch(planet.ptype) {
            case BARE_ROCK:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(401) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(205) / 100;
                break;
            case ATM_ROCK:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(401) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(105) / 100;
                break;
            case CLOUD:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(201) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(103) / 100;
                break;
            case EARTH:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(401) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(103) / 100;
                break;
            case ICE:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(301) / 300;
                break;
            default:
        }
        final int promotionFactor = calculateRichness(planet);
        for (int i = 0; i < deposits.length; i++) {
            if (deposits[i] != 0) {
                int rich = rng.nextInt(promotionFactor + 1);
                rich += deposits[i] - 1;
                deposits[i] = rich;
            }
        }
        return deposits;
    }
"
5,479569,13,"    public DSoCService(int MaximumNumberOfSegmentation) {
        MAX_NUMBER_OF_SES = MaximumNumberOfSegmentation;
        Random rand = new Random();
        int RandNum = rand.nextInt(MAX_NUMBER_OF_SES + 1);
        NUMBER_OF_SES = (RandNum < 3) ? 3 : RandNum;
        hx_SES = new SES[NUMBER_OF_SES];
        sx_SES = new SES[NUMBER_OF_SES];
        NumberFormat nf = NumberFormat.getInstance();
        nf.setMinimumIntegerDigits(4);
        nf.setMaximumIntegerDigits(4);
        str_Name = ""Service"" + nf.format((long) NameSec);
        NameSec++;
        init_SESs();
    }
"
284,10056156,13,"    public void buildClusterer(Instances data) throws Exception {
        m_Iterations = 0;
        if (data.checkForStringAttributes()) {
            throw new Exception(""Can't handle string attributes!"");
        }
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        m_ReplaceMissingFilter.setInputFormat(instances);
        instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(m_Seed);
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTable.hashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTable.hashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                float[] vals = new float[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                    }
                    m_ClusterCentroids.add(new Instance((float) 1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                tempI = new Instances[m_NumClusters];
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            float[] vals2 = new float[instances.numAttributes()];
            for (int j = 0; j < instances.numAttributes(); j++) {
                if (instances.attribute(j).isNumeric()) {
                    vals2[j] = (float) Math.sqrt(tempI[i].variance(j));
                } else {
                    vals2[j] = Instance.missingValue();
                }
            }
            m_ClusterStdDevs.add(new Instance((float) 1.0, vals2));
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
"
374,13281621,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
316,11051820,13,"    public Object newValue(Random random) {
        if (random.nextBoolean()) {
            return """";
        }
        StringBuilder strBuilder = new StringBuilder();
        int remainingLength = minLength + random.nextInt(maxLength - minLength);
        boolean endsWithPunctuation = random.nextBoolean();
        if (endsWithPunctuation) {
            remainingLength--;
        }
        String word = getWord(remainingLength, random);
        strBuilder.append(word);
        remainingLength -= word.length();
        while (remainingLength > 1) {
            strBuilder.append(getChar(midPunctuation, random));
            remainingLength--;
            word = getWord(remainingLength, random);
            strBuilder.append(word);
            remainingLength -= word.length();
        }
        if (endsWithPunctuation) {
            strBuilder.append(getChar(endPunctuation, random));
        }
        return strBuilder.toString();
    }
"
37,1801671,13,"    public String generateValidValue(Map<ConstraintType, Constraint> constraints) throws UnsupportedConstraintException, MissingPropertyException {
        for (ConstraintType constraintType : constraints.keySet()) {
            if (!supportedConstraintTypes.contains(constraintType)) {
                throw new UnsupportedConstraintException(this, constraintType);
            }
        }
        String value = null;
        if (constraints.containsKey(ConstraintType.LENGTH)) {
            Integer max = (Integer) constraints.get(ConstraintType.LENGTH).getProperty(""max"");
            Integer min = (Integer) constraints.get(ConstraintType.LENGTH).getProperty(""min"");
            if (max == null && min == null) {
                throw new MissingPropertyException(constraints.get(ConstraintType.LENGTH), ""min"", ""Expected at least one of properties [min, max] for Constraint of type LENGTH."");
            }
            min = (min == null ? 0 : min);
            max = (max == null ? Integer.MAX_VALUE : max);
            int length = min + random.nextInt(max - min);
            value = RandomStringUtils.random(length);
            return value;
        } else if (constraints.containsKey(ConstraintType.NOTNULL)) {
            return ""notnull"";
        }
        return value;
    }
"
485,18758340,13,"    private FramedMessage createFramedMessage(int headerLength) throws IOException {
        int MAX = (int) Math.pow(2, 8 * headerLength) - 1;
        System.out.println(""MAX = "" + MAX);
        final int MESSAGE_LENGTH = random.nextInt(MAX + 1);
        System.out.println(""MESSAGE_LENGTH = "" + MESSAGE_LENGTH + "" Byte"");
        return createFramedMessage(headerLength, MESSAGE_LENGTH);
    }
"
512,20027640,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
168,6310113,13,"    private Color getRandColor(int fc, int bc) {
        int fc_a = fc;
        int bc_a = bc;
        Random random = new Random();
        if (fc > 255) fc_a = 255;
        if (bc > 255) bc_a = 255;
        int r = fc + random.nextInt(bc_a - fc_a);
        int g = fc + random.nextInt(bc_a - fc_a);
        int b = fc + random.nextInt(bc_a - fc_a);
        return new Color(r, g, b);
    }
"
393,14416348,13,"    void createArtificialROIs(int howMany) {
        int nCandidates = 2 * howMany;
        Vector<Rectangle> candidates = new Vector<Rectangle>();
        int maxX = imageDim.width - displayDim.width;
        int maxY = imageDim.height - displayDim.height;
        {
            int way = 0;
            if (way == 0) {
                for (int i = 0; i < nCandidates; i++) {
                    int x = rand.nextInt(maxX + 1);
                    int y = rand.nextInt(maxY + 1);
                    candidates.add(new Rectangle(new Point(x, y), displayDim));
                }
            } else if (way == 1) {
            }
        }
        {
            int way = 0;
            if (way == 0) {
                for (int i = 0; i < howMany; i++) {
                    Rectangle rect = candidates.remove(rand.nextInt(candidates.size()));
                    ROI roi = new ROI(rect.getLocation(), rect.getSize(), null);
                    roi.setStaticRelevance(ARTIFICIAL_RELEVANCE);
                    rois.add(roi);
                }
            } else if (way == 1) {
            }
        }
    }
"
152,5279574,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
386,14015068,13,"    public static void main(String[] args) {
        StatisticsManager.getInstance().startEvaluation(NUMBER_TRANSACTIONS);
        ClientStarter starter;
        int numberParticipants;
        Random randomGenerator = new Random();
        for (int i = 0; i < NUMBER_TRANSACTIONS; i++) {
            numberParticipants = randomGenerator.nextInt(NUMBER_PARTICIPANTS_MAX + 1);
            if (numberParticipants < NUMBER_PARTICIPANTS_MIN) {
                numberParticipants = NUMBER_PARTICIPANTS_MIN;
            }
            starter = new ClientStarter(i + 1, NUMBER_TRANSACTIONS, USE_ABSTRACTSERVICE, numberParticipants, COMPENSATION_FAILURE_PROBABILITY);
            starter.start();
            try {
                Thread.sleep(TIME_SLEEP);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
"
377,13431733,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
456,17624942,13,"        public Layer(int num, ALayer pl, int inputs_per_neuron) {
            prevLayer = pl;
            index = num;
            ANeuron[] copyN;
            ANeuron[] inputsChoosen = new ANeuron[inputs_per_neuron];
            prevLayer = pl;
            ALayer aLayer;
            ANeuron choosen;
            Neuron berle = new Neuron();
            layerProgress = 0;
            boolean tryAgain;
            inputsToNeuron = inputs_per_neuron;
            number = c.getLayerNeuronsNumber(num);
            inumber = c.getLayerInitialNeuronsNumber(num);
            if (number > inumber) {
                number = inumber;
            }
            int actInput, golayer, which, s;
            berle.init(ja, inputsChoosen, inputs_per_neuron);
            mode = PASSIVE;
            prevLayer.computeOutputs();
            for (int i = 0; i < inumber; i++) {
                copyN = prevLayer.getRandomNeurons(2);
                inputsChoosen[0] = copyN[0];
                inputsChoosen[1] = copyN[1];
                actInput = 2;
                while (actInput < inputs_per_neuron) {
                    do {
                        aLayer = prevLayer;
                        switch(c.getParents()) {
                            case NetworkConfiguration.YOUNG:
                                if (actInput >= aLayer.getNumber()) {
                                    aLayer = aLayer.getPreviousLayer();
                                }
                                break;
                            case NetworkConfiguration.YOUNGER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= j--) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.MIDDLE:
                                s = myRandom.nextInt(num + 1);
                                for (int j = 0; j < s; j++) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLDER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= (num - (--j))) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLD:
                                if (actInput >= aLayer.getNumber()) {
                                    while ((aLayer.getPreviousLayer() != null) && (aLayer.getPreviousLayer().getPreviousLayer() != null)) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                } else {
                                    while ((aLayer != null) && (aLayer.getPreviousLayer() != null)) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                        }
                        choosen = aLayer.getNeuron(myRandom.nextInt(aLayer.getNumber()));
                        tryAgain = false;
                        for (int j = 0; j < actInput; j++) {
                            if (inputsChoosen[j].equals(choosen)) {
                                tryAgain = true;
                            }
                        }
                    } while (tryAgain);
                    inputsChoosen[actInput] = choosen;
                    actInput++;
                }
                do {
                    which = myRandom.nextInt(u.getNeuronsNumber());
                } while (!c.neuronTypeAllowed(which));
                int train;
                do {
                    train = myRandom.nextInt(u.getTrainersNumber());
                } while (!GlobalConfig.getInstance().getGac().neuronTrainerAllowed(train));
                try {
                    n[i] = (Neuron) u.getNeuronClass(which).newInstance();
                    n[i].init(ja, inputsChoosen, inputs_per_neuron, u.getNeuronConfig(which));
                    Trainer tt = (Trainer) u.getTrainerClass(train).newInstance();
                    tt.init(n[i], tt, n[i].getCoefsNumber());
                    n[i].setTrainer(tt);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    i--;
                } catch (InstantiationException e) {
                    e.printStackTrace();
                    i--;
                }
            }
            mode = ACTIVE;
        }
"
551,21625693,13,"    public void buildClusterer(Instances data) throws Exception {
        for (int i = 0; i < m_NumClusters; i++) {
            bucket[i] = new ArrayList<bucketInstance>();
        }
        bucketSize = (int) Math.ceil(data.numInstances() / (double) m_NumClusters);
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        m_ReplaceMissingFilter.setInputFormat(instances);
        instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTableHashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        while (!converged) {
            for (int j = 0; j < m_NumClusters; j++) {
                bucket[j] = new ArrayList<bucketInstance>();
            }
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            if (m_Iterations > maxIterations) {
                converged = true;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                double[] vals = new double[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                    }
                    m_ClusterCentroids.add(new DenseInstance(1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                tempI = new Instances[m_NumClusters];
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        for (int j = 0; j < m_NumClusters; j++) {
            bucket[j] = new ArrayList<bucketInstance>();
        }
        m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            double[] vals2 = new double[instances.numAttributes()];
            for (int j = 0; j < instances.numAttributes(); j++) {
                if (instances.attribute(j).isNumeric()) {
                    vals2[j] = Math.sqrt(tempI[i].variance(j));
                } else {
                    vals2[j] = Utils.missingValue();
                }
            }
            m_ClusterStdDevs.add(new DenseInstance(1.0, vals2));
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
"
253,9414364,13,"    private static void testForSubSetRandomOperationsStress() {
        IntegerSet bits = new IntegerSet(new ConciseSet());
        IntegerSet bitsPrevious = new IntegerSet(new ConciseSet());
        TreeSet<Integer> items = new TreeSet<Integer>();
        Random rnd = new MersenneTwister();
        for (int i = 0; i < 100000; i++) {
            System.out.print(""Test "" + i + "": "");
            bitsPrevious = bits.clone();
            if (!bitsPrevious.toString().equals(bits.toString())) throw new RuntimeException(""clone() error!"");
            bits.clear();
            items.clear();
            final int size = 1 + rnd.nextInt(10000);
            final int min = 1 + rnd.nextInt(10000 - 1);
            final int max = min + rnd.nextInt(10000 - min + 1);
            final int minSub = 1 + rnd.nextInt(10000 - 1);
            final int maxSub = minSub + rnd.nextInt(10000 - minSub + 1);
            for (int j = 0; j < size; j++) {
                int item = min + rnd.nextInt(max - min + 1);
                bits.add(item);
                items.add(item);
            }
            SortedSet<Integer> bitsSubSet = bits.subSet(minSub, maxSub);
            SortedSet<Integer> itemsSubSet = items.subSet(minSub, maxSub);
            if (!bitsSubSet.toString().equals(itemsSubSet.toString())) {
                System.out.println(""toString() difference!"");
                System.out.println(""value: "" + bitsSubSet.toString());
                System.out.println(""actual: "" + itemsSubSet.toString());
                return;
            }
            if (bitsSubSet.size() != itemsSubSet.size()) {
                System.out.println(""size() difference!"");
                System.out.println(""value: "" + bitsSubSet.size());
                System.out.println(""actual: "" + itemsSubSet.size());
                System.out.println(""bits: "" + bits.toString());
                System.out.println(""items: "" + items.toString());
                System.out.println(""bitsSubSet: "" + bitsSubSet.toString());
                System.out.println(""itemsSubSet: "" + itemsSubSet.toString());
                return;
            }
            if (!itemsSubSet.isEmpty() && (!bitsSubSet.first().equals(itemsSubSet.first()))) {
                System.out.println(""first() difference!"");
                System.out.println(""value: "" + bitsSubSet.first());
                System.out.println(""actual: "" + itemsSubSet.first());
                System.out.println(""bits: "" + bits.toString());
                System.out.println(""items: "" + items.toString());
                System.out.println(""bitsSubSet: "" + bitsSubSet.toString());
                System.out.println(""itemsSubSet: "" + itemsSubSet.toString());
                return;
            }
            if (!itemsSubSet.isEmpty() && (!bitsSubSet.last().equals(itemsSubSet.last()))) {
                System.out.println(""last() difference!"");
                System.out.println(""value: "" + bitsSubSet.last());
                System.out.println(""actual: "" + itemsSubSet.last());
                System.out.println(""bits: "" + bits.toString());
                System.out.println(""items: "" + items.toString());
                System.out.println(""bitsSubSet: "" + bitsSubSet.toString());
                System.out.println(""itemsSubSet: "" + itemsSubSet.toString());
                return;
            }
            boolean resBits = false;
            boolean resItems = false;
            boolean exceptionBits = false;
            boolean exceptionItems = false;
            switch(1 + rnd.nextInt(4)) {
                case 1:
                    System.out.format("" addAll() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        resBits = bitsSubSet.addAll(bitsPrevious);
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        resItems = itemsSubSet.addAll(bitsPrevious);
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
                case 2:
                    System.out.format("" removeAll() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        resBits = bitsSubSet.removeAll(bitsPrevious);
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        resItems = itemsSubSet.removeAll(bitsPrevious);
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
                case 3:
                    System.out.format("" retainAll() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        resBits = bitsSubSet.retainAll(bitsPrevious);
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        resItems = itemsSubSet.retainAll(bitsPrevious);
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
                case 4:
                    System.out.format("" clear() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        bitsSubSet.clear();
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        itemsSubSet.clear();
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
            }
            if (exceptionBits != exceptionItems) {
                System.out.println(""Incorrect exception!"");
                return;
            }
            if (resBits != resItems) {
                System.out.println(""Incorrect results!"");
                System.out.println(""resBits: "" + resBits);
                System.out.println(""resItems: "" + resItems);
                return;
            }
            if (!checkContent(bits, items)) {
                System.out.println(""Subview not correct!"");
                System.out.format(""min: %d, max: %d, minSub: %d, maxSub: %d\n"", min, max, minSub, maxSub);
                System.out.println(""Same elements: "" + (items.toString().equals(bits.toString())));
                System.out.println(""Original: "" + items);
                System.out.println(bits.debugInfo());
                System.out.println(bitsPrevious.debugInfo());
                return;
            }
            IntegerSet otherBits = new IntegerSet(new ConciseSet());
            otherBits.addAll(items);
            if (otherBits.hashCode() != bits.hashCode()) {
                System.out.println(""Representation not correct!"");
                System.out.format(""min: %d, max: %d, minSub: %d, maxSub: %d\n"", min, max, minSub, maxSub);
                System.out.println(bits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(bitsPrevious.debugInfo());
                return;
            }
            System.out.println(""done."");
        }
    }
"
502,19828158,13,"    public void buildClassifier(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        data = new Instances(data);
        data.deleteWithMissingClass();
        Random random = data.getRandomNumberGenerator(m_Seed);
        if (!m_hashtablegiven) {
            m_classifiers = new Hashtable();
        }
        int[] indices = new int[data.numClasses()];
        for (int i = 0; i < indices.length; i++) {
            indices[i] = i;
        }
        for (int i = indices.length - 1; i > 0; i--) {
            int help = indices[i];
            int index = random.nextInt(i + 1);
            indices[i] = indices[index];
            indices[index] = help;
        }
        m_ndtree = new NDTree();
        m_ndtree.insertClassIndexAtNode(indices[0]);
        for (int i = 1; i < indices.length; i++) {
            int nodeIndex = random.nextInt(2 * i - 1);
            NDTree node = m_ndtree.locateNode(nodeIndex, new int[1]);
            node.insertClassIndex(indices[i]);
        }
        m_ndtree.unifyTree();
        buildClassifierForNode(m_ndtree, data);
    }
"
307,10856256,13,"    public void testQueue() {
        FastPriorityQueueLong queue = new FastPriorityQueueLong(MAX_DISTANCE, TOP);
        List<OBResultInvertedInt<Long>> result = new ArrayList<OBResultInvertedInt<Long>>(TOTAL);
        int[] counts = new int[MAX_DISTANCE + 1];
        Random r = new Random();
        int i = 0;
        while (i < TOTAL) {
            int distance = r.nextInt(MAX_DISTANCE + 1);
            queue.add(distance, distance);
            result.add(new OBResultInvertedInt(distance, distance, distance));
            i++;
        }
        Collections.sort(result);
        Iterator<OBResultInvertedInt<Long>> it = result.iterator();
        i = 0;
        long[] data = queue.get();
        for (long l : data) {
            if (i >= TOP) {
                break;
            }
            OBResultInvertedInt<Long> e = it.next();
            assertTrue(""Found: "" + e.getDistance() + "" but fast got: "" + l, e.getDistance() == l);
            i++;
        }
    }
"
325,11205537,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
"
96,4042116,13,"    public void doSomethingElse() {
        if (!this.isRegisteredAtCoordinator()) {
            try {
                this.registerAtCoordinator();
            } catch (ParticipantException e) {
                System.out.println(""SharedParticipantService exception: "" + e.getLocalizedMessage());
            }
        }
        Random randomGenerator = new Random();
        int r = randomGenerator.nextInt(PROCESSINGTIME_MAX + 1);
        long sleepTimeMilli = 1000;
        if (r < PROCESSINGTIME_MIN) {
            sleepTimeMilli *= PROCESSINGTIME_MIN;
        } else {
            sleepTimeMilli *= r;
        }
        try {
            Thread.sleep(sleepTimeMilli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        StatisticsManager.getInstance().addFinishedService(true);
    }
"
460,17641541,13,"    public void crossOver(Gene a, Gene b, Gene a1, Gene b1) {
        int point = MyRandom.nextInt(bitsPerGene + 1);
        for (int j = 0; j < bitsPerGene; j++) {
            if (j < point) {
                a1.bits[j] = a.bits[j];
                b1.bits[j] = b.bits[j];
            } else {
                a1.bits[j] = b.bits[j];
                b1.bits[j] = a.bits[j];
            }
        }
    }
"
122,4657480,13,"    public int next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        int value = from + rand.nextInt(to - from);
        while (memory.containsKey(value)) {
            ++value;
            if (value == to) {
                value = from;
            }
        }
        memory.put(value, value);
        return value;
    }
"
465,17989783,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int red = fc + random.nextInt(bc - fc);
        int green = fc + random.nextInt(bc - fc);
        int blue = fc + random.nextInt(bc - fc);
        return new Color(red, green, blue);
    }
"
342,11866074,13,"    public int computerMove(IProgressMonitor progMonitor) {
        if (gameOver()) {
            return (whoWon);
        }
        if (!computerTurn) return (INVALID_MOVE);
        int maxScore = -322000;
        int bestPlay = -1;
        if (!firstMove && level != 0) {
            try {
                for (int col = 0; col <= COL_MAX; col++) {
                    if (validMove(col)) {
                        int[] testBoard = copyBoard(gameState);
                        int score = 0;
                        score = calculateComputerChances(col, testBoard, level == 1 ? 2 : MAX_LEVEL);
                        progMonitor.worked(col);
                        if (score > maxScore && makeMove(COMPUTER_PIECE, col, gameState) != -1) {
                            removePiece(col, gameState);
                            maxScore = score;
                            bestPlay = col;
                        }
                    }
                }
            } catch (Exception ex) {
                System.out.println(""Problem:"" + ex);
            }
        } else {
            firstMove = false;
        }
        int row, col;
        if (bestPlay != -1) {
            col = bestPlay;
            row = makeMove(COMPUTER_PIECE, bestPlay, gameState);
        } else {
            Random rand = new Random();
            col = rand.nextInt(COL_MAX + 1);
            while ((row = makeMove(COMPUTER_PIECE, col, gameState)) == -1) {
                col = rand.nextInt(COL_MAX + 1);
            }
        }
        lastRow = row;
        lastCol = col;
        if (checkForWin(COMPUTER_PIECE, gameState) == COMPUTER_WIN) {
            gameOver = true;
            whoWon = COMPUTER_WIN;
            return (COMPUTER_WIN);
        }
        computerTurn = false;
        if (gameOver()) return (whoWon); else return (NO_WINYET);
    }
"
53,2558197,13,"    protected static int getRandomValue(int min, int max) {
        Random rand = new Random();
        int v = min + rand.nextInt(max - min);
        return rand.nextBoolean() ? v : -v;
    }
"
380,13621015,13,"    private void workForRandomPeriod(int minDuration, int maxDuration) {
        Random random = new Random();
        int period = minDuration + random.nextInt(maxDuration - minDuration);
        long start = Process.getElapsedCpuTime();
        while (Process.getElapsedCpuTime() - start < period) {
            for (int i = 0, temp = 0; i < 50; i++) {
                temp += i;
            }
        }
    }
"
107,4409375,13,"        public static int randomizedPartition(int[] array, int startIndex, int endIndex) {
            int i = startIndex + random.nextInt(endIndex - startIndex);
            swap(array, i, startIndex);
            return partition(array, startIndex, endIndex);
        }
"
242,8998440,13,"    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getDeclaringClass() == Object.class) {
            try {
                return method.invoke(realObject, args);
            } catch (InvocationTargetException ite) {
                throw ite.getCause();
            }
        }
        int remainingRetries = numRetries;
        int waitTime = minWait + rng.nextInt(maxWait - minWait);
        Throwable thrown = null;
        while (remainingRetries >= 0) {
            try {
                return method.invoke(realObject, args);
            } catch (InvocationTargetException ite) {
                thrown = ite.getCause();
                if (remainingRetries == 0) {
                    log.info(""Reached maximum retry count, giving up."");
                    break;
                } else {
                    if (retryExceptionTypes != null && retryExceptionTypes.length > 0) {
                        boolean shouldRetry = false;
                        for (Class<? extends Throwable> exceptionType : retryExceptionTypes) {
                            if (exceptionType.isInstance(thrown)) {
                                shouldRetry = true;
                                break;
                            }
                        }
                        if (!shouldRetry) {
                            log.info(""Call threw exception of type "" + thrown.getClass().getName() + "", which is not configured to cause a retry - giving up."");
                            break;
                        }
                    }
                    log.debug(""Exception thrown by method "" + method.getName() + "" of "" + realObject + "". Retrying in "" + waitTime + ""ms"", thrown);
                    try {
                        Thread.sleep(waitTime);
                    } catch (InterruptedException ie) {
                        log.info(""Thread interrupted, giving up retrying."");
                        throw thrown;
                    }
                    remainingRetries--;
                    waitTime = (int) (waitTime * backoffMultiplier);
                }
            }
        }
        throw thrown;
    }
"
159,5542265,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        if (!m_dontReplaceMissing) {
            m_ReplaceMissingFilter.setInputFormat(instances);
            instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        }
        m_FullMissingCounts = new int[instances.numAttributes()];
        if (m_displayStdDevs) {
            m_FullStdDevs = new double[instances.numAttributes()];
        }
        m_FullNominalCounts = new int[instances.numAttributes()][0];
        m_FullMeansOrMediansOrModes = moveCentroid(0, instances, false);
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_FullMissingCounts[i] = instances.attributeStats(i).missingCount;
            if (instances.attribute(i).isNumeric()) {
                if (m_displayStdDevs) {
                    m_FullStdDevs[i] = Math.sqrt(instances.variance(i));
                }
                if (m_FullMissingCounts[i] == instances.numInstances()) {
                    m_FullMeansOrMediansOrModes[i] = Double.NaN;
                }
            } else {
                m_FullNominalCounts[i] = instances.attributeStats(i).nominalCounts;
                if (m_FullMissingCounts[i] > m_FullNominalCounts[i][Utils.maxIndex(m_FullNominalCounts[i])]) {
                    m_FullMeansOrMediansOrModes[i] = -1;
                }
            }
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        if (m_PreserveOrder) m_Assignments = clusterAssignments;
        m_DistanceFunction.setInstances(instances);
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        Instances initInstances = null;
        if (m_PreserveOrder) initInstances = new Instances(instances); else initInstances = instances;
        for (int j = initInstances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTableHashKey(initInstances.instance(instIndex), initInstances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(initInstances.instance(instIndex));
                initC.put(hk, null);
            }
            initInstances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        initInstances = null;
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        m_ClusterMissingCounts = new int[m_NumClusters][instances.numAttributes()];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    moveCentroid(i, tempI[i], true);
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                if (converged) {
                    Instances[] t = new Instances[m_NumClusters];
                    int index = 0;
                    for (int k = 0; k < tempI.length; k++) {
                        if (tempI[k].numInstances() > 0) {
                            t[index++] = tempI[k];
                        }
                    }
                    tempI = t;
                } else {
                    tempI = new Instances[m_NumClusters];
                }
            }
            if (m_Iterations == m_MaxIterations) converged = true;
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        if (m_displayStdDevs) {
            m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        }
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            if (m_displayStdDevs) {
                double[] vals2 = new double[instances.numAttributes()];
                for (int j = 0; j < instances.numAttributes(); j++) {
                    if (instances.attribute(j).isNumeric()) {
                        vals2[j] = Math.sqrt(tempI[i].variance(j));
                    } else {
                        vals2[j] = Instance.missingValue();
                    }
                }
                m_ClusterStdDevs.add(new Instance(1.0, vals2));
            }
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
"
12,727500,13,"    public static void main(String args[]) {
        try {
            DB.Initialize();
            Random r = new Random();
            StudentInfo[] s = StudentModel.getStudents();
            Club[] c = ClubModel.getClubs();
            if (false) {
                for (Club b : c) {
                    if (b.rank.equals(""-1"")) {
                        b.rank = """" + r.nextInt(11);
                        System.out.println(b.name + "": -1 -> "" + b.rank + ""  "" + DB.Update(""UPDATE Club SET rank='"" + b.rank + ""' WHERE club_id="" + b.id));
                    }
                    int rank = Integer.parseInt(b.rank);
                    String q = ""20101"";
                    double moneyz[] = { 200, 300, 500, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000 };
                    System.out.println(""Budget: "" + moneyz[rank] + ""   "" + DB.Update(""INSERT INTO Budget (`club_id`, `quarter_id`, `used`, `available`) VALUES ( "" + b.id + "", "" + q + "", 0, "" + moneyz[rank] + "" )"") + ""   "" + b.name);
                }
            }
            int max_club = 3;
            if (false) {
                for (StudentInfo i : s) {
                    int num = r.nextInt(max_club + 1);
                    num -= ClubModel.getClubsOfMember(i.uid).length;
                    for (int k = 0; k < num; k++) {
                        int join = r.nextInt(c.length);
                        System.out.println(i.uid + "" -> "" + c[join].name + ""   "" + ClubModel.addMember(i, c[join]));
                    }
                }
            }
        } catch (DBError de) {
        }
    }
"
213,7986663,13,"    public static String generate(int minLength, int maxLength) throws Exception {
        PasswordGenerator.init();
        if (minLength <= 0 || maxLength <= 0 || minLength > maxLength) return null;
        char[][] charGroups = new char[][] { PASSWORD_CHARS_LCASE.toCharArray(), PASSWORD_CHARS_UCASE.toCharArray(), PASSWORD_CHARS_NUMERIC.toCharArray(), PASSWORD_CHARS_SPECIAL.toCharArray() };
        int[] charsLeftInGroup = new int[charGroups.length];
        for (int i = 0; i < charsLeftInGroup.length; i++) charsLeftInGroup[i] = charGroups[i].length;
        int[] leftGroupsOrder = new int[charGroups.length];
        for (int i = 0; i < leftGroupsOrder.length; i++) leftGroupsOrder[i] = i;
        char[] password = null;
        if (minLength < maxLength) password = new char[random.nextInt(maxLength - minLength) + minLength]; else password = new char[minLength];
        int nextCharIdx;
        int nextGroupIdx;
        int nextLeftGroupsOrderIdx;
        int lastCharIdx;
        int lastLeftGroupsOrderIdx = leftGroupsOrder.length - 1;
        for (int i = 0; i < password.length; i++) {
            if (lastLeftGroupsOrderIdx == 0) nextLeftGroupsOrderIdx = 0; else nextLeftGroupsOrderIdx = random.nextInt(lastLeftGroupsOrderIdx);
            nextGroupIdx = leftGroupsOrder[nextLeftGroupsOrderIdx];
            lastCharIdx = charsLeftInGroup[nextGroupIdx] - 1;
            if (lastCharIdx == 0) nextCharIdx = 0; else nextCharIdx = random.nextInt(lastCharIdx + 1);
            password[i] = charGroups[nextGroupIdx][nextCharIdx];
            if (lastCharIdx == 0) charsLeftInGroup[nextGroupIdx] = charGroups[nextGroupIdx].length; else {
                if (lastCharIdx != nextCharIdx) {
                    char temp = charGroups[nextGroupIdx][lastCharIdx];
                    charGroups[nextGroupIdx][lastCharIdx] = charGroups[nextGroupIdx][nextCharIdx];
                    charGroups[nextGroupIdx][nextCharIdx] = temp;
                }
                charsLeftInGroup[nextGroupIdx]--;
            }
            if (lastLeftGroupsOrderIdx == 0) lastLeftGroupsOrderIdx = leftGroupsOrder.length - 1; else {
                if (lastLeftGroupsOrderIdx != nextLeftGroupsOrderIdx) {
                    int temp = leftGroupsOrder[lastLeftGroupsOrderIdx];
                    leftGroupsOrder[lastLeftGroupsOrderIdx] = leftGroupsOrder[nextLeftGroupsOrderIdx];
                    leftGroupsOrder[nextLeftGroupsOrderIdx] = temp;
                }
                lastLeftGroupsOrderIdx--;
            }
        }
        return new String(password);
    }
"
0,2403,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
1,2747,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
2,7762,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
3,10733,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
4,12936,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
5,13477,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
6,28136,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
7,28335,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
8,45592,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
9,53657,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
10,53723,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
11,59201,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
12,63418,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
13,65494,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
14,80862,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
15,103830,44,"    public static void main(String[] args) {
        Hashtable nueva = new Hashtable();
        nueva.put('A', 'A');
        nueva.put('E', '3');
        nueva.put('H', 'H');
        nueva.put('I', 'I');
        nueva.put('J', 'L');
        nueva.put('L', 'J');
        nueva.put('M', 'M');
        nueva.put('O', 'O');
        nueva.put('S', '2');
        nueva.put('T', 'T');
        nueva.put('U', 'U');
        nueva.put('V', 'V');
        nueva.put('W', 'W');
        nueva.put('X', 'X');
        nueva.put('Y', 'Y');
        nueva.put('Z', '5');
        nueva.put('1', '1');
        nueva.put('2', 'S');
        nueva.put('3', 'E');
        nueva.put('5', 'Z');
        nueva.put('8', '8');
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = """";
        boolean palin;
        boolean mirror;
        try {
            while ((line = br.readLine()) != null) {
                palin = isPalindrome(line);
                mirror = isMirrorString(line, nueva);
                if (!palin && !mirror) {
                    System.out.println(line + "" -- is not a palindrome.\n"");
                }
                if (!palin && mirror) {
                    System.out.println(line + "" -- is a mirrored string.\n"");
                }
                if (palin && !mirror) {
                    System.out.println(line + "" -- is a regular palindrome.\n"");
                }
                if (palin && mirror) {
                    System.out.println(line + "" -- is a mirrored palindrome.\n"");
                }
            }
        } catch (IOException ex) {
            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
"
16,106154,44,"    public static boolean isPalindrome(BigInteger number) {
        return number.toString().equals(new StringBuffer(number.toString()).reverse().toString());
    }
"
17,106155,44,"    public static boolean isLychrel(BigInteger number) {
        BigInteger numberTemp = number;
        for (int i = 0; i < 50; i++) {
            BigInteger sum = numberTemp.add(new BigInteger(new StringBuffer(numberTemp.toString()).reverse().toString()));
            if (isPalindrome(sum)) {
                System.out.println(number + "" "" + sum);
                return false;
            } else {
                numberTemp = sum;
            }
        }
        return true;
    }
"
18,111979,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
19,116120,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
20,120779,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
21,124389,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
22,128027,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
23,128737,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
24,136069,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
25,136939,44,"    public static void main(String[] args) {
        String line = readLn();
        while (line != null) {
            int i = process(line);
            System.out.println(""The string '"" + line + ""' contains "" + i + "" palindromes."");
            line = readLn();
        }
    }
"
26,136940,44,"    private static int process(String line) {
        HashMap<String, String> isPalindrome = new HashMap<String, String>();
        for (int k = 0; k < line.length(); k++) {
            for (int j = k + 1; j <= line.length(); j++) {
                String sub = line.substring(k, j);
                if (isPalindrome.get(sub) == null) {
                    if (isPalindrome(sub)) {
                        isPalindrome.put(sub, sub);
                    }
                }
            }
        }
        return isPalindrome.size();
    }
"
27,147669,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
28,147994,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
29,157747,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
30,157779,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
31,160206,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
32,162829,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
33,165908,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
34,174088,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
35,177744,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
36,187829,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
37,193054,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
38,193561,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
39,202152,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
40,202243,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
41,203114,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
42,207272,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
43,211686,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
44,217751,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
45,224088,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
46,227073,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
47,230247,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
48,234584,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
49,235427,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
50,238321,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
51,241852,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
52,242006,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
53,244234,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
54,245666,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
55,250689,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
56,259444,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
57,278440,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
58,279856,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
59,281238,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
60,281393,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
61,286790,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
62,292891,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
63,296923,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
64,298518,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
65,299390,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
66,305473,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
67,311167,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
68,314562,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
69,334119,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
70,345909,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
71,351291,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
72,353069,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
73,357577,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
74,359837,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
75,361552,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
76,370548,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
77,379081,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
78,383566,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
79,396829,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
80,403117,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
81,428051,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
82,454282,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
83,454858,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
84,461152,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
85,469062,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
86,469342,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
87,473027,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
88,474317,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
89,487414,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
90,489467,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
91,497857,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
92,512228,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
93,513247,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
94,518707,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
95,520194,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
96,531921,44,"    public static void main(String[] args) {
        int largestPalindrome = 0;
        for (int i = 100; i < 1000; i++) {
            for (int j = 100; j < 1000; j++) {
                int product = i * j;
                if (isPalindrome(String.valueOf(product))) {
                    System.out.println(product);
                    if (product > largestPalindrome) {
                        largestPalindrome = product;
                    }
                }
            }
        }
        System.out.println(largestPalindrome);
    }
"
97,541802,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
98,546907,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
99,563745,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
100,590961,44,"    private static void process(String line) {
        StringBuffer sb = new StringBuffer();
        for (int k = 0; k < line.length(); k++) {
            char c = line.charAt(k);
            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
                if ((c >= 'a' && c <= 'z')) {
                    int n = c - 'a';
                    c = (char) (n + 'A');
                }
                sb.append(c);
            }
        }
        if (isPalindrome(sb.toString())) {
            System.out.println(""You won't be eaten!"");
        } else {
            System.out.println(""Uh oh.."");
        }
    }
"
101,592518,44,"    public void testIsPalindrome() {
        System.out.println(""isPalindrome"");
        assertEquals(Algorithms.isPalindrome(""A""), true);
        assertEquals(Algorithms.isPalindrome(""BA""), false);
        assertEquals(Algorithms.isPalindrome(""BB""), true);
        assertEquals(Algorithms.isPalindrome(""BAB""), true);
        assertEquals(Algorithms.isPalindrome(""BAA""), false);
        assertEquals(Algorithms.isPalindrome(""ABB""), false);
    }
"
102,605830,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
103,631363,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
104,640610,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
105,646741,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
106,652691,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
107,661981,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
108,670346,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
109,673503,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
110,681080,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
111,682347,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
112,689533,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
113,694025,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
114,695352,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
115,695791,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
116,714207,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
117,718538,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
118,725502,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
119,739815,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
120,741290,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
121,745912,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
122,748155,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
123,755768,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
124,775736,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
125,776781,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
126,789020,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
127,801170,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
128,801888,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
129,812841,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
130,820540,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
131,820623,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
132,821504,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
133,843065,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
134,847424,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
135,853458,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
136,858383,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
137,863589,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
138,881840,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
139,891391,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
140,892628,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
141,910480,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
142,910690,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
143,911775,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
144,912098,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
145,913384,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
146,916275,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
147,927502,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
148,928485,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
149,932293,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
150,935196,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
151,935810,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
152,936425,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
153,939306,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
154,946512,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
155,947102,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
"
156,950312,44,"    public static void main(String[] args) {
        int cases = Integer.parseInt(readLn1());
        for (int caseNumber = 0; caseNumber < cases; caseNumber++) {
            System.out.println(""Case #"" + (caseNumber + 1) + "":"");
            String line = readLn();
            int k = (int) Math.sqrt(line.length());
            if (k * k != line.length()) System.out.print(""No magic :(""); else {
                if (!checkPalindrome(line)) {
                    System.out.print(""No magic :("");
                } else {
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < k; j++) {
                        for (int l = 0; l < k; l++) {
                            sb.append(line.charAt(l * k + j));
                        }
                    }
                    if (!sb.toString().equals(line)) {
                        System.out.print(""No magic :("");
                    } else {
                        System.out.print(k);
                    }
                }
            }
            System.out.println();
        }
    }
"
157,2044209,44,"    protected void collectSites(RestrictionEnzyme re, Vector new_positions, Vector all_positions, int strand) {
        int match_cnt = new_positions.size();
        for (int i = 0; i < match_cnt; i++) {
            int[] match_positions = (int[]) new_positions.elementAt(i);
            int cut_count = all_positions.size();
            boolean palindrome = false;
            for (int j = 0; j < cut_count && !palindrome; j++) {
                CutSite cutsite = (CutSite) all_positions.elementAt(j);
                palindrome = (match_positions[0] == cutsite.getLow() && match_positions[1] == cutsite.getHigh());
            }
            if (!palindrome) {
                CutSite match = (strand == 1 ? new CutSite(match_positions[0], match_positions[1], re) : new CutSite(match_positions[1], match_positions[0], re));
                match.setRefSequence(re.getRefSequence());
                all_positions.add(match);
                SeqFeatureUtil.sort(all_positions, 1);
            }
        }
    }
"
158,3868944,44,"    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        FifteenEight.blank(""Is \""radar\"" a palindrome, True or False? "" + isPalindrome(""radar""));
        FifteenEight.blank();
        FifteenEight.blank(""Is \""dogs and cats\"" a palindrome, True or False? "" + isPalindrome(""dogs and cats""));
        FifteenEight.blank();
        FifteenEight.blank(""Please enter a word or phrase to check for palindromishness: "");
        String temp = (in.readLine());
        if (isPalindrome(temp) == false) FifteenEight.blank(""That is not a palindrome.""); else FifteenEight.blank(""Yes! That is a palindrome!"");
        FifteenEight.blank();
        FifteenEight.blank(""Thank you for playing! eop."");
    }
"
159,4750695,44,"    protected void createJobScriptAndConfigurationFiles(FileWriter writer) throws Exception {
        BarcodeDesignerTask barcodeDesignerTask = (BarcodeDesignerTask) task;
        BarcodeDesignResultNode tmpResultNode = (BarcodeDesignResultNode) resultFileNode;
        File configFile = new File(getSGEConfigurationDirectory() + File.separator + CONFIG_PREFIX + ""1"");
        boolean fileSuccess = configFile.createNewFile();
        if (!fileSuccess) {
            throw new ServiceException(""Unable to create a config file for the 16S pipeline."");
        }
        File tmpConfigFile = new File(tmpResultNode.getDirectoryPath() + File.separator + ""454Barcode.config"");
        FileWriter configWriter = new FileWriter(tmpConfigFile);
        try {
            configWriter.write(""[Barcode_Rules]\n"");
            configWriter.write(""barcodeLength="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_barcodeLength) + ""\n"");
            configWriter.write(""fivePrimeClamp="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_fivePrimeClamp) + ""\n"");
            configWriter.write(""maxFlows="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_maxFlows) + ""\n"");
            configWriter.write(""flowSequence="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_flowSequence) + ""\n"");
            configWriter.write(""keyChar="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_keyChar) + ""\n"");
            configWriter.write(""minEditDistance="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_minEditDistance) + ""\n\n"");
            configWriter.write(""[Barcode_wPrimer_Rules]\n"");
            configWriter.write(""palindromeBin="" + SystemConfigurationProperties.getString(""BarcodeDesign.PalindromeBin"") + ""\n"");
            configWriter.write(""minPalindromeHBonds="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_minPalindromeHBonds) + ""\n"");
            configWriter.write(""maxPalindromeMateDistance="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_maxPalindromeMateDistance) + ""\n"");
            configWriter.write(""palindromeTempDirectory="" + SystemConfigurationProperties.getString(""BarcodeDesign.PalindromeTempDir"") + ""\n"");
            configWriter.write(""intDimerMaxScore="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_intDimerMaxScore) + ""\n"");
            configWriter.write(""endDimerMaxScore="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_endDimerMaxScore) + ""\n\n"");
            configWriter.write(""[Synthesis_Requirements]\n"");
            configWriter.write(""forwardPrimerAdapterSequence="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_forwardPrimerAdapterSequence) + ""\n"");
            configWriter.write(""reversePrimerAdapterSequence="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_reversePrimerAdapterSequence) + ""\n"");
            configWriter.write(""attachBarcodeToForwardPrimer="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_attachBarcodeToForwardPrimer) + ""\n"");
            configWriter.write(""attachBarcodeToReversePrimer="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_attachBarcodeToReversePrimer) + ""\n"");
        } finally {
            configWriter.flush();
            configWriter.close();
        }
        String perlPath = SystemConfigurationProperties.getString(""Perl.Path"");
        String basePath = SystemConfigurationProperties.getString(""Perl.ModuleBase"");
        String pipelineCmd = perlPath + "" "" + basePath + SystemConfigurationProperties.getString(""BarcodeDesign.Cmd"");
        SystemConfigurationProperties properties = SystemConfigurationProperties.getInstance();
        String tmpDirectoryName = properties.getProperty(""Upload.ScratchDir"");
        List<String> inputPrimerFiles = Task.listOfStringsFromCsvString(task.getParameter(BarcodeDesignerTask.PARAM_primerFile));
        List<String> inputAmpliconFiles = Task.listOfStringsFromCsvString(task.getParameter(BarcodeDesignerTask.PARAM_ampliconsFile));
        String fullCmd = pipelineCmd + "" -c "" + tmpConfigFile.getAbsolutePath() + "" -p "" + tmpDirectoryName + File.separator + inputPrimerFiles.get(0) + "" -a "" + tmpDirectoryName + File.separator + inputAmpliconFiles.get(0) + "" -o "" + tmpResultNode.getDirectoryPath() + "" -n "" + task.getParameter(BarcodeDesignerTask.PARAM_numBarcodesPerPrimerPair);
        StringBuffer script = new StringBuffer();
        fullCmd = ""export PATH=$PATH:"" + basePath + "";export PERL5LIB=$PERL5LIB:"" + basePath + "";"" + fullCmd;
        script.append(fullCmd).append(""\n"");
        writer.write(script.toString());
        setJobIncrementStop(1);
    }
"
160,6465770,44,"    public void testIsPalindrome() {
        assertTrue(PalindromeChecker.test(""123321""));
        assertFalse(PalindromeChecker.test(""123421""));
        assertTrue(PalindromeChecker.test(""1234321""));
        assertTrue(PalindromeChecker.test(""racecar""));
    }
"
161,6465771,44,"    public void testReverse() {
        assertEquals(""dog"", PalindromeChecker.reverse(""god""));
    }
"
162,6917038,44,"    private Hashtable setupLabels() {
        Hashtable labels = new Hashtable();
        labels.put(""file"", GT._(""&File""));
        labels.put(""newwin"", GT._(""New""));
        labels.put(""open"", GT._(""&Open""));
        labels.put(""openurl"", GT._(""Open &URL""));
        labels.put(""script"", GT._(""Scrip&t...""));
        labels.put(""atomsetchooser"", GT._(""AtomSetChooser...""));
        labels.put(""saveas"", GT._(""&Save As...""));
        labels.put(""exportMenu"", GT._(""&Export""));
        labels.put(""export"", GT._(""Export Image...""));
        labels.put(""povray"", GT._(""Render in pov-ray...""));
        labels.put(""pdf"", GT._(""Export PDF...""));
        labels.put(""print"", GT._(""&Print...""));
        labels.put(""close"", GT._(""Close""));
        labels.put(""exit"", GT._(""E&xit""));
        labels.put(""recentFiles"", GT._(""Recent Files...""));
        labels.put(""edit"", GT._(""&Edit""));
        labels.put(""makecrystal"", GT._(""Make crystal...""));
        labels.put(""selectall"", GT._(""Select All""));
        labels.put(""deselectall"", GT._(""Deselect All""));
        labels.put(""copyImage"", GT._(""Copy Image""));
        labels.put(""prefs"", GT._(""&Preferences...""));
        labels.put(""editSelectAllScript"", GT._(""Select All""));
        labels.put(""selectMenu"", GT._(""Select""));
        labels.put(""selectAllScript"", GT._(""All""));
        labels.put(""selectNoneScript"", GT._(""None""));
        labels.put(""selectHydrogenScript"", GT._(""Hydrogen""));
        labels.put(""selectCarbonScript"", GT._(""Carbon""));
        labels.put(""selectNitrogenScript"", GT._(""Nitrogen""));
        labels.put(""selectOxygenScript"", GT._(""Oxygen""));
        labels.put(""selectPhosphorusScript"", GT._(""Phosphorus""));
        labels.put(""selectSulphurScript"", GT._(""Sulphur""));
        labels.put(""selectAminoScript"", GT._(""Amino""));
        labels.put(""selectNucleicScript"", GT._(""Nucleic""));
        labels.put(""selectWaterScript"", GT._(""Water""));
        labels.put(""selectHeteroScript"", GT._(""Hetero""));
        labels.put(""display"", GT._(""&Display""));
        labels.put(""atomMenu"", GT._(""Atom""));
        labels.put(""atomNoneScript"", GT._(""None""));
        labels.put(""atom15Script"", GT._(""{0}% vanderWaals"", new Object[] { ""15"" }));
        labels.put(""atom20Script"", GT._(""{0}% vanderWaals"", new Object[] { ""20"" }));
        labels.put(""atom25Script"", GT._(""{0}% vanderWaals"", new Object[] { ""25"" }));
        labels.put(""atom100Script"", GT._(""{0}% vanderWaals"", new Object[] { ""100"" }));
        labels.put(""bondMenu"", GT._(""Bond""));
        labels.put(""bondNoneScript"", GT._(""None""));
        labels.put(""bondWireframeScript"", GT._(""Wireframe""));
        labels.put(""bond100Script"", GT._(""{0} "", new Object[] { ""0.10"" }));
        labels.put(""bond150Script"", GT._(""{0} "", new Object[] { ""0.15"" }));
        labels.put(""bond200Script"", GT._(""{0} "", new Object[] { ""0.20"" }));
        labels.put(""labelMenu"", GT._(""Label""));
        labels.put(""labelNoneScript"", GT._(""None""));
        labels.put(""labelSymbolScript"", GT._(""Symbol""));
        labels.put(""labelNameScript"", GT._(""Name""));
        labels.put(""labelNumberScript"", GT._(""Number""));
        labels.put(""labelCenteredScript"", GT._(""Centered""));
        labels.put(""labelUpperRightScript"", GT._(""Upper right""));
        labels.put(""vectorMenu"", GT._(""Vector""));
        labels.put(""vectorOffScript"", GT._(""None""));
        labels.put(""vectorOnScript"", GT._(""On""));
        labels.put(""vector3Script"", GT._(""{0} pixels"", new Object[] { ""3"" }));
        labels.put(""vector005Script"", GT._(""{0} "", new Object[] { ""0.05"" }));
        labels.put(""vector01Script"", GT._(""{0} "", new Object[] { ""0.1"" }));
        labels.put(""vectorScale02Script"", GT._(""Scale {0}"", new Object[] { ""0.2"" }));
        labels.put(""vectorScale05Script"", GT._(""Scale {0}"", new Object[] { ""0.5"" }));
        labels.put(""vectorScale1Script"", GT._(""Scale {0}"", new Object[] { ""1"" }));
        labels.put(""vectorScale2Script"", GT._(""Scale {0}"", new Object[] { ""2"" }));
        labels.put(""vectorScale5Script"", GT._(""Scale {0}"", new Object[] { ""5"" }));
        labels.put(""zoomMenu"", GT._(""Zoom""));
        labels.put(""zoom100Script"", GT._(""{0}%"", new Object[] { ""100"" }));
        labels.put(""zoom150Script"", GT._(""{0}%"", new Object[] { ""150"" }));
        labels.put(""zoom200Script"", GT._(""{0}%"", new Object[] { ""200"" }));
        labels.put(""zoom400Script"", GT._(""{0}%"", new Object[] { ""400"" }));
        labels.put(""zoom800Script"", GT._(""{0}%"", new Object[] { ""800"" }));
        labels.put(""perspectiveCheck"", GT._(""Perspective Depth""));
        labels.put(""axesCheck"", GT._(""Axes""));
        labels.put(""boundboxCheck"", GT._(""Bounding Box""));
        labels.put(""hydrogensCheck"", GT._(""&Hydrogens""));
        labels.put(""vectorsCheck"", GT._(""&Vectors""));
        labels.put(""measurementsCheck"", GT._(""&Measurements""));
        labels.put(""view"", GT._(""&View""));
        labels.put(""front"", GT._(""Front""));
        labels.put(""top"", GT._(""Top""));
        labels.put(""bottom"", GT._(""Bottom""));
        labels.put(""right"", GT._(""Right""));
        labels.put(""left"", GT._(""Left""));
        labels.put(""transform"", GT._(""Transform...""));
        labels.put(""definecenter"", GT._(""Define Center""));
        labels.put(""tools"", GT._(""&Tools""));
        labels.put(""viewMeasurementTable"", GT._(""Measurements...""));
        labels.put(""distanceUnitsMenu"", GT._(""Distance Units""));
        labels.put(""distanceNanometersScript"", GT._(""Nanometers 1E-9""));
        labels.put(""distanceAngstromsScript"", GT._(""Angstroms 1E-10""));
        labels.put(""distancePicometersScript"", GT._(""Picometers 1E-12""));
        labels.put(""animateMenu"", GT._(""Animate...""));
        labels.put(""vibrateMenu"", GT._(""Vibrate...""));
        labels.put(""graph"", GT._(""&Graph...""));
        labels.put(""chemicalShifts"", GT._(""Calculate chemical &shifts...""));
        labels.put(""crystprop"", GT._(""&Crystal Properties""));
        labels.put(""animateOnceScript"", GT._(""Once""));
        labels.put(""animateLoopScript"", GT._(""Loop""));
        labels.put(""animatePalindromeScript"", GT._(""Palindrome""));
        labels.put(""animateStopScript"", GT._(""Stop animation""));
        labels.put(""animateRewindScript"", GT._(""Rewind to first frame""));
        labels.put(""animateNextScript"", GT._(""Go to next frame""));
        labels.put(""animatePrevScript"", GT._(""Go to previous frame""));
        labels.put(""vibrateStartScript"", GT._(""Start vibration""));
        labels.put(""vibrateStopScript"", GT._(""Stop vibration""));
        labels.put(""vibrateRewindScript"", GT._(""First frequency""));
        labels.put(""vibrateNextScript"", GT._(""Next frequency""));
        labels.put(""vibratePrevScript"", GT._(""Previous frequency""));
        labels.put(""help"", GT._(""&Help""));
        labels.put(""about"", GT._(""About Jmol""));
        labels.put(""uguide"", GT._(""User Guide""));
        labels.put(""whatsnew"", GT._(""What's New""));
        labels.put(""console"", GT._(""Jmol Console""));
        labels.put(""Prefs.showHydrogens"", GT._(""Hydrogens""));
        labels.put(""Prefs.showMeasurements"", GT._(""Measurements""));
        labels.put(""Prefs.perspectiveDepth"", GT._(""Perspective Depth""));
        labels.put(""Prefs.showAxes"", GT._(""Axes""));
        labels.put(""Prefs.showBoundingBox"", GT._(""Bounding Box""));
        labels.put(""Prefs.axesOrientationRasmol"", GT._(""RasMol/Chime compatible axes orientation/rotations""));
        labels.put(""Prefs.openFilePreview"", GT._(""File Preview (needs restarting Jmol)""));
        labels.put(""Prefs.isLabelAtomColor"", GT._(""Use Atom Color""));
        labels.put(""Prefs.isBondAtomColor"", GT._(""Use Atom Color""));
        labels.put(""openTip"", GT._(""Open a file.""));
        labels.put(""exportTip"", GT._(""Export view to an image file.""));
        labels.put(""povrayTip"", GT._(""Render in pov-ray.""));
        labels.put(""printTip"", GT._(""Print view.""));
        labels.put(""rotateTip"", GT._(""Rotate molecule.""));
        labels.put(""pickTip"", GT._(""Select an atom or region.""));
        labels.put(""viewMeasurementTableTip"", GT._(""View measurement table.""));
        labels.put(""homeTip"", GT._(""Return molecule to home position.""));
        labels.put(""animateRewindScriptTip"", GT._(""Rewind to first frame""));
        labels.put(""animateNextScriptTip"", GT._(""Go to next frame""));
        labels.put(""animatePrevScriptTip"", GT._(""Go to previous frame""));
        return labels;
    }
"
163,7003180,44,"    @Override
    protected String[] getWordContents() {
        boolean wasTranslating = GT.getDoTranslate();
        GT.setDoTranslate(true);
        String[] words = new String[] { ""modelSetMenu"", GT._(""No atoms loaded""), ""configurationComputedMenu"", GT._(""Configurations""), ""elementsComputedMenu"", GT._(""Element""), ""FRAMESbyModelComputedMenu"", GT._(""Model/Frame""), ""languageComputedMenu"", GT._(""Language""), ""PDBaaResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBnucleicResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBcarboResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBheteroComputedMenu"", GT._(""By HETATM""), ""surfMoComputedMenuText"", GT._(""Molecular Orbitals ({0})""), ""SYMMETRYSelectComputedMenu"", GT._(""Symmetry""), ""SYMMETRYShowComputedMenu"", GT._(""Space Group""), ""SYMMETRYhide"", GT._(""Hide Symmetry""), ""hiddenModelSetText"", GT._(""Model information""), ""selectMenuText"", GT._(""Select ({0})""), ""allModelsText"", GT._(""All {0} models""), ""configurationMenuText"", GT._(""Configurations ({0})""), ""modelSetCollectionText"", GT._(""Collection of {0} models""), ""atomsText"", GT._(""atoms: {0}""), ""bondsText"", GT._(""bonds: {0}""), ""groupsText"", GT._(""groups: {0}""), ""chainsText"", GT._(""chains: {0}""), ""polymersText"", GT._(""polymers: {0}""), ""modelMenuText"", GT._(""model {0}""), ""viewMenuText"", GT._(""View {0}""), ""mainMenuText"", GT._(""Main Menu""), ""biomoleculesMenuText"", GT._(""Biomolecules""), ""biomoleculeText"", GT._(""biomolecule {0} ({1} atoms)""), ""loadBiomoleculeText"", GT._(""load biomolecule {0} ({1} atoms)""), ""selectAll"", GT._(""All""), ""selectNone"", GT._(""None""), ""hideNotSelectedCB"", GT._(""Display Selected Only""), ""invertSelection"", GT._(""Invert Selection""), ""viewMenu"", GT._(""View""), ""front"", GT._(""Front""), ""left"", GT._(""Left""), ""right"", GT._(""Right""), ""top"", TextFormat.split(GT._(""Top[as in \""view from the top, from above\"" - (translators: remove this bracketed part]""), '[')[0], ""bottom"", GT._(""Bottom""), ""back"", GT._(""Back""), ""PDBproteinMenu"", GT._(""Protein""), ""allProtein"", GT._(""All""), ""proteinBackbone"", GT._(""Backbone""), ""proteinSideChains"", GT._(""Side Chains""), ""polar"", GT._(""Polar Residues""), ""nonpolar"", GT._(""Nonpolar Residues""), ""positiveCharge"", GT._(""Basic Residues (+)""), ""negativeCharge"", GT._(""Acidic Residues (-)""), ""noCharge"", GT._(""Uncharged Residues""), ""PDBnucleicMenu"", GT._(""Nucleic""), ""allNucleic"", GT._(""All""), ""DNA"", GT._(""DNA""), ""RNA"", GT._(""RNA""), ""nucleicBackbone"", GT._(""Backbone""), ""nucleicBases"", GT._(""Bases""), ""atPairs"", GT._(""AT pairs""), ""gcPairs"", GT._(""GC pairs""), ""auPairs"", GT._(""AU pairs""), ""PDBheteroMenu"", GT._(""Hetero""), ""allHetero"", GT._(""All PDB \""HETATM\""""), ""Solvent"", GT._(""All Solvent""), ""Water"", GT._(""All Water""), ""nonWaterSolvent"", GT._(""Nonaqueous Solvent"") + "" (solvent and not water)"", ""exceptWater"", GT._(""Nonaqueous HETATM"") + "" (hetero and not water)"", ""Ligand"", GT._(""Ligand""), ""allCarbo"", GT._(""All""), ""PDBcarboMenu"", GT._(""Carbohydrate""), ""PDBnoneOfTheAbove"", GT._(""None of the above""), ""renderMenu"", GT._(""Style""), ""renderSchemeMenu"", GT._(""Scheme""), ""renderCpkSpacefill"", GT._(""CPK Spacefill""), ""renderBallAndStick"", GT._(""Ball and Stick""), ""renderSticks"", GT._(""Sticks""), ""renderWireframe"", GT._(""Wireframe""), ""PDBrenderCartoonsOnly"", GT._(""Cartoon""), ""PDBrenderTraceOnly"", GT._(""Trace""), ""atomMenu"", GT._(""Atoms""), ""atomNone"", GT._(""Off""), ""atom15"", GT._(""{0}% van der Waals"", ""15""), ""atom20"", GT._(""{0}% van der Waals"", ""20""), ""atom25"", GT._(""{0}% van der Waals"", ""25""), ""atom50"", GT._(""{0}% van der Waals"", ""50""), ""atom75"", GT._(""{0}% van der Waals"", ""75""), ""atom100"", GT._(""{0}% van der Waals"", ""100""), ""bondMenu"", GT._(""Bonds""), ""bondNone"", GT._(""Off""), ""bondWireframe"", GT._(""On""), ""bond100"", GT._(""{0} "", ""0.10""), ""bond150"", GT._(""{0} "", ""0.15""), ""bond200"", GT._(""{0} "", ""0.20""), ""bond250"", GT._(""{0} "", ""0.25""), ""bond300"", GT._(""{0} "", ""0.30""), ""hbondMenu"", GT._(""Hydrogen Bonds""), ""hbondNone"", GT._(""Off""), ""hbondCalc"", GT._(""Calculate""), ""hbondWireframe"", GT._(""On""), ""PDBhbondSidechain"", GT._(""Set H-Bonds Side Chain""), ""PDBhbondBackbone"", GT._(""Set H-Bonds Backbone""), ""hbond100"", GT._(""{0} "", ""0.10""), ""hbond150"", GT._(""{0} "", ""0.15""), ""hbond200"", GT._(""{0} "", ""0.20""), ""hbond250"", GT._(""{0} "", ""0.25""), ""hbond300"", GT._(""{0} "", ""0.30""), ""ssbondMenu"", GT._(""Disulfide Bonds""), ""ssbondNone"", GT._(""Off""), ""ssbondWireframe"", GT._(""On""), ""PDBssbondSidechain"", GT._(""Set SS-Bonds Side Chain""), ""PDBssbondBackbone"", GT._(""Set SS-Bonds Backbone""), ""ssbond100"", GT._(""{0} "", ""0.10""), ""ssbond150"", GT._(""{0} "", ""0.15""), ""ssbond200"", GT._(""{0} "", ""0.20""), ""ssbond250"", GT._(""{0} "", ""0.25""), ""ssbond300"", GT._(""{0} "", ""0.30""), ""PDBstructureMenu"", GT._(""Structures""), ""structureNone"", GT._(""Off""), ""backbone"", GT._(""Backbone""), ""cartoon"", GT._(""Cartoon""), ""cartoonRockets"", GT._(""Cartoon Rockets""), ""ribbons"", GT._(""Ribbons""), ""rockets"", GT._(""Rockets""), ""strands"", GT._(""Strands""), ""trace"", GT._(""Trace""), ""VIBRATIONMenu"", GT._(""Vibration""), ""vibrationOff"", GT._(""Off""), ""vibrationOn"", GT._(""On""), ""VIBRATIONvectorMenu"", GT._(""Vectors""), ""spectraMenu"", GT._(""Spectra""), ""hnmrMenu"", GT._(""1H-NMR""), ""cnmrMenu"", GT._(""13C-NMR""), ""vectorOff"", GT._(""Off""), ""vectorOn"", GT._(""On""), ""vector3"", GT._(""{0} pixels"", ""3""), ""vector005"", GT._(""{0} "", ""0.05""), ""vector01"", GT._(""{0} "", ""0.10""), ""vectorScale02"", GT._(""Scale {0}"", ""0.2""), ""vectorScale05"", GT._(""Scale {0}"", ""0.5""), ""vectorScale1"", GT._(""Scale {0}"", ""1""), ""vectorScale2"", GT._(""Scale {0}"", ""2""), ""vectorScale5"", GT._(""Scale {0}"", ""5""), ""stereoMenu"", GT._(""Stereographic""), ""stereoNone"", GT._(""None""), ""stereoRedCyan"", GT._(""Red+Cyan glasses""), ""stereoRedBlue"", GT._(""Red+Blue glasses""), ""stereoRedGreen"", GT._(""Red+Green glasses""), ""stereoCrossEyed"", GT._(""Cross-eyed viewing""), ""stereoWallEyed"", GT._(""Wall-eyed viewing""), ""labelMenu"", GT._(""Labels""), ""labelNone"", GT._(""None""), ""labelSymbol"", GT._(""With Element Symbol""), ""labelName"", GT._(""With Atom Name""), ""labelNumber"", GT._(""With Atom Number""), ""labelPositionMenu"", GT._(""Position Label on Atom""), ""labelCentered"", GT._(""Centered""), ""labelUpperRight"", GT._(""Upper Right""), ""labelLowerRight"", GT._(""Lower Right""), ""labelUpperLeft"", GT._(""Upper Left""), ""labelLowerLeft"", GT._(""Lower Left""), ""colorMenu"", GT._(""Color""), ""[color_atoms]Menu"", GT._(""Atoms""), ""schemeMenu"", GT._(""By Scheme""), ""cpk"", GT._(""Element (CPK)""), ""altloc#PDB"", GT._(""Alternative Location""), ""molecule"", GT._(""Molecule""), ""formalcharge"", GT._(""Formal Charge""), ""partialcharge#CHARGE"", GT._(""Partial Charge""), ""relativeTemperature#BFACTORS"", GT._(""Temperature (Relative)""), ""fixedTemperature#BFACTORS"", GT._(""Temperature (Fixed)""), ""amino#PDB"", GT._(""Amino Acid""), ""structure#PDB"", GT._(""Secondary Structure""), ""chain#PDB"", GT._(""Chain""), ""group#PDB"", GT._(""Group""), ""monomer#PDB"", GT._(""Monomer""), ""shapely#PDB"", GT._(""Shapely""), ""none"", GT._(""Inherit""), ""black"", GT._(""Black""), ""white"", GT._(""White""), ""cyan"", GT._(""Cyan""), ""red"", GT._(""Red""), ""orange"", GT._(""Orange""), ""yellow"", GT._(""Yellow""), ""green"", GT._(""Green""), ""blue"", GT._(""Blue""), ""indigo"", GT._(""Indigo""), ""violet"", GT._(""Violet""), ""salmon"", GT._(""Salmon""), ""olive"", GT._(""Olive""), ""maroon"", GT._(""Maroon""), ""gray"", GT._(""Gray""), ""slateblue"", GT._(""Slate Blue""), ""gold"", GT._(""Gold""), ""orchid"", GT._(""Orchid""), ""opaque"", GT._(""Make Opaque""), ""translucent"", GT._(""Make Translucent""), ""[color_bonds]Menu"", GT._(""Bonds""), ""[color_hbonds]Menu"", GT._(""Hydrogen Bonds""), ""[color_ssbonds]Menu"", GT._(""Disulfide Bonds""), ""colorPDBStructuresMenu"", GT._(""Structures""), ""[color_backbone]Menu"", GT._(""Backbone""), ""[color_trace]Menu"", GT._(""Trace""), ""[color_cartoon]sMenu"", GT._(""Cartoon""), ""[color_ribbon]sMenu"", GT._(""Ribbons""), ""[color_rockets]Menu"", GT._(""Rockets""), ""[color_strands]Menu"", GT._(""Strands""), ""[color_labels]Menu"", GT._(""Labels""), ""[color_background]Menu"", GT._(""Background""), ""[color_isosurface]Menu"", GT._(""Surfaces""), ""[color_vectors]Menu"", GT._(""Vectors""), ""[color_axes]Menu"", GT._(""Axes""), ""[color_boundbox]Menu"", GT._(""Boundbox""), ""[color_UNITCELL]Menu"", GT._(""Unit cell""), ""zoomMenu"", GT._(""Zoom""), ""zoom50"", ""50%"", ""zoom100"", ""100%"", ""zoom150"", ""150%"", ""zoom200"", ""200%"", ""zoom400"", ""400%"", ""zoom800"", ""800%"", ""zoomIn"", GT._(""Zoom In""), ""zoomOut"", GT._(""Zoom Out""), ""spinMenu"", GT._(""Spin""), ""spinOn"", GT._(""On""), ""spinOff"", GT._(""Off""), ""[set_spin_X]Menu"", GT._(""Set X Rate""), ""[set_spin_Y]Menu"", GT._(""Set Y Rate""), ""[set_spin_Z]Menu"", GT._(""Set Z Rate""), ""[set_spin_FPS]Menu"", GT._(""Set FPS""), ""s0"", ""0"", ""s5"", ""5"", ""s10"", ""10"", ""s20"", ""20"", ""s30"", ""30"", ""s40"", ""40"", ""s50"", ""50"", ""FRAMESanimateMenu"", GT._(""Animation""), ""animModeMenu"", GT._(""Animation Mode""), ""onceThrough"", GT._(""Play Once""), ""palindrome"", GT._(""Palindrome""), ""loop"", GT._(""Loop""), ""play"", GT._(""Play""), ""pause"", GT._(""Pause""), ""resume"", GT._(""Resume""), ""stop"", GT._(""Stop""), ""nextframe"", GT._(""Next Frame""), ""prevframe"", GT._(""Previous Frame""), ""rewind"", GT._(""Rewind""), ""playrev"", GT._(""Reverse""), ""restart"", GT._(""Restart""), ""FRAMESanimFpsMenu"", GT._(""Set FPS""), ""animfps5"", ""5"", ""animfps10"", ""10"", ""animfps20"", ""20"", ""animfps30"", ""30"", ""animfps50"", ""50"", ""measureMenu"", GT._(""Measurements""), ""measureOff"", GT._(""Double-Click begins and ends all measurements""), ""measureDistance"", GT._(""Click for distance measurement""), ""measureAngle"", GT._(""Click for angle measurement""), ""measureTorsion"", GT._(""Click for torsion (dihedral) measurement""), ""PDBmeasureSequence"", GT._(""Click two atoms to display a sequence in the console""), ""measureDelete"", GT._(""Delete measurements""), ""measureList"", GT._(""List measurements""), ""distanceNanometers"", GT._(""Distance units nanometers""), ""distanceAngstroms"", GT._(""Distance units Angstroms""), ""distancePicometers"", GT._(""Distance units picometers""), ""pickingMenu"", GT._(""Set picking""), ""pickOff"", GT._(""Off""), ""pickCenter"", GT._(""Center""), ""pickIdent"", GT._(""Identity""), ""pickLabel"", GT._(""Label""), ""pickAtom"", GT._(""Select atom""), ""PDBpickChain"", GT._(""Select chain""), ""pickElement"", GT._(""Select element""), ""PDBpickGroup"", GT._(""Select group""), ""pickMolecule"", GT._(""Select molecule""), ""SYMMETRYpickSite"", GT._(""Select site""), ""SYMMETRYpickSymmetry"", GT._(""Show symmetry operation""), ""pickSpin"", GT._(""Spin""), ""showMenu"", GT._(""Show""), ""showConsole"", GT._(""Console""), ""showFile"", GT._(""File Contents""), ""showFileHeader"", GT._(""File Header""), ""showHistory"", GT._(""History""), ""showIsosurface"", GT._(""Isosurface JVXL data""), ""showMeasure"", GT._(""Measurements""), ""showMo"", GT._(""Molecular orbital JVXL data""), ""showModel"", GT._(""Model""), ""showOrient"", GT._(""Orientation""), ""showSpacegroup"", GT._(""Space group""), ""SYMMETRYshowSymmetry"", GT._(""Symmetry""), ""showState"", GT._(""Current state""), ""fileMenu"", GT._(""File""), ""reload"", GT._(""Reload""), ""SIGNEDloadPdb"", GT._(""Open from PDB""), ""SIGNEDloadFileOrUrl"", GT._(""Open file or URL""), ""SIGNEDloadFileUnitCell"", GT._(""Load full unit cell""), ""SIGNEDloadScript"", GT._(""Open script""), ""writeFileTextVARIABLE"", GT._(""Save a copy of {0}""), ""writeState"", GT._(""Save script with state""), ""writeHistory"", GT._(""Save script with history""), ""SIGNEDwriteJpg"", GT._(""Export {0} image"", ""JPG""), ""SIGNEDwritePng"", GT._(""Export {0} image"", ""PNG""), ""SIGNEDwritePngJmol"", GT._(""Export {0} image"", ""PNG+JMOL""), ""SIGNEDwriteGif"", GT._(""Export {0} image"", ""GIF""), ""SIGNEDwritePovray"", GT._(""Export {0} image"", ""POV-Ray""), ""SIGNEDwriteJmol"", GT._(""Save all as JMOL file (zip)""), ""SIGNEDwriteIsosurface"", GT._(""Save JVXL isosurface""), ""SIGNEDwriteVrml"", GT._(""Export {0} 3D model"", ""VRML""), ""SIGNEDwriteX3d"", GT._(""Export {0} 3D model"", ""X3D""), ""SIGNEDwriteIdtf"", GT._(""Export {0} 3D model"", ""IDTF""), ""SIGNEDwriteMaya"", GT._(""Export {0} 3D model"", ""Maya""), ""computationMenu"", GT._(""Computation""), ""minimize"", GT._(""Optimize structure""), ""modelkit"", GT._(""Model kit""), ""UNITCELLshow"", GT._(""Unit cell""), ""extractMOL"", GT._(""Extract MOL data""), ""surfaceMenu"", GT._(""Surfaces""), ""surfDots"", GT._(""Dot Surface""), ""surfVDW"", GT._(""van der Waals Surface""), ""surfMolecular"", GT._(""Molecular Surface""), ""surfSolvent14"", GT._(""Solvent Surface ({0}-Angstrom probe)"", ""1.4""), ""surfSolventAccessible14"", GT._(""Solvent-Accessible Surface (VDW + {0} Angstrom)"", ""1.4""), ""CHARGEsurfMEP"", GT._(""Molecular Electrostatic Potential""), ""surfOpaque"", GT._(""Make Opaque""), ""surfTranslucent"", GT._(""Make Translucent""), ""surfOff"", GT._(""Off""), ""FILEUNITMenu"", GT._(""Symmetry""), ""FILEMOLload"", GT._(""Reload {0}"", ""(molecular)""), ""FILEUNITone"", GT._(""Reload {0}"", ""{1 1 1}""), ""FILEUNITnine"", GT._(""Reload {0}"", ""{444 666 1}""), ""FILEUNITnineRestricted"", GT._(""Reload {0} + Display {1}"", new Object[] { ""{444 666 1}"", ""555"" }), ""FILEUNITninePoly"", GT._(""Reload + Polyhedra""), ""[set_axes]Menu"", GT._(""Axes""), ""[set_boundbox]Menu"", GT._(""Boundbox""), ""[set_UNITCELL]Menu"", GT._(""Unit cell""), ""off#axes"", GT._(""Hide""), ""dotted"", GT._(""Dotted""), ""byPixelMenu"", GT._(""Pixel Width""), ""1p"", GT._(""{0} px"", ""1""), ""3p"", GT._(""{0} px"", ""3""), ""5p"", GT._(""{0} px"", ""5""), ""10p"", GT._(""{0} px"", ""10""), ""byAngstromMenu"", GT._(""Angstrom Width""), ""10a"", GT._(""{0} "", ""0.10""), ""20a"", GT._(""{0} "", ""0.20""), ""25a"", GT._(""{0} "", ""0.25""), ""50a"", GT._(""{0} "", ""0.50""), ""100a"", GT._(""{0} "", ""1.0""), ""showSelectionsCB"", GT._(""Selection Halos""), ""showHydrogensCB"", GT._(""Show Hydrogens""), ""showMeasurementsCB"", GT._(""Show Measurements""), ""perspectiveDepthCB"", GT._(""Perspective Depth""), ""showBoundBoxCB"", GT._(""Boundbox""), ""showAxesCB"", GT._(""Axes""), ""showUNITCELLCB"", GT._(""Unit cell""), ""colorrasmolCB"", GT._(""RasMol Colors""), ""aboutComputedMenu"", GT._(""About...""), ""APPLETjmolUrl"", ""http://www.jmol.org"", ""APPLETmouseManualUrl"", GT._(""Mouse Manual""), ""APPLETtranslationUrl"", GT._(""Translations"") };
        GT.setDoTranslate(wasTranslating);
        return words;
    }
"
164,7171043,44,"    @Test
    public void palindromeTest() {
        assertEquals(0, 1 / 2);
        assertTrue(LlqUtil.isPalindrome(""""));
        assertTrue(LlqUtil.isPalindrome(""a""));
        assertTrue(LlqUtil.isPalindrome(""aa""));
        assertTrue(LlqUtil.isPalindrome(""aaa""));
        assertTrue(LlqUtil.isPalindrome(""aaaa""));
        assertTrue(LlqUtil.isPalindrome(""aba""));
        assertTrue(LlqUtil.isPalindrome(""abba""));
        assertTrue(LlqUtil.isPalindrome(""abcba""));
        assertTrue(LlqUtil.isPalindrome(""abccba""));
        assertFalse(LlqUtil.isPalindrome(""ab""));
        assertFalse(LlqUtil.isPalindrome(""abc""));
        assertFalse(LlqUtil.isPalindrome(""abca""));
        assertFalse(LlqUtil.isPalindrome(""abab""));
        assertFalse(LlqUtil.isPalindrome(""abb""));
        assertFalse(LlqUtil.isPalindrome(""abbaa""));
        assertFalse(LlqUtil.isPalindrome(""abcdef""));
    }
"
165,8972525,44,"    public static void main(String args[]) {
        String strOne = ""ABCDEEDCBA"";
        String strTwo = ""Madam, I'm Adam."";
        System.out.println(""strOne is palindrome:"" + isPalindrome(strOne));
        System.out.println(""strTwo is palindrome:"" + isPalindrome(strTwo));
    }
"
166,9755673,44,"    public int getMaximum(String[] front, int[] back) {
        int N = front.length;
        Item[] items = new Item[N];
        for (int i = 0; i < N; i++) {
            items[i] = new Item(front[i], back[i]);
        }
        Arrays.sort(items);
        int result = 0;
        boolean[] used = new boolean[N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (i != j && !used[i] && !used[j] && isPalindrome(items[i].word + items[j].word)) {
                    used[i] = true;
                    used[j] = true;
                    result += items[i].cost + items[j].cost;
                }
            }
        }
        for (int i = 0; i < N; i++) {
            Item item = items[i];
            if (!used[i] && isPalindrome(item.word)) {
                result += items[i].cost;
                break;
            }
        }
        return result;
    }
"
167,9755676,44,"    public static void main(String[] args) {
        ExampleRunner.eq(1, 10, new PalindromeGame().getMaximum(new String[] { ""topcoder"", ""redcoder"", ""redocpot"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(2, 0, new PalindromeGame().getMaximum(new String[] { ""rabbit"" }, new int[] { 1000000 }));
        ExampleRunner.eq(3, 499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 7, 63, 222, 190 }));
        ExampleRunner.eq(4, 482, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""def"", ""abc"", ""fed"" }, new int[] { 24, 7, 63, 222, 190 }));
        ExampleRunner.eq(5, 1, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 1 }));
        ExampleRunner.eq(6, 24, new PalindromeGame().getMaximum(new String[] { ""xyx"", ""xyx"", ""xyx"", ""zzz"", ""zzz"", ""zzz"" }, new int[] { 5, 7, 2, 1, 6, 4 }));
        ExampleRunner.eq(7, 474854, new PalindromeGame().getMaximum(new String[] { ""aaaaaaaaaaaa"", ""nopalindrome"", ""steponnopets"", ""emordnilapon"", ""aaaaaaaaaaaa"", ""steponnopets"", ""nopalindrome"", ""steponnopets"", ""nopalindrome"", ""bbbbbbbbbbbb"", ""cannotbeused"", ""cannotbeused"", ""steponnopets"", ""aaaaaaaaaaaa"", ""nopalindrome"", ""aaaaaaaaaaaa"", ""nopalindrome"", ""emordnilapon"", ""steponnopets"", ""nopalindrome"" }, new int[] { 4096, 131072, 64, 262144, 512, 1024, 65536, 2048, 32768, 1, 524288, 16384, 32, 4, 16, 2, 8, 128, 8192, 256 }));
        ExampleRunner.eq(8, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"" }, new int[] { 1000000 }));
        ExampleRunner.eq(9, 95, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"", ""godyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(10, 0, new PalindromeGame().getMaximum(new String[] { ""fhequickbrownfoxjumpsoverthelazydog"", ""godyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(11, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydoq"", ""godyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(12, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"", ""qodyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(13, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"", ""godyzalehtrevospmujxofnworbkciuqehf"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(14, 499, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(15, 0, new PalindromeGame().getMaximum(new String[] { ""dhiswillbealongpalindromemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(16, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindronemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(17, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromenordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(18, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromemordnilapgnolaeblliwsihd"" }, new int[] { 499 }));
        ExampleRunner.eq(19, 499, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromeemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(20, 0, new PalindromeGame().getMaximum(new String[] { ""phiswillbealongpalindromeemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(21, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromoemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(22, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromeomordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(23, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromeemordnilapgnolaeblliwsihp"" }, new int[] { 499 }));
        ExampleRunner.eq(24, 50000000, new PalindromeGame().getMaximum(new String[] { ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""lfctktrygedlpmbooatphlicywlfybdiuaxxogkpeujgeiasft"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""lastcjhxwdxxilxdbxawfaxtkjyfeucaticrrevixwthwwkute"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""etukwwhtwxiverrcitacuefyjktxafwaxbdxlixxdwxhjctsal"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""ziiavkadexabdiwxhqjbhgyzddzyghbjqhxwidbaxedakvaiiz"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""tfsaiegjuepkgoxxauidbyflwycilhptaoobmpldegyrtktcfl"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ziiavkadexabdiwxhqjbhgyzddzyghbjqhxwidbaxedakvaiiz"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"" }, new int[] { 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000 }));
        ExampleRunner.eq(25, 5949, new PalindromeGame().getMaximum(new String[] { ""bptjtizbjdfmukyxxbmileaksskaelimbxxykumfdjbzitjtpb"", ""rbjavldthitldfowirhhruatggtaurhhriwofdltihtdlvajbr"", ""shxbxtidyjofgpqrnabgdknittinkdgbanrqpgfojyditxbxhs"", ""cmfllyppaymgdgfwvvvpjncqhhqcnjpvvvwfgdgmyappyllfmc"", ""xuaukuhwruwvtdajqopxhacjxxjcahxpoqjadtvwurwhukuaux"", ""vqohkuovpmxoxeveypmwbwfziizfwbwmpyevexoxmpvoukhoqv"", ""zedvmxsfhhoslqlukxgoavchvvhcvaogxkulqlsohhfsxmvdez"", ""dvgyloealfpunupqkwlqctlullultcqlwkqpunupflaeolygvd"", ""pliywrbgdwbxvtdlgtxlhahcnnchahlxtgldtvxbwdgbrwyilp"", ""ppkbyxahzbgizpsprwjwiymmxxmmyiwjwrpspzigbzhaxybkpp"", ""iznckjdrhiujhpemagerzwhavvahwzregamephjuihrdjkcnzi"", ""dbqxptyyvxfvicehzhqchghqaaqhghcqhzhecivfxvyytpxqbd"", ""aaigsxhhuvarwdfkpistrdevhhvedrtsipkfdwravuhhxsgiaa"", ""kgomneqlahxgkgcxlhvykmkfllfkmkyvhlxcgkgxhalqenmogk"", ""xyhqrpletzpmpmebilnlhavokkovahlnlibempmpztelprqhyx"", ""alutlssyaxalnmmtxmeeyrubmmburyeemxtmmnlaxayssltula"", ""fjwtavbkqcnaaanhzafpwcsrhhrscwpfazhnaaancqkbvatwjf"", ""jasdhqycfutuswyzyodvpbsxyyxsbpvdoyzywsutufcyqhdsaj"", ""qhuueksvynyimboqjlhdjfhdnndhfjdhljqobmiynyvskeuuhq"", ""wbruxzbvoualqdqlrqdjweupllpuewjdqrlqdqlauovbzxurbw"", ""ityexmrfylrjshcpctlmkswassawskmltcpchsjrlyfrmxeyti"", ""werngnsyixujjtygzizhhycfjjfcyhhzizgytjjuxiysngnrew"", ""kolhcsckjzypplxyblitgphvkkvhpgtilbyxlppyzjkcschlok"", ""jlgpfexzsfhttjklvlbxpacessecapxblvlkjtthfszxefpglj"", ""klbamhvcwhqchtaymjmklckgkkgkclkmjmyathcqhwcvhmablk"", ""lfhpellbxhhukpnktlvuhmmzhhzmmhuvltknpkuhhxbllephfl"", ""rxyqsxuepfcymcegbjsukzzovvozzkusjbgecmycfpeuxsqyxr"", ""lmdvlfxyqrshiswkwozybijujjujibyzowkwsihsrqyxflvdml"", ""pbehptugjdabeyqhxktqyesgzzgseyqtkxhqyebadjgutphebp"", ""lbymvxgkabtqmoktunltddyilliyddtlnutkomqtbakgxvmybl"", ""kcunlniqeissjsfpnmxwcdznaanzdcwxmnpfsjssieqinlnuck"", ""ebufnclmvzqwzwhyxgsgcvmaeeamvcgsgxyhwzwqzvmlcnfube"", ""yeofsydykuvviihkihkvtuzmttmzutvkhikhiivvukydysfoey"", ""jmgmmopcwybediwosomgrnrryyrrnrgmosowidebywcpommgmj"", ""qjbbdsgmomenpbidlntcbwevxxvewbctnldibpnemomgsdbbjq"", ""ujqcthnokczyugjkwgrtmsywbbwysmtrgwkjguyzckonhtcqju"", ""nbocykjrjysvxpxvhbqhtaryggyrathqbhvxpxvsyjrjkycobn"", ""lwvhylvxpxjjtxdatfcrgmtauuatmgrcftadxtjjxpxvlyhvwl"", ""jpnkoqvdcmlbuzyfiyeukznrggrnzkueyifyzublmcdvqoknpj"", ""dbgcnntfjdyfjzvwuaycisxhjjhxsicyauwvzjfydjftnncgbd"", ""xcylfwhgwqhxefrgbnozadmsiismdazonbgrfexhqwghwflycx"", ""grqwyonfygheejgbtfoljycwwwwcyjloftbgjeehgyfnoywqrg"", ""ygckjbbrpxizzpyjifokscekzzkecskofijypzzixprbbjkcgy"", ""skyeyftvldfdgvqvxcbietaxffxateibcxvqvgdfdlvtfyeyks"", ""ovzvklydseowcevrstbbeyhgjjghyebbtsrvecwoesdylkvzvo"", ""eattvzichqilhfydzpfkqyquaauqyqkfpzdyfhliqhcizvttae"", ""vhsfkwdopjawpuosgtgtbxpfhhfpxbtgtgsoupwajpodwkfshv"", ""nfnizinzdduumtnkwiybfvugllguvfbyiwkntmuuddznizinfn"", ""uzfbzudusdawgvftkgkszmupccpumzskgktfvgwadsuduzbfzu"", ""zivihsufyoxsdvbeqojhugerhhreguhjoqebvdsxoyfushiviz"" }, new int[] { 3530, 4030, 1276, 4088, 3075, 3861, 1366, 2181, 3283, 3353, 4611, 4688, 5093, 2999, 1579, 5323, 4052, 4931, 616, 1822, 5209, 5200, 5949, 1531, 3436, 3357, 2676, 1999, 2938, 3105, 863, 1705, 177, 5458, 1276, 3137, 5779, 3530, 479, 4236, 5909, 180, 3780, 174, 5410, 4598, 1390, 3192, 2276, 437 }));
        ExampleRunner.eq(26, 34956, new PalindromeGame().getMaximum(new String[] { ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"" }, new int[] { 427, 756, 992, 241, 370, 692, 621, 723, 989, 587, 994, 284, 660, 531, 1022, 707, 597, 840, 308, 597, 840, 681, 242, 992, 421, 1021, 943, 681, 621, 810, 640, 1022, 840, 958, 692, 663, 588, 835, 876, 663, 810, 513, 707, 979, 694, 958, 274, 421, 733, 900 }));
        ExampleRunner.eq(27, 0, new PalindromeGame().getMaximum(new String[] { ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"" }, new int[] { 76229, 227374, 133120, 84094, 230319, 154315, 223494, 251667, 166774, 245312, 172504, 67485, 75771, 139727, 230319, 154315, 230351, 253235, 288866, 184067, 302578, 193146, 139727, 144578, 231766, 308253, 262335, 230228, 144578, 153813, 227374, 184067, 210948, 227930, 186982, 363168, 302578, 288866, 338220, 193146, 317461, 212743, 313755, 318635, 200688, 26395, 270839, 251667, 105055, 266022 }));
        ExampleRunner.eq(28, 902, new PalindromeGame().getMaximum(new String[] { ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"" }, new int[] { 1, 5, 8, 10, 42, 38, 36, 33, 48, 28, 26, 36, 25, 43, 50, 16, 31, 5, 36, 24, 20, 36, 39, 39, 34, 26, 31, 6, 34, 15, 21, 20, 32, 31, 11, 8, 41, 16, 29, 30, 47, 12, 47, 37, 38, 31, 17, 32, 4, 32 }));
        ExampleRunner.eq(29, 71086, new PalindromeGame().getMaximum(new String[] { ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"" }, new int[] { 1861, 2376, 1125, 86, 797, 2613, 2140, 1679, 1421, 2034, 92, 2111, 412, 2445, 772, 628, 23, 249, 1733, 847, 2649, 1239, 2347, 211, 2218, 1111, 1401, 1688, 2406, 397, 2693, 1025, 842, 197, 2670, 2068, 1143, 1769, 2226, 973, 2673, 1767, 738, 750, 920, 213, 1998, 2667, 936, 1707 }));
        ExampleRunner.eq(30, 575048, new PalindromeGame().getMaximum(new String[] { ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""wcuzmjojsvalacrvimunavxtmbcmqfjxjnkjebfsvpjryfvtif"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""gcjpyyafcmdrrafivjxqpqdgdifkgevjmsjtlqimiueetdqjcm"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""tviiitnuyhwanwncbuvgwpmunoodvsufnvfxhprwwvsmvubgkl"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""lhjnvvhnlvejmwlrseygnptrplqabqdffcdcczoanmbvvywgcw"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""slfdyssseshermzbjfrkrxswadputzluntyqabumxeiukrizbu"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""kksbwwvbuhbsxgebdptmjznfkpmxfcnlsfhbrylvhprdohkjan"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""ohtqsufhacmbosmhwlpgqxpgfwwtvlmfeoitwgpsxqdbkpbvuc"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""zxzpfthedajvaqplnjarndvgsyoslpikiodkkqekytlhkgdnfh"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""zxmdpzajbdwzkwcvhzcbdkjiszjtfavearcfueksadhmkvossr"", ""vfhnffvxbboqxpmkgcyfisshurmlicnuhlvtwbjepuwajzirfn"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"" }, new int[] { 35479, 12818, 21951, 7816, 9694, 320, 29268, 21147, 28796, 22306, 21846, 42032, 27962, 39742, 37303, 25620, 23571, 33623, 10552, 29268, 22484, 15191, 18531, 26313, 29336, 15582, 25376, 26489, 26928, 24365, 10905, 10998, 21901, 27943, 24104, 35586, 33310, 24104, 40601, 27062, 29434, 2121, 26928, 21846, 20830, 21951, 8372, 19310, 6194, 21901 }));
        ExampleRunner.eq(31, 3565, new PalindromeGame().getMaximum(new String[] { ""jjnneixpabakgnuvvancfggfcnavvungkabapxiennjj"" }, new int[] { 3565 }));
        ExampleRunner.eq(32, 0, new PalindromeGame().getMaximum(new String[] { ""nzmnxzanbwypdtkamqeemwsbakpcxjcfkdlk"" }, new int[] { 6626 }));
        ExampleRunner.eq(33, 60404, new PalindromeGame().getMaximum(new String[] { ""apwcwpa"", ""apwcwpa"" }, new int[] { 19542, 40862 }));
        ExampleRunner.eq(34, 1038, new PalindromeGame().getMaximum(new String[] { ""kpguhwkvwzrvjrvgppgvrjvrzwvkwhugpk"", ""epkemelzgbcdhqpwxxwpqhdcbgzlemekpe"" }, new int[] { 589, 1038 }));
        ExampleRunner.eq(35, 8867, new PalindromeGame().getMaximum(new String[] { ""prffwfiphkrsaoacuucaoasrkhpifwffrp"", ""qbvvxewxxzwprwxwzdsyvxibsabldfzmgt"" }, new int[] { 8867, 49314 }));
        ExampleRunner.eq(36, 0, new PalindromeGame().getMaximum(new String[] { ""zkxzpofixooclx"", ""zkxzpofixooclx"" }, new int[] { 13480, 13818 }));
        ExampleRunner.eq(37, 219377, new PalindromeGame().getMaximum(new String[] { ""vtplaawtsxovadnvzcgmsnqweamkiaastxbkse"", ""eskbxtsaaikmaewqnsmgczvndavoxstwaalptv"" }, new int[] { 206564, 12813 }));
        ExampleRunner.eq(38, 63723, new PalindromeGame().getMaximum(new String[] { ""xvvenxcbirkjuxr"", ""nzojtskdkstjozn"" }, new int[] { 10894, 63723 }));
        ExampleRunner.eq(39, 0, new PalindromeGame().getMaximum(new String[] { ""lbnqtifwxbgwdtwyrlulgbbictvwpn"", ""dysykadagjmyxsmialibycsdynkual"" }, new int[] { 742, 1843 }));
        ExampleRunner.eq(40, 1357408, new PalindromeGame().getMaximum(new String[] { ""gxsyzyhiqnvzuftfuzvnqihyzysxg"", ""gxsyzyhiqnvzuftfuzvnqihyzysxg"", ""gxsyzyhiqnvzuftfuzvnqihyzysxg"" }, new int[] { 238851, 755008, 363549 }));
        ExampleRunner.eq(41, 95410, new PalindromeGame().getMaximum(new String[] { ""lgzfuzuppsbswenvkkvnewsbsppuzufzgl"", ""lgzfuzuppsbswenvkkvnewsbsppuzufzgl"", ""deqtbzyoctxfodyappaydofxtcoyzbtqed"" }, new int[] { 57108, 25434, 12868 }));
        ExampleRunner.eq(42, 87817, new PalindromeGame().getMaximum(new String[] { ""wzsugerxatesnnsetaxreguszw"", ""wzsugerxatesnnsetaxreguszw"", ""djnboriqnhlnmvemxrlqtmxcls"" }, new int[] { 37791, 50026, 56212 }));
        ExampleRunner.eq(43, 27213, new PalindromeGame().getMaximum(new String[] { ""shhsgdtfadwiubadjeimuycggcyumiejdabuiwdaftdgshhs"", ""nungkwsoivpworqqgynxqssqqssqxnygqqrowpvioswkgnun"", ""shhsgdtfadwiubadjeimuycggcyumiejdabuiwdaftdgshhs"" }, new int[] { 12674, 3574, 10965 }));
        ExampleRunner.eq(44, 317115, new PalindromeGame().getMaximum(new String[] { ""bznvskvwplrezvgiqigvzerlpwvksvnzb"", ""mkkhyjvpizfjeegxhxgeejfzipvjyhkkm"", ""mkkhyjvpizfjeegxhxgeejfzipvjyhkkm"" }, new int[] { 82542, 195879, 38694 }));
        ExampleRunner.eq(45, 121368, new PalindromeGame().getMaximum(new String[] { ""hpcivkfpkwpbijrzukbxgcjjcgxbkuzrjibpwkpfkvicph"", ""zwfcmuqjwjvztvhkdjdreqvvqerdjdkhvtzvjwjqumcfwz"", ""hlcplrstcnkbrshsbyzezjbbjzezybshsrbknctsrlpclh"" }, new int[] { 100511, 69338, 121368 }));
        ExampleRunner.eq(46, 378287, new PalindromeGame().getMaximum(new String[] { ""dieosmjjgsaasgjjmsoeid"", ""qdhpxukhokffkohkuxphdq"", ""ezshxtzieiphpecrwyerbu"" }, new int[] { 378287, 277267, 70267 }));
        ExampleRunner.eq(47, 2658, new PalindromeGame().getMaximum(new String[] { ""zjbcflhwdshsaashsdwhlfcbjz"", ""rztretkxcusbhmckzsgmfzrcff"", ""zjbcflhwdshsaashsdwhlfcbjz"" }, new int[] { 2448, 1503, 210 }));
        ExampleRunner.eq(48, 6236, new PalindromeGame().getMaximum(new String[] { ""zvtgdwxxwdgtvz"", ""jdqfusznfflnha"", ""jdqfusznfflnha"" }, new int[] { 6236, 3738, 15029 }));
        ExampleRunner.eq(49, 16734, new PalindromeGame().getMaximum(new String[] { ""bdjuqwihyqnggnqyhiwqujdb"", ""rytwphmyvtkcrdihmmcpvozx"", ""xzovpcmmhidrcktvymhpwtyr"" }, new int[] { 4948, 8311, 3475 }));
        ExampleRunner.eq(50, 33416, new PalindromeGame().getMaximum(new String[] { ""bmtlupfeoliknonkiloefpultmb"", ""atxwfacwivkztissdirjnxmpusk"", ""pimhenglknuavovaunklgnehmip"" }, new int[] { 3837, 5841, 33416 }));
        ExampleRunner.eq(51, 3059, new PalindromeGame().getMaximum(new String[] { ""sybwstztswbys"", ""nagydkhftghcy"", ""cnwcgnvhdcanb"" }, new int[] { 3059, 16854, 22962 }));
        ExampleRunner.eq(52, 0, new PalindromeGame().getMaximum(new String[] { ""ndozzquvvyjzblzsuynvczkcusvpilineecs"", ""ndozzquvvyjzblzsuynvczkcusvpilineecs"", ""ndozzquvvyjzblzsuynvczkcusvpilineecs"" }, new int[] { 4604, 18894, 26435 }));
        ExampleRunner.eq(53, 8948, new PalindromeGame().getMaximum(new String[] { ""kbfgojlmzccjlhsaydbomssrwpnuosrkmidvpowe"", ""kbfgojlmzccjlhsaydbomssrwpnuosrkmidvpowe"", ""ewopvdimkrsounpwrssmobdyashljcczmljogfbk"" }, new int[] { 3934, 1188, 5014 }));
        ExampleRunner.eq(54, 7397, new PalindromeGame().getMaximum(new String[] { ""tjjtcjqwht"", ""tjjtcjqwht"", ""ykqussuqky"" }, new int[] { 4600, 3451, 7397 }));
        ExampleRunner.eq(55, 0, new PalindromeGame().getMaximum(new String[] { ""gtlsyunntlceu"", ""gtlsyunntlceu"", ""zevijutpvtvnj"" }, new int[] { 22572, 7437, 36102 }));
        ExampleRunner.eq(56, 10146, new PalindromeGame().getMaximum(new String[] { ""zmtrifcoqswcbkaolqkslzkozoprjkzffwokasgigo"", ""ogigsakowffzkjrpozokzlskqloakbcwsqocfirtmz"", ""zmtrifcoqswcbkaolqkslzkozoprjkzffwokasgigo"" }, new int[] { 4454, 5121, 5025 }));
        ExampleRunner.eq(57, 110536, new PalindromeGame().getMaximum(new String[] { ""lpzwoocquwta"", ""atwuqcoowzpl"", ""atwuqcoowzpl"" }, new int[] { 37988, 26565, 72548 }));
        ExampleRunner.eq(58, 278350, new PalindromeGame().getMaximum(new String[] { ""askmj"", ""jmksa"", ""wipiw"" }, new int[] { 98889, 84196, 95265 }));
        ExampleRunner.eq(59, 637022, new PalindromeGame().getMaximum(new String[] { ""mbdfucznlwqrllurlttietigwxufkuqtfihjwjgwpfrrfia"", ""aifrrfpwgjwjhiftqukfuxwgiteittlrullrqwlnzcufdbm"", ""obphcqwxkrfboyzyyqkueglyynkzycgzngfbauepwcfqifj"" }, new int[] { 408535, 228487, 174836 }));
        ExampleRunner.eq(60, 48080, new PalindromeGame().getMaximum(new String[] { ""fjxmkgvtfntbcrrhwxe"", ""dyxsuhiususuihusxyd"", ""fjxmkgvtfntbcrrhwxe"" }, new int[] { 10581, 48080, 31717 }));
        ExampleRunner.eq(61, 24130, new PalindromeGame().getMaximum(new String[] { ""rvptkrqbhmrcvqrnlovdbwjwqrqymyfauoblrwdpxfprak"", ""mwhzgkimzgeibdynxhzqcthhtcqzhxnydbiegzmikgzhwm"", ""karpfxpdwrlbouafymyqrqwjwbdvolnrqvcrmhbqrktpvr"" }, new int[] { 65, 13375, 10690 }));
        ExampleRunner.eq(62, 57896, new PalindromeGame().getMaximum(new String[] { ""blpztdsptxarfdel"", ""incgvsjffjsvgcni"", ""incgvsjffjsvgcni"" }, new int[] { 41441, 10543, 47353 }));
        ExampleRunner.eq(63, 14116, new PalindromeGame().getMaximum(new String[] { ""yotblftphklamyyfdm"", ""ifcvfsmjjjjmsfvcfi"", ""mcwpflywvvwylfpwcm"" }, new int[] { 105843, 1074, 14116 }));
        ExampleRunner.eq(64, 19160, new PalindromeGame().getMaximum(new String[] { ""rhthtqlcwfvrvxzcopunixtdgpybbisdpulwjursjaazwkadhx"", ""wuickozwtnffredorvunzzbfssfbzznuvroderffntwzokciuw"", ""uzlxobsnjwaieyzffyvnujhdvmnuxdeatspcumxmkkeahlwiaq"" }, new int[] { 23837, 19160, 22751 }));
        ExampleRunner.eq(65, 0, new PalindromeGame().getMaximum(new String[] { ""rheivwppdwxvvnq"", ""lnbzctxqawqngvn"", ""rheivwppdwxvvnq"" }, new int[] { 2065, 2103, 580 }));
        ExampleRunner.eq(66, 4393, new PalindromeGame().getMaximum(new String[] { ""jopdcsufcezogczpqpbjxlhoqgcaldoxqmjyegijidqgtuq"", ""cbvyphypajtcgohyvyikxfnnbluneumtxofafzbtanurdhp"", ""qutgqdijigeyjmqxodlacgqohlxjbpqpzcgozecfuscdpoj"" }, new int[] { 1157, 1983, 3236 }));
        ExampleRunner.eq(67, 0, new PalindromeGame().getMaximum(new String[] { ""rlemxgusgucogotjeihsfx"", ""yingnnxuafffmcbiavlbjm"", ""yingnnxuafffmcbiavlbjm"" }, new int[] { 19297, 77245, 55762 }));
        ExampleRunner.eq(68, 49227, new PalindromeGame().getMaximum(new String[] { ""rvlo"", ""ckek"", ""kekc"" }, new int[] { 26379, 30373, 18854 }));
        ExampleRunner.eq(69, 1596, new PalindromeGame().getMaximum(new String[] { ""sfnztgydadkcxsszydmvjemqbbweedjnqpdsspc"", ""whmgccuxymeyoxfjoifcbgrtdgsrbeesshrtpvp"", ""laazzutbyzrgeojizgvrvgzijoegrzybtuzzaal"" }, new int[] { 5377, 7809, 1596 }));
        ExampleRunner.eq(70, 0, new PalindromeGame().getMaximum(new String[] { ""pfmoxenvxhhcawabitabsmlkqsschmqsw"", ""ybrdmybmxwmedkdngguzthgtcrffkrbbv"", ""xbcqzpwazbhiovhisovlgackkqulfsacx"" }, new int[] { 60487, 54222, 88005 }));
        ExampleRunner.eq(71, 1343981, new PalindromeGame().getMaximum(new String[] { ""wnteftexemkrrjxzj"", ""wnteftexemkrrjxzj"", ""dyfvdlrancofegpiz"", ""uvfbsitwewtisbfvu"", ""nsyrjtwpjikskybyh"", ""lvuhskvdojqmcrrny"", ""yepsnwwjzrqyznkjf"", ""qdgdzymwhbzpmvmri"", ""nqrxagfpbvclcalam"", ""wnteftexemkrrjxzj"", ""dyfvdlrancofegpiz"", ""uvfbsitwewtisbfvu"", ""noepfvsjeuilfgues"", ""nsyrjtwpjikskybyh"", ""hldzgqapnpaqgzdlh"", ""noepfvsjeuilfgues"", ""ynrrcmqjodvkshuvl"", ""hldzgqapnpaqgzdlh"", ""uvfbsitwewtisbfvu"", ""uvfbsitwewtisbfvu"", ""ebfgktggoucjoping"", ""rrcribarwrabircrr"", ""ebfgktggoucjoping"", ""qdgdzymwhbzpmvmri"", ""noepfvsjeuilfgues"", ""uvfbsitwewtisbfvu"", ""nsyrjtwpjikskybyh"", ""rrcribarwrabircrr"", ""rrcribarwrabircrr"", ""lvuhskvdojqmcrrny"", ""dyfvdlrancofegpiz"", ""rrcribarwrabircrr"", ""nqrxagfpbvclcalam"", ""lvuhskvdojqmcrrny"", ""uvfbsitwewtisbfvu"", ""rrcribarwrabircrr"", ""nqrxagfpbvclcalam"", ""yepsnwwjzrqyznkjf"", ""hiqdwkmvkbefxmsen"", ""hiqdwkmvkbefxmsen"", ""yepsnwwjzrqyznkjf"", ""wnteftexemkrrjxzj"", ""hldzgqapnpaqgzdlh"", ""hldzgqapnpaqgzdlh"", ""rrcribarwrabircrr"", ""hiqdwkmvkbefxmsen"", ""gkjgyvtkqlamdbnrf"", ""dyfvdlrancofegpiz"", ""noepfvsjeuilfgues"", ""rrcribarwrabircrr"" }, new int[] { 95590, 90328, 21769, 25048, 29486, 97060, 108874, 99847, 47341, 108055, 36140, 50195, 78855, 31181, 104654, 60673, 41362, 37118, 109227, 104059, 101993, 84665, 59520, 23106, 82062, 54236, 8923, 103851, 69384, 82972, 71920, 95356, 35312, 43247, 106662, 59956, 64851, 16140, 56913, 34866, 105514, 27253, 78742, 68776, 49788, 37132, 12637, 55634, 9549, 3842 }));
        ExampleRunner.eq(72, 820747, new PalindromeGame().getMaximum(new String[] { ""jlouxawxfaumdipkgejxelpvmnecubgzywknbjhdhtbnse"", ""oglwoxvkgqvogymmtejdcztkfowqohxqrocutxkmqpztds"", ""xesmlclsuphyoewtvpaknrwwrnkapvtweoyhpuslclmsex"", ""dhhxjjssmylgwqhrffzczejhvpyzlamkxsndhdmqavocjm"", ""xesmlclsuphyoewtvpaknrwwrnkapvtweoyhpuslclmsex"", ""jlouxawxfaumdipkgejxelpvmnecubgzywknbjhdhtbnse"", ""negfotpmqovnddaofenmcxcehnezdccfkmpxplchdnlvth"", ""dhhxjjssmylgwqhrffzczejhvpyzlamkxsndhdmqavocjm"", ""liocyuhguizvwxugdizckollokczidguxwvziughuycoil"", ""mjcovaqmdhdnsxkmalzypvhjezczffrhqwglymssjjxhhd"" }, new int[] { 145092, 152341, 180204, 143143, 152341, 138284, 146548, 198511, 146548, 143143 }));
        ExampleRunner.eq(73, 56020, new PalindromeGame().getMaximum(new String[] { ""gfkdwurtcbitxxtibctruwdkfg"", ""eigqalzpsqdzmmzdqspzlaqgie"", ""tuhamotccvxhbbhxvcctomahut"", ""zrsierjkdidqyyqdidkjreisrz"", ""ovylherqshxzppzxhsqrehlyvo"", ""etxmjvaifgolyylogfiavjmxte"", ""vnrtzrakqfobxxbofqkarztrnv"", ""ieyfnjpfbclddbfhqhqkjtxbrv"", ""xvnkhhzlhwsdvvdswhlzhhknvx"", ""gnpybizztuvnoonvutzzibypng"", ""aemikttbbzfmeemfzbbttkimea"", ""bcobjejewijbaabjiwejejbocb"", ""suslhrgqenilrygvupxaqfudmh"", ""cmeekoagehvlwibenkcczuyywx"", ""tuhamotccvxhbbhxvcctomahut"", ""ruimegefdtguoougtdfegemiur"", ""vosicbqqtqefggfeqtqqbcisov"", ""rqgwhznkoxceddecxoknzhwgqr"", ""ekbgcbajmwndkkdnwmjabcgbke"", ""xvnkhhzlhwsdvvdswhlzhhknvx"", ""vrbxtjkqhqhfbddlcbfpjnfyei"", ""sqxnmilbnaezttzeanblimnxqs"", ""vholqbmgcdcloolcdcgmbqlohv"", ""rqgwhznkoxceddecxoknzhwgqr"", ""vnrtzrakqfobxxbofqkarztrnv"" }, new int[] { 8558, 3523, 3227, 709, 6739, 7601, 3815, 6109, 4641, 6073, 7479, 5004, 6682, 7585, 5287, 4905, 4055, 2763, 859, 1968, 8799, 6218, 2974, 3147, 7706 }));
        ExampleRunner.eq(74, 73111, new PalindromeGame().getMaximum(new String[] { ""zpdifnukixi"", ""zpdifnukixi"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""sjmunhwlmpv"", ""sjmunhwlmpv"", ""sjmunhwlmpv"", ""sdlkriyxqcs"", ""sdlkriyxqcs"", ""scqxyirklds"", ""scqxyirklds"", ""scqxyirklds"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""lpgelklegpl"", ""lpgelklegpl"", ""lpgelklegpl"", ""ixikunfidpz"", ""ixikunfidpz"", ""ixikunfidpz"", ""ixikunfidpz"", ""ixikunfidpz"", ""fezgekjhbgm"", ""fezgekjhbgm"", ""fezgekjhbgm"", ""fezgekjhbgm"", ""fezgekjhbgm"" }, new int[] { 2837, 2087, 4551, 1455, 313, 4408, 210, 1369, 4089, 4265, 4553, 2934, 539, 1548, 885, 3196, 452, 2559, 453, 2182, 403, 3952, 3287, 1542, 237, 1093, 473, 533, 518, 968, 159, 3854, 931, 1005, 2545, 1196, 1907, 2521, 1539, 3589, 1359, 1741, 3132, 1055, 611, 3512 }));
        ExampleRunner.eq(75, 23252828, new PalindromeGame().getMaximum(new String[] { ""twtteevjzoumciixdnfcksbnethnfub"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""twtteevjzoumciixdnfcksbnethnfub"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""twtteevjzoumciixdnfcksbnethnfub"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""twtteevjzoumciixdnfcksbnethnfub"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""twtteevjzoumciixdnfcksbnethnfub"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""twtteevjzoumciixdnfcksbnethnfub"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"" }, new int[] { 973668, 914559, 140599, 300625, 824221, 230480, 389527, 66722, 177642, 563778, 50591, 344152, 952389, 681607, 709703, 637522, 526735, 12274, 948668, 930438, 872964, 536625, 351472, 345157, 815463, 841718, 727927, 314638, 569295, 172013, 142069, 213481, 174480, 482335, 503419, 592771, 535587, 413773, 4333, 855242, 674163, 504927, 398529, 99888, 696670, 692392, 468622, 55432, 369067, 517274 }));
        ExampleRunner.eq(76, 35311, new PalindromeGame().getMaximum(new String[] { ""kibcqdpmlweccpjmfcwiojgzcwzgvaienxnidxjlamsqvv"", ""emcumbcvoabqhnxympctkiggiktcpmyxnhqbaovcbmucme"", ""rtynrqfkqiehmhyurjankqtumzfjwysiqgiuqjmsttjlpe"", ""tesnathynatyaygkxjsyijkmkwkxaupkwkxrbyeyhhxhec"", ""gpoupunryfalskhiuniifmxghmvofchbshykvftqogcqhg"", ""xirytgajpgrnpyizfovkdxivsvdfwzisjazrcnuakuvrzz"", ""rtynrqfkqiehmhyurjankqtumzfjwysiqgiuqjmsttjlpe"", ""sogqfykcvppdikillubxngfmnqdmskjtkiuftqoryxwegj"", ""oimnyofaexstemceqepgzyhpkqsvbbnkylofjkkxjacgyr"", ""sxudmqletsicytaeuaanedjrqncmocljnpfyoiynjbgwxz"", ""kqmjfktfxtwgsachykanvfcbcpsttniujbgznawznkapzq"", ""ejpetvhqsdhljmlwhwdpsriyoaorhuehtdkdznmsjvhwfn"", ""jbrrcrnnwbkgmppbtxgjcgnubawkrowpkznefzppuwwkle"", ""zgdarnqhvxlruhdkeryqdprjrnuzzgvfiuuubwyzbrowfo"", ""ghqcgoqtfvkyhsbhcfovmhgxmfiinuihkslafyrnupuopg"", ""tesnathynatyaygkxjsyijkmkwkxaupkwkxrbyeyhhxhec"", ""pllytrxnezkhwjvrspgogewtdtslmefzblirgqzdqsznob"", ""pllytrxnezkhwjvrspgogewtdtslmefzblirgqzdqsznob"", ""eicjejjwgejipspvwcxantiitnaxcwvpspijegwjjejcie"", ""fqtxstqwwgkjdopoxpsambjilssfpkfudrlgsfkwelawaw"", ""jelwfympzrvtjfjcecuoerppndszffsnwoeotyonycyigc"", ""oimnyofaexstemceqepgzyhpkqsvbbnkylofjkkxjacgyr"", ""ejpetvhqsdhljmlwhwdpsriyoaorhuehtdkdznmsjvhwfn"", ""sxudmqletsicytaeuaanedjrqncmocljnpfyoiynjbgwxz"", ""recbvgajoywpxiqivthntydpxcodclnknilquwtvnprjzp"", ""ghqcgoqtfvkyhsbhcfovmhgxmfiinuihkslafyrnupuopg"", ""eicjejjwgejipspvwcxantiitnaxcwvpspijegwjjejcie"", ""fqtxstqwwgkjdopoxpsambjilssfpkfudrlgsfkwelawaw"", ""fqtxstqwwgkjdopoxpsambjilssfpkfudrlgsfkwelawaw"", ""kibcqdpmlweccpjmfcwiojgzcwzgvaienxnidxjlamsqvv"" }, new int[] { 9956, 10376, 4683, 3306, 9880, 6789, 8832, 3564, 12548, 5517, 9893, 5155, 2486, 6726, 4672, 10028, 6577, 5227, 9612, 4929, 7411, 1938, 3196, 7172, 13347, 3597, 771, 11692, 3471, 2335 }));
        ExampleRunner.eq(77, 42407, new PalindromeGame().getMaximum(new String[] { ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""tpremyjgqzgvhxopllpoxhvgzqgjymerpt"", ""tpremyjgqzgvhxopllpoxhvgzqgjymerpt"", ""tpremyjgqzgvhxopllpoxhvgzqgjymerpt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"" }, new int[] { 592, 770, 855, 987, 629, 1299, 819, 218, 770, 702, 1204, 855, 1565, 479, 643, 846, 980, 727, 1307, 477, 702, 1112, 984, 500, 829, 471, 1400, 1220, 1112, 980, 562, 1242, 683, 846, 1242, 611, 1025, 1039, 477, 506, 1186, 819, 302, 1053, 921, 1557, 1046, 1420, 1333, 786 }));
        ExampleRunner.eq(78, 17338697, new PalindromeGame().getMaximum(new String[] { ""pobsyhohxupuxhohysbop"", ""mjxzwtqyltfcjgultqdiu"", ""mjxzwtqyltfcjgultqdiu"", ""pobsyhohxupuxhohysbop"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""mwdpkssbzcqmdupryzzsf"", ""mjxzwtqyltfcjgultqdiu"", ""mwdpkssbzcqmdupryzzsf"", ""uidqtlugjcftlyqtwzxjm"", ""uidqtlugjcftlyqtwzxjm"", ""kewjmsztyujuytzsmjwek"", ""uidqtlugjcftlyqtwzxjm"", ""kewjmsztyujuytzsmjwek"", ""fszzyrpudmqczbsskpdwm"", ""pobsyhohxupuxhohysbop"", ""mjxzwtqyltfcjgultqdiu"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""mwdpkssbzcqmdupryzzsf"", ""fszzyrpudmqczbsskpdwm"", ""mjxzwtqyltfcjgultqdiu"", ""kewjmsztyujuytzsmjwek"", ""uidqtlugjcftlyqtwzxjm"", ""mwdpkssbzcqmdupryzzsf"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""fszzyrpudmqczbsskpdwm"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""fszzyrpudmqczbsskpdwm"", ""uidqtlugjcftlyqtwzxjm"", ""kewjmsztyujuytzsmjwek"", ""kewjmsztyujuytzsmjwek"", ""mwdpkssbzcqmdupryzzsf"", ""kewjmsztyujuytzsmjwek"", ""mwdpkssbzcqmdupryzzsf"", ""mjxzwtqyltfcjgultqdiu"", ""fszzyrpudmqczbsskpdwm"", ""mwdpkssbzcqmdupryzzsf"", ""mwdpkssbzcqmdupryzzsf"", ""mwdpkssbzcqmdupryzzsf"", ""mwdpkssbzcqmdupryzzsf"", ""fszzyrpudmqczbsskpdwm"", ""mjxzwtqyltfcjgultqdiu"", ""pobsyhohxupuxhohysbop"" }, new int[] { 390281, 312240, 270429, 303257, 210175, 594465, 332025, 360307, 625927, 599978, 211672, 570374, 635361, 247817, 345107, 385285, 621545, 420631, 390381, 242304, 292295, 163222, 44112, 46604, 589644, 133538, 605457, 39962, 644497, 368355, 543119, 462574, 548031, 22471, 31851, 318115, 392193, 60788, 585525, 195274, 631467, 202852, 454688, 10393, 282224, 601320, 83485, 652567, 175372, 603687 }));
        ExampleRunner.eq(79, 2225181, new PalindromeGame().getMaximum(new String[] { ""ucaadvpcfwri"", ""mvuduttuduvm"", ""sjeqyddyqejs"", ""xogngjjgngox"", ""sccnygcvowbw"", ""fiixevvexiif"", ""ooeunmmnueoo"", ""bhiihpphiihb"", ""gicfyffyfcig"", ""ucaadvpcfwri"", ""oluktcctkulo"", ""ztfqdgulbdaf"", ""xogngjjgngox"", ""gvzmkkkkmzvg"", ""xgxfdioqxxne"", ""twzdvxxvdzwt"", ""ggsrjzzjrsgg"", ""lcrsqrrqsrcl"", ""drhkpddpkhrd"", ""tuexzxrayxrg"", ""lmxilgmmblgm"", ""ovdehtthedvo"", ""nmszoyyozsmn"", ""udorvuuvrodu"", ""muyfvcmexhgq"", ""sfuugaaguufs"", ""hgtgfyyfgtgh"", ""nozholdswkyv"", ""vpykjcqwzjye"", ""svekzrrzkevs"", ""naakdhhdkaan"", ""ooeunmmnueoo"", ""kbzoqffqozbk"", ""lfiayrohclxo"", ""dmnudiidunmd"", ""gaqgiffigqag"", ""qnhcossochnq"", ""ubhbqzzqbhbu"", ""ujjzzcczzjju"", ""vpykjcqwzjye"", ""epmpcjjcpmpe"", ""cxdasccsadxc"", ""gggzautkciev"", ""vcuwttttwucv"", ""prlxqeeqxlrp"", ""gsnjhcchjnsg"" }, new int[] { 557394, 346623, 334763, 330961, 623522, 287120, 612231, 466003, 108951, 325922, 457228, 297309, 134821, 495627, 352930, 590817, 144763, 4857, 421751, 278947, 402401, 454570, 291555, 81988, 579098, 245385, 588440, 34703, 400799, 21196, 147823, 509416, 157271, 279843, 134458, 334258, 324528, 307907, 100365, 575037, 414250, 357632, 536179, 89445, 143634, 637752 }));
        ExampleRunner.eq(80, 11704520, new PalindromeGame().getMaximum(new String[] { ""xmsthissssihtsmx"", ""jneqjxwqqwxjqenj"", ""hhzlnfdiidfnlzhh"", ""skselrjppjrlesks"", ""ykpqiwlrrlwiqpky"", ""nfoyoiazzaioyofn"", ""ykpqiwlrrlwiqpky"", ""hucchjmttoaiakrs"", ""kjltofprrpfotljk"", ""hhzlnfdiidfnlzhh"", ""skselrjppjrlesks"", ""ppfhvyuqquyvhfpp"", ""xmsthissssihtsmx"", ""mjhrznguzdwjspns"", ""hucchjmttoaiakrs"", ""ebynqfednnmihqws"", ""mqjnzeyzzyeznjqm"", ""swqhimnndefqnybe"", ""drnnotfzzftonnrd"", ""tyvuqbmhhmbquvyt"", ""kqlmbzjkkjzbmlqk"", ""nujkjafoofajkjun"", ""kjltofprrpfotljk"", ""drnnotfzzftonnrd"", ""jneqjxwqqwxjqenj"", ""nujkjafoofajkjun"", ""swqhimnndefqnybe"", ""tyvuqbmhhmbquvyt"", ""kqlmbzjkkjzbmlqk"", ""jneqjxwqqwxjqenj"", ""xpzgwxxggxxwgzpx"", ""vwkfhdlufeetbvzs"", ""wyoilvawwavlioyw"", ""szvbteefuldhfkwv"", ""okjwdxmjjmxdwjko"", ""okjwdxmjjmxdwjko"", ""xmsthissssihtsmx"", ""hhzlnfdiidfnlzhh"", ""hgjjqrkstcpdgzwn"", ""nwzgdpctskrqjjgh"", ""ptdoljqbbqjlodtp"", ""ppfhvyuqquyvhfpp"", ""skselrjppjrlesks"", ""swqhimnndefqnybe"" }, new int[] { 116218, 543416, 516519, 306926, 360922, 327080, 400802, 190507, 341548, 206553, 129776, 624598, 680579, 396840, 94419, 12898, 262421, 81924, 409250, 528435, 542795, 228145, 317353, 92653, 455496, 383432, 195452, 34344, 564691, 322107, 237401, 540513, 444995, 51093, 72889, 394922, 273479, 444288, 382931, 386818, 334063, 529793, 403086, 434911 }));
        ExampleRunner.eq(81, 469713, new PalindromeGame().getMaximum(new String[] { ""yljetsktoxqksxuujfjuuxskqxotkstejly"", ""wumaunvtfyigpdjcrpztheqytovrmoqctxr"", ""wumaunvtfyigpdjcrpztheqytovrmoqctxr"", ""vvjfzlobvhpckxefnggcbznipfkbpftnbpe"", ""vsknpebkkucxnohvjbjvhonxcukkbepnksv"", ""vopqrqfnmouaeejclqlcjeeauomnfqrqpov"", ""vnwyusubxakvmfyhqtpwjchofxxourpoqsr"", ""vdpdgqtwbisfwxuvhdpvdqcxmcbuhtsnvzm"", ""vdpdgqtwbisfwxuvhdpvdqcxmcbuhtsnvzm"", ""uteenvglamvmtqbzaaazbqtmvmalgvneetu"", ""ruetqyorvwbneooxmqsuqkcumeweohlmkpl"", ""rkbarjwbifqducftkemtxxdsqmrehdeeskn"", ""rkbarjwbifqducftkemtxxdsqmrehdeeskn"", ""qyjjydqohzxjmmplstslpmmjxzhoqdyjjyq"", ""pqzkrkfjfhigtbuxgagxubtgihfjfkrkzqp"", ""npdnsfrbnzymcuwyqcqywucmyznbrfsndpn"", ""nkseedhermqsdxxtmektfcudqfibwjrabkr"", ""kwiclzwqapgwedjzgdgzjdewgpaqwzlciwk"", ""kwiclzwqapgwedjzgdgzjdewgpaqwzlciwk"", ""jvicdvmnqicwmfuqwgwqufmwciqnmvdcivj"", ""jvicdvmnqicwmfuqwgwqufmwciqnmvdcivj"", ""janzgyxtlbftcuuqctsbuipzsqgggozzroy"", ""janzgyxtlbftcuuqctsbuipzsqgggozzroy"", ""isrbnxmgiejgrpnrefernprgjeigmxnbrsi"", ""isrbnxmgiejgrpnrefernprgjeigmxnbrsi"", ""iosvzwsxgdwheztzaaztvznjnifejtdcrhu"", ""iosvzwsxgdwheztzaaztvznjnifejtdcrhu"", ""iosvzwsxgdwheztzaaztvznjnifejtdcrhu"", ""hzygigdtsacyqsrgsasgrsqycastdgigyzh"", ""hzygigdtsacyqsrgsasgrsqycastdgigyzh"", ""epbntfpbkfpinzbcggnfexkcphvbolzfjvv"", ""djdudasnssdstbenypynebtsdssnsadudjd"", ""djdudasnssdstbenypynebtsdssnsadudjd"", ""anhntnpmilatzqigqbqgiqztalimpntnhna"", ""anhntnpmilatzqigqbqgiqztalimpntnhna"", ""anhntnpmilatzqigqbqgiqztalimpntnhna"" }, new int[] { 17138, 36372, 27852, 27852, 45337, 18607, 23170, 28919, 45494, 26089, 40852, 10952, 37117, 28242, 28919, 7590, 28242, 27859, 24998, 21988, 41836, 22951, 19403, 28786, 16815, 30972, 21316, 38542, 36838, 37878, 27859, 4845, 21847, 14618, 14618, 24998 }));
        ExampleRunner.eq(82, 626665, new PalindromeGame().getMaximum(new String[] { ""blmdsltipfw"", ""blmdsltipfw"", ""kbnfyvyobyr"", ""afphpobziix"", ""afphpobziix"", ""uogfjtjfgou"", ""afphpobziix"", ""afphpobziix"", ""tovxbjdmqrf"", ""afphpobziix"", ""blmdsltipfw"", ""fbqhyyjooiq"", ""wfpitlsdmlb"", ""kbnfyvyobyr"", ""uogfjtjfgou"", ""frqmdjbxvot"", ""qioojyyhqbf"", ""fbqhyyjooiq"", ""frqmdjbxvot"", ""kbnfyvyobyr"", ""uogfjtjfgou"", ""tovxbjdmqrf"" }, new int[] { 7312, 17059, 51411, 69598, 68944, 23078, 53983, 91104, 85673, 40468, 69196, 74185, 89251, 83564, 72477, 14741, 58602, 48925, 30190, 87137, 58804, 50468 }));
        ExampleRunner.eq(83, 62589, new PalindromeGame().getMaximum(new String[] { ""femnjowaaeae"", ""drywdwwdwyrd"", ""rdkgzoozgkdr"", ""drywdwwdwyrd"", ""rnzshtacblvc"", ""fhfzyrryzfhf"", ""rnzshtacblvc"", ""rdkgzoozgkdr"", ""rdkgzoozgkdr"", ""pvvxbllbxvvp"", ""femnjowaaeae"", ""ckwpbbbbpwkc"", ""cvlbcathsznr"", ""lkxslsslsxkl"", ""fhfzyrryzfhf"", ""xmyohddhoymx"", ""guzoetqtmdij"", ""myoumrrmuoym"", ""ajpjnccnjpja"", ""pvvxbllbxvvp"", ""ckwpbbbbpwkc"", ""guzoetqtmdij"", ""ndnzussuzndn"", ""tnyzxhhxzynt"", ""yqxubttbuxqy"", ""dzkiyeeyikzd"", ""ndnzussuzndn"", ""ndnzussuzndn"", ""myoumrrmuoym"", ""qtibgllgbitq"", ""ajpjnccnjpja"", ""pjxgqbbqgxjp"", ""jidmtqteozug"", ""lkxslsslsxkl"", ""myoumrrmuoym"", ""rnzshtacblvc"", ""gakkooookkag"", ""yqxubttbuxqy"", ""pjxgqbbqgxjp"", ""gakkooookkag"", ""lkxslsslsxkl"", ""fhfzyrryzfhf"", ""tnyzxhhxzynt"" }, new int[] { 1364, 2817, 1291, 758, 3255, 1559, 2014, 292, 885, 3295, 2989, 2560, 3107, 2919, 2372, 3371, 1721, 3275, 1780, 1915, 2827, 810, 592, 212, 1559, 1383, 1119, 898, 2626, 2940, 2306, 911, 2405, 1022, 1511, 2710, 204, 2338, 2074, 1303, 3252, 2667, 567 }));
        ExampleRunner.eq(84, 50313, new PalindromeGame().getMaximum(new String[] { ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""darpflzfnlcnqvasljnzjnodpulom"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""darpflzfnlcnqvasljnzjnodpulom"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"" }, new int[] { 2979, 2770, 1745, 831, 125, 1960, 1630, 574, 1615, 461, 1740, 2575, 2855, 1461, 2495, 14, 2888, 3644, 3432, 2568, 1997, 581, 581, 3511, 333, 2393, 1942, 1427, 893, 1442, 3466, 608 }));
        ExampleRunner.eq(85, 136876, new PalindromeGame().getMaximum(new String[] { ""ogfb"", ""ceec"", ""aytd"", ""epxk"", ""szmx"", ""dtya"", ""tonc"", ""adda"", ""ceec"", ""dfmi"", ""riir"", ""icci"", ""anwq"", ""nzrr"", ""gntj"", ""adda"", ""oxve"", ""riir"", ""pwwp"", ""mttm"", ""cnot"", ""oiio"", ""mttm"", ""diid"", ""ywrf"", ""frwy"", ""kuuk"", ""imfd"", ""jtcv"", ""atqc"", ""kuuk"", ""anwq"", ""jtcv"", ""duud"", ""jynn"", ""gevx"", ""dvlq"", ""oiio"", ""cnot"", ""kuuk"", ""nzrr"", ""mppm"", ""kxpe"", ""arra"", ""qjlz"", ""dztx"", ""qwna"" }, new int[] { 8465, 6903, 7900, 7597, 7898, 426, 3358, 1261, 4471, 3608, 5527, 1610, 1546, 9321, 1209, 5090, 5527, 8725, 8574, 9612, 4421, 3507, 5774, 8850, 589, 8686, 3824, 237, 5537, 2150, 5894, 8083, 670, 2929, 5525, 4503, 5100, 7940, 6079, 8662, 1651, 6879, 1425, 4276, 2083, 1333, 6672 }));
        ExampleRunner.eq(86, 11894427, new PalindromeGame().getMaximum(new String[] { ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""kfloccjxw"", ""kfloccjxw"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"" }, new int[] { 291588, 88674, 186593, 345840, 343186, 195482, 287926, 323387, 370054, 521861, 260649, 370542, 438425, 255232, 130545, 355120, 322060, 322060, 79525, 108357, 370054, 281733, 109072, 323387, 389235, 344385, 343186, 44636, 75598, 102926, 222961, 389235, 186219, 516416, 186219, 64975, 545366, 10930, 318182, 13873, 222961, 10930, 264829, 344385, 68727, 418499, 263223, 358667, 79525, 430346 }));
        ExampleRunner.eq(87, 1522621, new PalindromeGame().getMaximum(new String[] { ""cmzwyjyxlnsfgkwrbhlprflcmqpxiuyj"", ""cmzwyjyxlnsfgkwrbhlprflcmqpxiuyj"", ""djkzgyfopotaemgodwuctaprrpqnntoi"", ""dyralguuxdgakqwmmwqkagdxuuglaryd"", ""dyralguuxdgakqwmmwqkagdxuuglaryd"", ""fnohkqwgbabqyiipvxxekjqygrwbkdnp"", ""hluflnqdgfpvzadcgaihfacbrnzyyfqx"", ""hwwcbopfzpwrywyvwcyajernopiexohg"", ""iotnnqprrpatcuwdogmeatopofygzkjd"", ""jyuixpqmclfrplhbrwkgfsnlxyjywzmc"", ""lauvvxlwowszjofmmfojzswowlxvvual"", ""mslcwsheidjrnaewcxnhydtxdqrrfnlu"", ""oemrtlibirzckkoxkphcybjwhhgxawvl"", ""pndkbwrgyqjkexxvpiiyqbabgwqkhonf"", ""smcdtnyjzfdsidzddzdisdfzjyntdcms"", ""smcdtnyjzfdsidzddzdisdfzjyntdcms"", ""viquqzrblirtbkcwwckbtrilbrzquqiv"", ""viquqzrblirtbkcwwckbtrilbrzquqiv"" }, new int[] { 190268, 109231, 158715, 180967, 143667, 65850, 78186, 142888, 150816, 7550, 142387, 220028, 2856, 10889, 200326, 18329, 33399, 219458 }));
        ExampleRunner.eq(88, 607080, new PalindromeGame().getMaximum(new String[] { ""zsnbmrmplplpmrmbnsz"", ""yznrijxgkjmdnoxwvim"", ""yvubnsqtadzgnwzxete"", ""yljzmxkofimhtebjoze"", ""yfrpussjgbvypnhjvop"", ""xrvaavzjlltdyhzdcix"", ""xcfoqkhxpapxhkqofcx"", ""wxlswakuixealioqkms"", ""vvggjwomghmzahsdzfv"", ""vlctnuiqlbdrpepxrbi"", ""shsbdjlzcwczljdbshs"", ""rtllbcfakxeqhybbiig"", ""reygnbnwkuntluxhakz"", ""ppjzfgsiztzisgfzjpp"", ""onfddtzceqgqmwggflq"", ""occdjthynqgqxiugevg"", ""nrmabbpxiptifxjzvuf"", ""nfcrmvijfmfjivmrcfn"", ""kzrsmqmkdjiobbhkqef"", ""khplhlckhbcailbdguc"", ""jwbasqklruqufumwdnk"", ""jqyieymkutvehxscgrg"", ""irlrrvfwxyoufpiqecy"", ""irfdcjktodkejyagpll"", ""imqvvjnunzakridvrgm"", ""ijmagrxbjbqltpertln"", ""grgcsxhevtukmyeiyqj"", ""ebsbquqwapbtgcjzmyv"", ""eaemnohdduddhonmeae"", ""dfzirqcmnkjsnyglrlx"", ""dewjotroiegexqrrxha"", ""dekfiyyokakoyyifked"", ""cpkpstzlfnflztspkpc"", ""aybejfkeoagozyobpog"", ""avvymvdsntfylpmpobm"", ""amlbianyciuvjattvhl"" }, new int[] { 44597, 44863, 98628, 215813, 82394, 180514, 144563, 96161, 4932, 82707, 243511, 53869, 223450, 268414, 165252, 130637, 29569, 280986, 136911, 2330, 42303, 116948, 256209, 157799, 269801, 207606, 209146, 235683, 204049, 262055, 218947, 58113, 3001, 66931, 112577, 97114 }));
        ExampleRunner.eq(89, 459736, new PalindromeGame().getMaximum(new String[] { ""obviwimtyqgptlydmzroa"", ""socdvghvhrlxpvnkmrdev"", ""dovgyjqfddhcteixcrfiy"", ""hxtsillmmxitisirwvwlj"", ""nvlyjyklvypyvlkyjylvn"", ""xhpdbwmdhsqshdmwbdphx"", ""hxtsillmmxitisirwvwlj"", ""jlwvwrisitixmmllistxh"", ""uehtutisyvmgkxlbomcbv"", ""snrjwjevnrsdnyljnbksz"", ""zyekxeefiztzifeexkeyz"", ""zyekxeefiztzifeexkeyz"", ""sxoapnliqnvnqilnpaoxs"", ""uehtutisyvmgkxlbomcbv"", ""jlwvwrisitixmmllistxh"", ""socdvghvhrlxpvnkmrdev"", ""xsztxcwxggjvkxuplxzqy"", ""hxtsillmmxitisirwvwlj"", ""mploknwelhfslqmxoxvis"", ""dovgyjqfddhcteixcrfiy"" }, new int[] { 77729, 99477, 66238, 49028, 66238, 54747, 107287, 36484, 55720, 38183, 38451, 55720, 41679, 99277, 96351, 41679, 54834, 59205, 75314, 44906 }));
        ExampleRunner.eq(90, 68897, new PalindromeGame().getMaximum(new String[] { ""rzppjimqangxrsmtkxrprle"", ""hzsxtmjulckgkclujmtxszh"", ""quhcbaagsvxriekposknpft"", ""rozhsqkdzcdavqhgybcnfoa"", ""ozlxvrqzjkssskjzqrvxlzo"", ""hzbsqdiywxwdtwvkfstyrev"", ""icdwpezugigvetnkvpemdwj"", ""uwhhjeqltgjkraeuhlpdftz"", ""cilikkssohcjyconfdalrmj"", ""jwdmepvkntevgiguzepwdci"", ""eipshyeertzaztreeyhspie"" }, new int[] { 3974, 3571, 1447, 1149, 12077, 6467, 21022, 22121, 23934, 28268, 19607 }));
        ExampleRunner.eq(91, 3725832, new PalindromeGame().getMaximum(new String[] { ""yuqewzbelrrumvmcsdrpikzdnekqcitthgbnimgkcaqrkueqo"", ""sjxnnyplhofzwgkeotbbiuwxftmhgafininmwihyojgvbwtwd"", ""yuqewzbelrrumvmcsdrpikzdnekqcitthgbnimgkcaqrkueqo"", ""yuqewzbelrrumvmcsdrpikzdnekqcitthgbnimgkcaqrkueqo"", ""ruyohhlbmpwtipeuogyjgdjutujdgjygouepitwpmblhhoyur"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""vqsejyhtrhloerpsozupyzxtfoddsopzsuvblfxwzpouabmqf"", ""ruyohhlbmpwtipeuogyjgdjutujdgjygouepitwpmblhhoyur"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""vqsejyhtrhloerpsozupyzxtfoddsopzsuvblfxwzpouabmqf"" }, new int[] { 464972, 445821, 496340, 343981, 478941, 480323, 619306, 153655, 91508, 89100, 300720, 524909, 367976, 259538, 448956, 612620 }));
        ExampleRunner.eq(92, 8654, new PalindromeGame().getMaximum(new String[] { ""wgojhrzwvxa"", ""qlifppldqta"", ""qnemcpsouha"", ""zirmlrniyac"", ""hksyixoshvd"", ""mqpcygrgvoy"", ""grbrwublqbk"", ""dknbuwubnkd"", ""mygzlwsaryk"", ""wmfnusuxkly"", ""kjxtppptxjk"", ""wgojhrzwvxa"", ""rswtwjycqxx"", ""ybhwzzunbhd"", ""euwoirhetjw"", ""yvvctujpxxm"", ""gwferdrefwg"", ""kyoflxlfoyk"", ""dhbnuzzwhby"", ""lvlgwgmnlbw"", ""plvmlrfhuvy"", ""pigbefniuxs"", ""zmybbbbbymz"", ""matcdfqdxho"", ""imldklqldgw"", ""jalbeqojwsk"", ""rswtwjycqxx"", ""gahiydlufsn"", ""opdaeneadpo"", ""iwbzoeghocn"", ""euwoirhetjw"", ""pgpqaxaqpgp"", ""benkwywkneb"", ""zmybbbbbymz"", ""axvwzrhjogw"", ""yvuhfrlmvlp"", ""wbswnznwsbw"", ""bjllfuflljb"", ""cpzdgvojkgt"", ""bydqzqzqdyb"", ""hzrwfsfwrzh"", ""tgjipmnmuzz"", ""mzqqruszudm"", ""tgjipmnmuzz"", ""dvhsoxiyskh"", ""zzumnmpijgt"", ""plvmlrfhuvy"", ""hksyixoshvd"", ""rmfionfpujv"", ""premvzwjtsf"" }, new int[] { 921, 98, 143, 130, 736, 677, 863, 854, 637, 466, 458, 621, 1033, 248, 150, 394, 789, 1022, 555, 764, 664, 831, 357, 380, 998, 694, 15, 870, 848, 293, 103, 221, 308, 599, 842, 289, 656, 745, 724, 526, 1015, 991, 603, 41, 169, 931, 994, 664, 116, 19 }));
        ExampleRunner.eq(93, 1860, new PalindromeGame().getMaximum(new String[] { ""baxbfmatowvkzursiflar"", ""njrpmmbshhdwjhisyttrj"", ""yymqubrlpeyrbbmhgurdc"", ""njrpmmbshhdwjhisyttrj"", ""baxbfmatowvkzursiflar"", ""njrpmmbshhdwjhisyttrj"", ""ekkjzzugowrwoguzzjkke"", ""yymqubrlpeyrbbmhgurdc"", ""ekkjzzugowrwoguzzjkke"", ""baxbfmatowvkzursiflar"" }, new int[] { 102, 243, 30, 418, 283, 507, 1056, 1429, 804, 98 }));
        ExampleRunner.eq(94, 499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 7, 63, 222, 190 }));
        ExampleRunner.eq(95, 1, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 1 }));
        ExampleRunner.eq(96, 10, new PalindromeGame().getMaximum(new String[] { ""topcoder"", ""redcoder"", ""redocpot"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(97, 50000000, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"" }, new int[] { 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000 }));
        ExampleRunner.eq(98, 150, new PalindromeGame().getMaximum(new String[] { ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"" }, new int[] { 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 }));
        ExampleRunner.eq(99, 11, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 11 }));
        ExampleRunner.eq(100, 10, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 10 }));
        ExampleRunner.eq(101, 7, new PalindromeGame().getMaximum(new String[] { ""cac"", ""bab"" }, new int[] { 7, 6 }));
        ExampleRunner.eq(102, 9, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"", ""a"" }, new int[] { 1, 2, 3, 4 }));
        ExampleRunner.eq(103, 34, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""b"", ""c"", ""d"" }, new int[] { 1, 12, 14, 8, 5 }));
        ExampleRunner.eq(104, 1, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 1 }));
        ExampleRunner.eq(105, 50, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aba"" }, new int[] { 50, 12 }));
        ExampleRunner.eq(106, 1000, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 1000 }));
        ExampleRunner.eq(107, 11, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 11 }));
        ExampleRunner.eq(108, 3000, new PalindromeGame().getMaximum(new String[] { ""topcoderaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""abaabaabaabaabaabaabaabaabaabaabaaba"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaredocpot"" }, new int[] { 1000, 1000, 1000 }));
        ExampleRunner.eq(109, 9, new PalindromeGame().getMaximum(new String[] { ""aaaa"", ""cbbc"", ""aaaa"", ""aaaa"", ""dawg"" }, new int[] { 1, 2, 4, 3, 100 }));
        ExampleRunner.eq(110, 11012, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ab"", ""ab"", ""ba"", ""ba"", ""ba"", ""ba"" }, new int[] { 1, 2, 3, 4, 1000, 6, 10000 }));
        ExampleRunner.eq(111, 9, new PalindromeGame().getMaximum(new String[] { ""aba"", ""fef"", ""aba"", ""aba"" }, new int[] { 1, 4, 2, 3 }));
        ExampleRunner.eq(112, 10, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 10 }));
        ExampleRunner.eq(113, 111, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aaa"", ""aaa"" }, new int[] { 100, 10, 1 }));
        ExampleRunner.eq(114, 6, new PalindromeGame().getMaximum(new String[] { ""ab"", ""aa"", ""ba"" }, new int[] { 2, 2, 2 }));
        ExampleRunner.eq(115, 718, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""cba"" }, new int[] { 7, 24, 63, 222, 190, 212 }));
        ExampleRunner.eq(116, 10, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 10 }));
        ExampleRunner.eq(117, 12, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ba"", ""ab"" }, new int[] { 5, 6, 6 }));
        ExampleRunner.eq(118, 5, new PalindromeGame().getMaximum(new String[] { ""aba"", ""bbc"", ""cbb"" }, new int[] { 1, 2, 2 }));
        ExampleRunner.eq(119, 441, new PalindromeGame().getMaximum(new String[] { ""abc"", ""sss"", ""cba"" }, new int[] { 3, 433, 5 }));
        ExampleRunner.eq(120, 7, new PalindromeGame().getMaximum(new String[] { ""aba"", ""ccc"", ""mmm"" }, new int[] { 5, 7, 3 }));
        ExampleRunner.eq(121, 16, new PalindromeGame().getMaximum(new String[] { ""aba"", ""cdc"", ""cdc"", ""cdc"" }, new int[] { 5, 3, 7, 4 }));
        ExampleRunner.eq(122, 1, new PalindromeGame().getMaximum(new String[] { ""abcba"" }, new int[] { 1 }));
        ExampleRunner.eq(123, 45, new PalindromeGame().getMaximum(new String[] { ""a"", ""a"", ""a"", ""b"", ""b"", ""b"" }, new int[] { 10, 10, 5, 10, 10, 3 }));
        ExampleRunner.eq(124, 10, new PalindromeGame().getMaximum(new String[] { ""abcd"", ""dcba"", ""abcd"", ""dcba"" }, new int[] { 1, 2, 3, 4 }));
        ExampleRunner.eq(125, 559, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""aba"", ""aba"", ""aba"" }, new int[] { 24, 7, 63, 222, 190, 20, 10, 30 }));
        ExampleRunner.eq(126, 72, new PalindromeGame().getMaximum(new String[] { ""abc"", ""aba"", ""cba"" }, new int[] { 23, 24, 25 }));
        ExampleRunner.eq(127, 87, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 87, 9, 1, 2, 1 }));
        ExampleRunner.eq(128, 12, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 12 }));
        ExampleRunner.eq(129, 37, new PalindromeGame().getMaximum(new String[] { ""abc"", ""eec"", ""cba"", ""cee"", ""abc"", ""ced"", ""cce"" }, new int[] { 7, 8, 9, 11, 9, 7, 8 }));
        ExampleRunner.eq(130, 4, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"" }, new int[] { 1, 2, 1 }));
        ExampleRunner.eq(131, 1002, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ba"", ""cc"", ""dd"" }, new int[] { 1, 1, 500, 1000 }));
        ExampleRunner.eq(132, 10, new PalindromeGame().getMaximum(new String[] { ""aa"", ""ab"", ""ab"", ""ba"", ""cd"", ""dc"", ""dc"" }, new int[] { 1, 1, 2, 3, 1, 2, 3 }));
        ExampleRunner.eq(133, 110, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""cba"" }, new int[] { 1, 10, 100 }));
        ExampleRunner.eq(134, 13, new PalindromeGame().getMaximum(new String[] { ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""onm"", ""lkj"", ""fed"", ""cba"", ""ihg"", ""pep"", ""mir"", ""rim"" }, new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }));
        ExampleRunner.eq(135, 6, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""ccc"" }, new int[] { 1, 2, 3 }));
        ExampleRunner.eq(136, 10, new PalindromeGame().getMaximum(new String[] { ""aba"", ""ddd"" }, new int[] { 5, 10 }));
        ExampleRunner.eq(137, 21, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"" }, new int[] { 5, 3, 4, 5, 4 }));
        ExampleRunner.eq(138, 20, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aca"" }, new int[] { 10, 20 }));
        ExampleRunner.eq(139, 1, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 1 }));
        ExampleRunner.eq(140, 30, new PalindromeGame().getMaximum(new String[] { ""aba"", ""cbc"" }, new int[] { 20, 30 }));
        ExampleRunner.eq(141, 12, new PalindromeGame().getMaximum(new String[] { ""aabbb"", ""aabaa"", ""aabaa"", ""aabaa"", ""bbbaa"", ""abbba"" }, new int[] { 2, 1, 2, 1, 2, 5 }));
        ExampleRunner.eq(142, 10, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aka"" }, new int[] { 5, 10 }));
        ExampleRunner.eq(143, 21, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"", ""aaa"", ""aba"", ""bba"", ""abb"", ""bab"", ""bba"", ""aba"", ""aab"", ""bab"", ""abb"", ""bba"", ""aba"", ""bba"", ""ada"" }, new int[] { 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3 }));
        ExampleRunner.eq(144, 4, new PalindromeGame().getMaximum(new String[] { ""aaab"", ""baaa"", ""baaa"" }, new int[] { 1, 2, 3 }));
        ExampleRunner.eq(145, 92, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""aaa"", ""aaa"", ""bbb"", ""bbb"", ""ccc"", ""ddd"", ""eee"" }, new int[] { 13, 13, 12, 11, 19, 17, 2, 7, 5 }));
        ExampleRunner.eq(146, 1000, new PalindromeGame().getMaximum(new String[] { ""aea"" }, new int[] { 1000 }));
        ExampleRunner.eq(147, 552, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 77, 63, 222, 190 }));
        ExampleRunner.eq(148, 3, new PalindromeGame().getMaximum(new String[] { ""xxx"", ""xex"", ""xxx"" }, new int[] { 1, 1, 1 }));
        ExampleRunner.eq(149, 8, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""cba"" }, new int[] { 3, 2, 5 }));
        ExampleRunner.eq(150, 159, new PalindromeGame().getMaximum(new String[] { ""aa"", ""aa"", ""aa"", ""bb"", ""bb"", ""bb"", ""cc"", ""cc"", ""cc"", ""dd"", ""dd"", ""ab"", ""ba"" }, new int[] { 5, 6, 6, 10, 7, 10, 20, 6, 20, 30, 30, 10, 10 }));
        ExampleRunner.eq(151, 99, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 99 }));
        ExampleRunner.eq(152, 7, new PalindromeGame().getMaximum(new String[] { ""topot"", ""reder"", ""redoc"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(153, 10, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"" }, new int[] { 4, 10 }));
        ExampleRunner.eq(154, 333, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"" }, new int[] { 3, 33, 333 }));
        ExampleRunner.eq(155, 5, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 5 }));
        ExampleRunner.eq(156, 0, new PalindromeGame().getMaximum(new String[] { ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"" }, new int[] { 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50 }));
        ExampleRunner.eq(157, 2499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""aba"", ""xyx"" }, new int[] { 24, 7, 63, 222, 190, 1000, 2000 }));
        ExampleRunner.eq(158, 11, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aba"" }, new int[] { 1, 10 }));
        ExampleRunner.eq(159, 30, new PalindromeGame().getMaximum(new String[] { ""cac"", ""bab"", ""dad"", ""aaa"", ""bbb"", ""ccc"", ""aaa"", ""bbb"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8 }));
        ExampleRunner.eq(160, 49998775, new PalindromeGame().getMaximum(new String[] { ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"" }, new int[] { 1000000, 999999, 999998, 999997, 999996, 999995, 999994, 999993, 999992, 999991, 999990, 999989, 999988, 999987, 999986, 999985, 999984, 999983, 999982, 999981, 999980, 999979, 999978, 999977, 999976, 999975, 999974, 999973, 999972, 999971, 999970, 999969, 999968, 999967, 999966, 999965, 999964, 999963, 999962, 999961, 999960, 999959, 999958, 999957, 999956, 999955, 999954, 999953, 999952, 999951 }));
        ExampleRunner.eq(161, 50, new PalindromeGame().getMaximum(new String[] { ""ana"" }, new int[] { 50 }));
        ExampleRunner.eq(162, 8, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"" }, new int[] { 5, 1, 2 }));
        ExampleRunner.eq(163, 10, new PalindromeGame().getMaximum(new String[] { ""abbasabba"", ""laxmannnn"" }, new int[] { 10, 1 }));
        ExampleRunner.eq(164, 505, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""abc"" }, new int[] { 24, 7, 63, 222, 190, 30 }));
        ExampleRunner.eq(165, 14, new PalindromeGame().getMaximum(new String[] { ""bb"", ""bb"" }, new int[] { 7, 7 }));
        ExampleRunner.eq(166, 285, new PalindromeGame().getMaximum(new String[] { ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
        ExampleRunner.eq(167, 6, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aba"", ""aaa"" }, new int[] { 1, 2, 3 }));
        ExampleRunner.eq(168, 9, new PalindromeGame().getMaximum(new String[] { ""abccba"", ""deffed"", ""abcdef"", ""fedcba"" }, new int[] { 1, 2, 3, 4 }));
        ExampleRunner.eq(169, 90, new PalindromeGame().getMaximum(new String[] { ""anuj"", ""adda"", ""baab"", ""baab"", ""baab"", ""juna"" }, new int[] { 5, 70, 5, 5, 5, 5 }));
        ExampleRunner.eq(170, 431, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ab"", ""cc"", ""ba"" }, new int[] { 1, 30, 400, 1 }));
        ExampleRunner.eq(171, 20, new PalindromeGame().getMaximum(new String[] { ""xyz"", ""xyz"", ""xyz"", ""aba"" }, new int[] { 1, 5, 6, 20 }));
        ExampleRunner.eq(172, 10, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"" }, new int[] { 10, 10 }));
        ExampleRunner.eq(173, 15, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(174, 1200, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"", ""c"" }, new int[] { 1000, 10, 100, 100 }));
        ExampleRunner.eq(175, 4, new PalindromeGame().getMaximum(new String[] { ""aa"", ""bb"" }, new int[] { 4, 4 }));
        ExampleRunner.eq(176, 3, new PalindromeGame().getMaximum(new String[] { ""a"", ""a"", ""a"" }, new int[] { 1, 1, 1 }));
        ExampleRunner.eq(177, 1000000, new PalindromeGame().getMaximum(new String[] { ""noon"" }, new int[] { 1000000 }));
        ExampleRunner.eq(178, 1090, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""cba"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"" }, new int[] { 7, 24, 63, 222, 190, 212, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12 }));
        ExampleRunner.eq(179, 4, new PalindromeGame().getMaximum(new String[] { ""top"", ""red"", ""red"", ""aba"", ""bab"" }, new int[] { 7, 5, 3, 2, 4 }));
        ExampleRunner.eq(180, 310, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"", ""aaa"", ""aaa"" }, new int[] { 50, 60, 100, 150 }));
        ExampleRunner.eq(181, 499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 7, 24, 63, 222, 190 }));
        ExampleRunner.eq(182, 553, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 78, 63, 222, 190 }));
        ExampleRunner.eq(183, 2, new PalindromeGame().getMaximum(new String[] { ""abcba"" }, new int[] { 2 }));
        ExampleRunner.eq(184, 6, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"", ""a"" }, new int[] { 1, 2, 1, 3 }));
        ExampleRunner.eq(185, 18, new PalindromeGame().getMaximum(new String[] { ""aa"", ""ab"", ""ab"", ""ba"", ""cd"", ""dc"", ""dc"", ""as"", ""sa"", ""sa"", ""ew"", ""ew"", ""we"" }, new int[] { 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 3, 2, 1 }));
        ExampleRunner.eq(186, 15, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""cba"" }, new int[] { 1, 5, 10 }));
        ExampleRunner.eq(187, 2, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"" }, new int[] { 1, 2 }));
        ExampleRunner.eq(188, 0, new PalindromeGame().getMaximum(new String[] { ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"" }, new int[] { 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 100000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 100000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 4353, 45, 345, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 4567, 1000000, 1000000, 1000000 }));
        ExampleRunner.eq(189, 24, new PalindromeGame().getMaximum(new String[] { ""asdsa"", ""werew"", ""qwert"", ""trewq"", ""zxcvb"", ""bvcxz"", ""qwert"", ""tgyht"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8 }));
        ExampleRunner.eq(190, 3, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aba"", ""ccc"", ""top"", ""pot"" }, new int[] { 1, 1, 1, 1, 1 }));
        ExampleRunner.eq(191, 40, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""cba"" }, new int[] { 10, 20, 30 }));
        ExampleRunner.eq(192, 5, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"" }, new int[] { 5, 5, 5 }));
        ExampleRunner.eq(193, 859, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aba"", ""xyx"", ""zyz"", ""abc"", ""cba"", ""cba"", ""def"", ""fed"", ""def"" }, new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 }));
        ExampleRunner.eq(194, 1244, new PalindromeGame().getMaximum(new String[] { ""aa"", ""bb"", ""cc"", ""dd"", ""ee"", ""aa"", ""bb"", ""cc"", ""dd"", ""ff"", ""ee"", ""ff"", ""gg"", ""hh"", ""ii"", ""jj"", ""kk"", ""ll"", ""mm"", ""nn"", ""oo"", ""pp"", ""qq"", ""rr"", ""ss"", ""tt"", ""uu"", ""vv"", ""ww"", ""xx"", ""yy"", ""gg"", ""hh"", ""ii"", ""jj"", ""kk"", ""ll"", ""mm"", ""nn"", ""oo"", ""pp"", ""qq"", ""rr"", ""ss"", ""tt"", ""uu"", ""vv"", ""ww"", ""xx"", ""zz"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50 }));
        ExampleRunner.eq(195, 102, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""cba"" }, new int[] { 1, 100, 2 }));
        ExampleRunner.eq(196, 2300000, new PalindromeGame().getMaximum(new String[] { ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"" }, new int[] { 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000 }));
        ExampleRunner.eq(197, 800, new PalindromeGame().getMaximum(new String[] { ""fef"" }, new int[] { 800 }));
        ExampleRunner.eq(198, 11090531, new PalindromeGame().getMaximum(new String[] { ""abcdefghijklmnopqrstuvwxyz"", ""zyxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrqponmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdefghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrqponmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""aaaaaaaaaaaaaaaaaaaaaaaaaa"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""aaaaaaaaaaaaaaaaaaaaaaaaaa"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjhigfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjiggfedcba"", ""bbbbbbbbbbbbbbbbbbbbbbbbbb"", ""ayxwvutsrqponmljkihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""zzzzzzzzzzzzzzzzzzzzzzzzzz"", ""zzzzzzzzzzzzzzzzzzzzzzzzzz"" }, new int[] { 99, 8, 888, 1, 100000, 2, 8, 10000, 999999, 234244, 987898, 1000000, 1000000, 99, 8, 888, 1, 100000, 2, 8, 10000, 999999, 234244, 987898, 1000000, 1000000, 99, 8, 888, 1989, 100000, 2, 8, 10000, 999999, 234244, 987898, 1000000, 1000000, 99, 8, 808, 1908, 100000, 10000, 999999, 234244, 987898, 100000, 1000000 }));
        ExampleRunner.eq(199, 18, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aaa"", ""aaa"" }, new int[] { 5, 6, 7 }));
        ExampleRunner.eq(200, 23, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 23 }));
        ExampleRunner.eq(201, 321, new PalindromeGame().getMaximum(new String[] { ""abba"", ""deed"" }, new int[] { 123, 321 }));
        ExampleRunner.eq(202, 102, new PalindromeGame().getMaximum(new String[] { ""abc"", ""aba"", ""cba"" }, new int[] { 1, 100, 1 }));
        ExampleRunner.eq(203, 103, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ab"", ""ab"", ""ab"", ""ba"", ""ba"", ""ba"", ""ba"" }, new int[] { 10, 11, 12, 13, 14, 14, 14, 15 }));
        ExampleRunner.eq(204, 11, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aba"" }, new int[] { 4, 7 }));
    }
"
168,10067401,44,"    protected int findTheLargestPalindromeProductOfTwo3DigitNumbers() {
        int palindrome = 0;
        int max3DigitNumber = 999;
        int min3DigitNumber = 900;
        int max = max3DigitNumber * max3DigitNumber;
        int min = min3DigitNumber * min3DigitNumber;
        for (int i = max; i >= min; i--) {
            if (isPalindrome(i)) {
                for (int j = min3DigitNumber; j <= max3DigitNumber; j++) {
                    if (i % j == 0 && i / j <= max3DigitNumber) {
                        return i;
                    }
                }
            }
        }
        return palindrome;
    }
"
169,10067402,44,"    protected int findTheLargestPalindromeProductOfTwo3DigitNumbers2() {
        int palindrome = 0;
        for (int a = 9; a > 0; a--) {
            for (int b = 9; b >= 0; b--) {
                for (int c = 9; c >= 0; c--) {
                    palindrome = 100001 * a + 10010 * b + 1100 * c;
                    for (int k = 90; k >= 10; k--) {
                        if (palindrome % k == 0) {
                            int n = palindrome / k / 11;
                            if (n >= 100 && n <= 999) {
                                return palindrome;
                            }
                        }
                    }
                }
            }
        }
        return palindrome;
    }
"
170,10067404,44,"    public static void main(String[] args) {
        FindTheLargestPalindromeProductOfTwo3DigitNumbers sample = new FindTheLargestPalindromeProductOfTwo3DigitNumbers();
        int palindrome = sample.findTheLargestPalindromeProductOfTwo3DigitNumbers2();
        System.out.println(palindrome);
    }
"
171,11560330,44,"    public boolean isPalindrome() {
        return palindrome;
    }
"
172,11560331,44,"    public void setPalindromic(boolean palindrome) {
        this.palindrome = palindrome;
    }
"
173,11674438,44,"    private String[] getWordContents() {
        boolean wasTranslating = GT.getDoTranslate();
        if (!wasTranslating) GT.setDoTranslate(true);
        String[] words = new String[] { ""modelSetMenu"", GT._(""No nodes loaded""), ""configurationComputedMenu"", GT._(""Configurations""), ""elementsComputedMenu"", GT._(""Element""), ""FRAMESbyModelComputedMenu"", GT._(""Model/Frame""), ""languageComputedMenu"", GT._(""Language""), ""PDBaaResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBnucleicResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBcarboResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBheteroComputedMenu"", GT._(""By HETATM""), ""surfMoComputedMenu"", GT._(""Molecular Orbitals""), ""SYMMETRYComputedMenu"", GT._(""Symmetry""), ""hiddenModelSetText"", GT._(""Model information""), ""selectMenuText"", GT._(""Select ({0})""), ""allModelsText"", GT._(""All {0} models""), ""configurationMenuText"", GT._(""Configurations ({0})""), ""modelSetCollectionText"", GT._(""Collection of {0} models""), ""nodesText"", GT._(""nodes: {0}""), ""edgesText"", GT._(""edges: {0}""), ""groupsText"", GT._(""groups: {0}""), ""chainsText"", GT._(""chains: {0}""), ""polymersText"", GT._(""polymers: {0}""), ""modelMenuText"", GT._(""model {0}""), ""viewMenuText"", GT._(""View {0}""), ""mainMenuText"", GT._(""Main Menu""), ""biomoleculesMenuText"", GT._(""Biomolecules""), ""biomoleculeText"", GT._(""biomolecule {0} ({1} nodes)""), ""loadBiomoleculeText"", GT._(""load biomolecule {0} ({1} nodes)""), ""selectAll"", GT._(""All""), ""selectNone"", GT._(""None""), ""hideNotSelectedCheckbox"", GT._(""Display Selected Only""), ""invertSelection"", GT._(""Invert Selection""), ""viewMenu"", GT._(""View""), ""front"", GT._(""Front""), ""left"", GT._(""Left""), ""right"", GT._(""Right""), ""top"", GT._(""Top""), ""bottom"", GT._(""Bottom""), ""back"", GT._(""Back""), ""renderMenu"", GT._(""Style""), ""renderSchemeMenu"", GT._(""Scheme""), ""renderBallAndStick"", GT._(""Ball and Stick""), ""renderWireframe"", GT._(""Wireframe""), ""nodeMenu"", GT._(""Nodes""), ""nodeNone"", GT._(""Off""), ""node15"", GT._(""Small size"", ""15""), ""node20"", GT._(""Small size + 5%"", ""20""), ""node25"", GT._(""Small size + 10%"", ""25""), ""node50"", GT._(""Medium size"", ""50""), ""node75"", GT._(""Medium size + 25%"", ""75""), ""node100"", GT._(""Full size"", ""100""), ""edgeMenu"", GT._(""Edges""), ""edgeNone"", GT._(""Off""), ""edgeWireframe"", GT._(""On""), ""edge20"", GT._(""{0}"", ""0.02""), ""edge50"", GT._(""{0}"", ""0.05""), ""edge100"", GT._(""{0}"", ""0.10""), ""edge150"", GT._(""{0}"", ""0.15""), ""edge200"", GT._(""{0}"", ""0.20""), ""edge250"", GT._(""{0}"", ""0.25""), ""stereoMenu"", GT._(""Stereographic""), ""stereoNone"", GT._(""None""), ""stereoRedCyan"", GT._(""Red+Cyan glasses""), ""stereoRedBlue"", GT._(""Red+Blue glasses""), ""stereoRedGreen"", GT._(""Red+Green glasses""), ""stereoCrossEyed"", GT._(""Cross-eyed viewing""), ""stereoWallEyed"", GT._(""Wall-eyed viewing""), ""labelMenu"", GT._(""Labels""), ""labelNone"", GT._(""None""), ""labelName"", GT._(""With Node Name""), ""labelNumber"", GT._(""With Node Number""), ""labelPositionMenu"", GT._(""Position Label on Node""), ""labelCentered"", GT._(""Centered""), ""labelUpperRight"", GT._(""Upper Right""), ""labelLowerRight"", GT._(""Lower Right""), ""labelUpperLeft"", GT._(""Upper Left""), ""labelLowerLeft"", GT._(""Lower Left""), ""colorMenu"", GT._(""Color""), ""[color_nodes]Menu"", GT._(""Nodes""), ""none"", GT._(""Inherit""), ""black"", GT._(""Black""), ""white"", GT._(""White""), ""cyan"", GT._(""Cyan""), ""red"", GT._(""Red""), ""orange"", GT._(""Orange""), ""yellow"", GT._(""Yellow""), ""green"", GT._(""Green""), ""blue"", GT._(""Blue""), ""indigo"", GT._(""Indigo""), ""violet"", GT._(""Violet""), ""salmon"", GT._(""Salmon""), ""olive"", GT._(""Olive""), ""maroon"", GT._(""Maroon""), ""gray"", GT._(""Gray""), ""slateblue"", GT._(""Slate Blue""), ""gold"", GT._(""Gold""), ""orchid"", GT._(""Orchid""), ""opaque"", GT._(""Make Opaque""), ""translucent"", GT._(""Make Translucent""), ""[color_edges]Menu"", GT._(""Edges""), ""[color_labels]Menu"", GT._(""Labels""), ""[color_background]Menu"", GT._(""Background""), ""[color_vectors]Menu"", GT._(""Vectors""), ""[color_axes]Menu"", GT._(""Axes""), ""[color_boundbox]Menu"", GT._(""Boundbox""), ""zoomMenu"", GT._(""Zoom""), ""zoom50"", ""50%"", ""zoom100"", ""100%"", ""zoom150"", ""150%"", ""zoom200"", ""200%"", ""zoom400"", ""400%"", ""zoom800"", ""800%"", ""zoomIn"", GT._(""Zoom In""), ""zoomOut"", GT._(""Zoom Out""), ""FRAMESanimateMenu"", GT._(""Animation""), ""animModeMenu"", GT._(""Animation Mode""), ""onceThrough"", GT._(""Play Once""), ""palindrome"", GT._(""Palindrome""), ""loop"", GT._(""Loop""), ""play"", GT._(""Play""), ""pause"", GT._(""Pause""), ""resume"", GT._(""Resume""), ""stop"", GT._(""Stop""), ""nextframe"", GT._(""Next Frame""), ""prevframe"", GT._(""Previous Frame""), ""rewind"", GT._(""Rewind""), ""playrev"", GT._(""Reverse""), ""restart"", GT._(""Restart""), ""FRAMESanimFpsMenu"", GT._(""Set FPS""), ""animfps5"", ""5"", ""animfps10"", ""10"", ""animfps20"", ""20"", ""animfps30"", ""30"", ""animfps50"", ""50"", ""SIGNEDwriteMenu"", GT._(""Save""), ""writeFileTextVARIABLE"", GT._(""File {0}""), ""writeState"", GT._(""Script with state""), ""writeHistory"", GT._(""Script with history""), ""writeJpg"", GT._(""{0} Image"", ""JPG""), ""writePng"", GT._(""{0} Image"", ""PNG""), ""[set_axes]Menu"", GT._(""Axes""), ""[set_boundbox]Menu"", GT._(""Boundbox""), ""[set_UNITCELL]Menu"", GT._(""Unit cell""), ""off#axes"", GT._(""Hide""), ""dotted"", GT._(""Dotted""), ""byPixelMenu"", GT._(""Pixel Width""), ""1p"", GT._(""{0} px"", ""1""), ""3p"", GT._(""{0} px"", ""3""), ""5p"", GT._(""{0} px"", ""5""), ""10p"", GT._(""{0} px"", ""10""), ""byAngstromMenu"", GT._(""Angstrom Width""), ""10a"", GT._(""{0} "", ""0.10""), ""20a"", GT._(""{0} "", ""0.20""), ""25a"", GT._(""{0} "", ""0.25""), ""50a"", GT._(""{0} "", ""0.50""), ""100a"", GT._(""{0} "", ""1.0""), ""showSelectionsCheckbox"", GT._(""Selection Halos""), ""showHydrogensCheckbox"", GT._(""Show Hydrogens""), ""showMeasurementsCheckbox"", GT._(""Show Measurements""), ""perspectiveDepthCheckbox"", GT._(""Perspective Depth""), ""showBoundBoxCheckbox"", GT._(""Boundbox""), ""showAxesCheckbox"", GT._(""Axes""), ""showUNITCELLCheckbox"", GT._(""Unit cell""), ""colorrasmolCheckbox"", GT._(""RasMol Colors""), ""aboutComputedMenu"", GT._(""About Jnet"") };
        if (!wasTranslating) GT.setDoTranslate(wasTranslating);
        return words;
    }
"
174,11976309,44,"    public static void main(String[] args) {
        System.out.println(""abba"".equals(new PalindromeDecoding().decode(""ab"", new int[] { 0 }, new int[] { 2 })));
        System.out.println(""Mississippi"".equals(new PalindromeDecoding().decode(""Misip"", new int[] { 2, 3, 1, 7 }, new int[] { 1, 1, 2, 2 })));
        System.out.println(""XYYXXYYXXYYXXYYXXYYXXYYXXYYXXYYX"".equals(new PalindromeDecoding().decode(""XY"", new int[] { 0, 0, 0, 0 }, new int[] { 2, 4, 8, 16 })));
    }
"
175,12453210,44,"    public void testReplaceMethodOverrideWithSetterInjection() {
        DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
        reader.setValidating(true);
        reader.loadBeanDefinitions(new ClassPathResource(""delegationOverrides.xml"", getClass()));
        OverrideOneMethod oom = (OverrideOneMethod) xbf.getBean(""overrideOneMethod"");
        TestBean jenny1 = oom.getPrototypeDependency();
        assertEquals(""Jenny"", jenny1.getName());
        TestBean jenny2 = oom.getPrototypeDependency();
        assertEquals(""Jenny"", jenny2.getName());
        assertNotSame(jenny1, jenny2);
        TestBean dave1 = oom.protectedOverrideSingleton();
        assertEquals(""David"", dave1.getName());
        TestBean dave2 = oom.protectedOverrideSingleton();
        assertEquals(""David"", dave2.getName());
        assertSame(dave1, dave2);
        String str = ""woierowijeiowiej"";
        assertEquals(str, oom.echo(str));
        String s = ""this is not a palindrome"";
        String reverse = new StringBuffer(s).reverse().toString();
        assertEquals(""Should have overridden to reverse, not echo"", reverse, oom.replaceMe(s));
        assertEquals(""Should have overridden no-arg overloaded replaceMe method to return fixed value"", FixedMethodReplacer.VALUE, oom.replaceMe());
        OverrideOneMethodSubclass ooms = (OverrideOneMethodSubclass) xbf.getBean(""replaceVoidMethod"");
        DoSomethingReplacer dos = (DoSomethingReplacer) xbf.getBean(""doSomethingReplacer"");
        assertEquals(null, dos.lastArg);
        String s1 = """";
        String s2 = ""foo bar black sheep"";
        ooms.doSomething(s1);
        assertEquals(s1, dos.lastArg);
        ooms.doSomething(s2);
        assertEquals(s2, dos.lastArg);
    }
"
176,13179361,44,"    void setAnimationReplayMode(int animationReplayMode, float firstFrameDelay, float lastFrameDelay) {
        this.firstFrameDelay = firstFrameDelay > 0 ? firstFrameDelay : 0;
        firstFrameDelayMs = (int) (this.firstFrameDelay * 1000);
        this.lastFrameDelay = lastFrameDelay > 0 ? lastFrameDelay : 0;
        lastFrameDelayMs = (int) (this.lastFrameDelay * 1000);
        if (animationReplayMode >= ANIMATION_ONCE && animationReplayMode <= ANIMATION_PALINDROME) this.animationReplayMode = animationReplayMode; else Logger.error(""invalid animationReplayMode:"" + animationReplayMode);
    }
"
177,13179373,44,"    boolean setAnimationRelative(int direction) {
        int frameStep = this.frameStep * direction * currentDirection;
        int modelIndexNext = currentModelIndex + frameStep;
        boolean isDone = (modelIndexNext > firstModelIndex && modelIndexNext > lastModelIndex || modelIndexNext < firstModelIndex && modelIndexNext < lastModelIndex);
        if (isDone) {
            switch(animationReplayMode) {
                case ANIMATION_ONCE:
                    return false;
                case ANIMATION_LOOP:
                    modelIndexNext = (animationDirection == currentDirection ? firstModelIndex : lastModelIndex);
                    break;
                case ANIMATION_PALINDROME:
                    currentDirection = -currentDirection;
                    modelIndexNext -= 2 * frameStep;
            }
        }
        int nModels = viewer.getModelCount();
        if (modelIndexNext < 0 || modelIndexNext >= nModels) return false;
        setCurrentModelIndex(modelIndexNext);
        return true;
    }
"
178,13179374,44,"    String getAnimationModeName() {
        switch(animationReplayMode) {
            case ANIMATION_LOOP:
                return ""LOOP"";
            case ANIMATION_PALINDROME:
                return ""PALINDROME"";
            default:
                return ""ONCE"";
        }
    }
"
179,13839382,44,"    private int solve(int result, int[] m, int pos) {
        if (m.length == pos) {
            if (isPalindrome(m)) {
                return result;
            }
            return Integer.MAX_VALUE;
        }
        if (m[pos] == 0) {
            m[pos] = 1;
            int solve1 = solve(result + oCost, m, pos + 1);
            m[pos] = -1;
            int solve2 = solve(result + xCost, m, pos + 1);
            m[pos] = 0;
            return Math.min(solve1, solve2);
        }
        return solve(result, m, pos + 1);
    }
"
180,13839384,44,"    public static void main(String[] args) {
        System.out.println(8 == new MinCostPalindrome().getMinimum(""oxo?xox?"", 3, 5));
    }
"
181,14321901,44,"    public void testProblem4() {
        NaturalNumberStream naturalNumberStream = new NaturalNumberStream(1, 999);
        BaseListStream2<Integer, Integer, Integer> cartesianProduct = new BaseListStream2<Integer, Integer, Integer>(naturalNumberStream, naturalNumberStream) {

            public Integer invoke(Integer input0, Integer input1, int index) {
                return input0 * input1;
            }
        };
        ListFilterStream<Integer> filter = new BaseListFilterStream<Integer>(cartesianProduct) {

            public boolean evaluate(Integer object) {
                return palindrome(object);
            }
        };
        MaxAccumulator accumulator = new MaxAccumulator(filter);
        System.out.println(accumulator.getValue());
        assertEquals(new Integer(906609), accumulator.getValue());
    }
"
182,14321903,44,"            public boolean evaluate(Integer object) {
                return palindrome(object);
            }
"
183,14321904,44,"    public static boolean palindrome(int input) {
        String inputAsStreing = """" + input;
        int stringLength = inputAsStreing.length();
        for (int i = 0; i < stringLength / 2; i++) {
            if (inputAsStreing.charAt(i) != inputAsStreing.charAt(stringLength - 1 - i)) return false;
        }
        return true;
    }
"
184,14321905,44,"    public void testPalindrome() {
        assertTrue(palindrome(1001));
        assertFalse(palindrome(1011));
    }
"
185,14357839,44,"    @Override
    public void setUp() throws Exception {
        super.setUp();
        directory = new RAMDirectory();
        Analyzer analyzer = new Analyzer() {

            @Override
            public TokenStream tokenStream(String fieldName, Reader reader) {
                return new WhitespaceTokenizer(reader);
            }

            @Override
            public int getPositionIncrementGap(String fieldName) {
                return 100;
            }
        };
        IndexWriter writer = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
        Document doc = new Document();
        doc.add(new Field(""field"", ""one two three four five"", Field.Store.YES, Field.Index.ANALYZED));
        doc.add(new Field(""repeated"", ""this is a repeated field - first part"", Field.Store.YES, Field.Index.ANALYZED));
        Fieldable repeatedField = new Field(""repeated"", ""second part of a repeated field"", Field.Store.YES, Field.Index.ANALYZED);
        doc.add(repeatedField);
        doc.add(new Field(""palindrome"", ""one two three two one"", Field.Store.YES, Field.Index.ANALYZED));
        writer.addDocument(doc);
        doc = new Document();
        doc.add(new Field(""nonexist"", ""phrase exist notexist exist found"", Field.Store.YES, Field.Index.ANALYZED));
        writer.addDocument(doc);
        doc = new Document();
        doc.add(new Field(""nonexist"", ""phrase exist notexist exist found"", Field.Store.YES, Field.Index.ANALYZED));
        writer.addDocument(doc);
        writer.optimize();
        writer.close();
        searcher = new IndexSearcher(directory, true);
        query = new PhraseQuery();
    }
"
186,14357855,44,"    public void testPalyndrome2() throws Exception {
        query.setSlop(0);
        query.add(new Term(""field"", ""two""));
        query.add(new Term(""field"", ""three""));
        ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""phrase found with exact phrase scorer"", 1, hits.length);
        float score0 = hits[0].score;
        QueryUtils.check(query, searcher);
        query.setSlop(2);
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score1 = hits[0].score;
        assertEquals(""exact scorer and sloppy scorer score the same when slop does not matter"", score0, score1, SCORE_COMP_THRESH);
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(2);
        query.add(new Term(""palindrome"", ""two""));
        query.add(new Term(""palindrome"", ""three""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score2 = hits[0].score;
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(2);
        query.add(new Term(""palindrome"", ""three""));
        query.add(new Term(""palindrome"", ""two""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score3 = hits[0].score;
        QueryUtils.check(query, searcher);
    }
"
187,14357856,44,"    public void testPalyndrome3() throws Exception {
        query.setSlop(0);
        query.add(new Term(""field"", ""one""));
        query.add(new Term(""field"", ""two""));
        query.add(new Term(""field"", ""three""));
        ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""phrase found with exact phrase scorer"", 1, hits.length);
        float score0 = hits[0].score;
        QueryUtils.check(query, searcher);
        query.setSlop(4);
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score1 = hits[0].score;
        assertEquals(""exact scorer and sloppy scorer score the same when slop does not matter"", score0, score1, SCORE_COMP_THRESH);
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(4);
        query.add(new Term(""palindrome"", ""one""));
        query.add(new Term(""palindrome"", ""two""));
        query.add(new Term(""palindrome"", ""three""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score2 = hits[0].score;
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(4);
        query.add(new Term(""palindrome"", ""three""));
        query.add(new Term(""palindrome"", ""two""));
        query.add(new Term(""palindrome"", ""one""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score3 = hits[0].score;
        QueryUtils.check(query, searcher);
    }
"
188,15588498,44,"    private static int tryIterations(int number, BigInteger currentSum, int iterationNumber) {
        if (iterationNumber > iterationLimit) {
            return -1;
        }
        if (PalindromeUtil.checkPalindrome(currentSum) && currentSum.compareTo(BigInteger.valueOf(9)) > 0 && iterationNumber != 1) {
            return iterationNumber;
        }
        BigInteger reverse = PalindromeUtil.reverse(currentSum);
        BigInteger reverseSum = currentSum.add(reverse);
        if (PalindromeUtil.checkPalindrome(reverseSum) && currentSum.compareTo(BigInteger.valueOf(9)) > 0) {
            return iterationNumber;
        }
        int attempt = tryIterations(number, reverseSum, iterationNumber + 1);
        if (attempt != -1) {
            if (reverseSum.compareTo(BigInteger.valueOf(10001l)) < 0) {
                int ival = reverseSum.intValue();
                attempts[ival] = (attempt - iterationNumber);
            }
        }
        return attempt;
    }
"
189,16152855,44,"    public static void main(String[] args) {
        final List<Integer> temp = new ArrayList<Integer>();
        for (int i = 999; i > 1; i--) for (int j = 999; j > 1; j--) {
            final int k = i * j;
            if (isPalindrome(String.valueOf(k))) temp.add(k);
        }
        Collections.sort(temp);
        System.out.println(temp.get(temp.size() - 1));
    }
"
190,16491811,44,"    public void DONT_testPalindrome3() throws CalamariException {
        doTestBooleanExamples(EXAMPLES_PALINDROME_3, EXAMPLES_PALINDROME_3);
    }
"
191,16491812,44,"    public void DONT_testPalindrome4() throws CalamariException {
        doTestBooleanExamples(EXAMPLES_PALINDROME_4, EXAMPLES_PALINDROME_4);
    }
"
192,16896239,44,"    public static void main(String[] args) {
        BigInt sum = BigInt.from(0L);
        for (int i = 0; i < 1000000; i++) {
            if (isDecimalPalindrome(i) && isBinaryPalindrome(i)) {
                sum = sum.plus(String.valueOf(i));
            }
        }
        System.out.println(sum);
    }
"
193,16896240,44,"    private static boolean isBinaryPalindrome(Integer i) {
        return PalindromeChecker.test(Integer.toBinaryString(i));
    }
"
194,16896241,44,"    private static boolean isDecimalPalindrome(Integer i) {
        return PalindromeChecker.test(i.toString());
    }
"
195,18072334,44,"    private void setDefaultValues() {
        setParameter(PARAM_primerFile, """");
        setParameter(PARAM_ampliconsFile, """");
        setParameter(PARAM_numBarcodesPerPrimerPair, ""100"");
        setParameter(PARAM_barcodeLength, ""10"");
        setParameter(PARAM_fivePrimeClamp, ""CG"");
        setParameter(PARAM_maxFlows, ""5"");
        setParameter(PARAM_flowSequence, ""TACG"");
        setParameter(PARAM_keyChar, ""TCAG"");
        setParameter(PARAM_minEditDistance, ""3"");
        setParameter(PARAM_minPalindromeHBonds, ""14"");
        setParameter(PARAM_maxPalindromeMateDistance, ""11"");
        setParameter(PARAM_intDimerMaxScore, ""8"");
        setParameter(PARAM_endDimerMaxScore, ""3"");
        setParameter(PARAM_forwardPrimerAdapterSequence, """");
        setParameter(PARAM_reversePrimerAdapterSequence, """");
        setParameter(PARAM_attachBarcodeToForwardPrimer, ""false"");
        setParameter(PARAM_attachBarcodeToReversePrimer, ""false"");
        this.taskName = TASK_NAME;
    }
"
196,18072335,44,"    public ParameterVO getParameterVO(String key) throws ParameterException {
        if (key == null) return null;
        String value = getParameter(key);
        if (value == null) return null;
        if (key.equals(PARAM_numBarcodesPerPrimerPair)) {
            return new DoubleParameterVO(1, 1000, 100);
        }
        if (key.equals(PARAM_barcodeLength)) {
            return new DoubleParameterVO(1, 100, 10);
        }
        if (key.equals(PARAM_maxFlows)) {
            return new DoubleParameterVO(1, 10, 5);
        }
        if (key.equals(PARAM_minEditDistance)) {
            return new DoubleParameterVO(1, 100, 3);
        }
        if (key.equals(PARAM_minPalindromeHBonds)) {
            return new DoubleParameterVO(1, 100, 14);
        }
        if (key.equals(PARAM_maxPalindromeMateDistance)) {
            return new DoubleParameterVO(1, 100, 11);
        }
        if (key.equals(PARAM_intDimerMaxScore)) {
            return new DoubleParameterVO(1, 100, 8);
        }
        if (key.equals(PARAM_endDimerMaxScore)) {
            return new DoubleParameterVO(1, 100, 3);
        }
        if (key.equals(PARAM_fivePrimeClamp) || key.equals(PARAM_flowSequence) || key.equals(PARAM_keyChar) || key.equals(PARAM_forwardPrimerAdapterSequence) || key.equals(PARAM_reversePrimerAdapterSequence)) {
            return new TextParameterVO(value);
        }
        if (key.equals(PARAM_primerFile) || key.equals(PARAM_ampliconsFile)) {
            return new MultiSelectVO(listOfStringsFromCsvString(value), listOfStringsFromCsvString(value));
        }
        if (key.equals(PARAM_attachBarcodeToForwardPrimer) || key.equals(PARAM_attachBarcodeToReversePrimer)) {
            return new BooleanParameterVO(Boolean.valueOf(value));
        }
        return null;
    }
"
197,18245809,44,"    public void testConverterPalindromeClosuers() throws IOException {
        String in = ""aaaa _bb bb_ ccc *dd dd* eeee"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""aaaa <i>bb bb</i> ccc <strong>dd dd</strong> eeee"");
    }
"
198,18245810,44,"    public void testConverterNonPalindromeClosuers() throws IOException {
        String in = ""aaaa _bb bb* ccc _dd dd* eeee"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""aaaa <i>bb bb<strong> ccc </i>dd dd</strong> eeee"");
    }
"
199,18245811,44,"    public void testTitlePalindromeClosures() throws IOException {
        String in = ""=title one= ==title two== *bold*"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""<h1>title one</h1> <h2>title two</h2> <strong>bold</strong>"");
    }
"
200,18245812,44,"    public void testTitleNonPalindromeClosures() throws IOException {
        String in = ""=title one== =title two== *bold*"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""<h1>title one</h1> <h1>title two</h1> <strong>bold</strong>"");
    }
"
201,19418632,44,"        @Override
        String[] getSupportFileNames() {
            String[] fileNames = new String[9];
            String imagePath = ""org/openscience/jmol/app/images/"";
            fileNames[0] = imagePath + ""lastButton.png"";
            fileNames[1] = imagePath + ""playButton.png"";
            fileNames[2] = imagePath + ""playLoopButton.png"";
            fileNames[3] = imagePath + ""playOnceButton.png"";
            fileNames[4] = imagePath + ""playPalindromeButton.png"";
            fileNames[5] = imagePath + ""prevButton.png"";
            fileNames[6] = imagePath + ""pauseButton.png"";
            fileNames[7] = imagePath + ""nextButton.png"";
            fileNames[8] = imagePath + ""firstButton.png"";
            return (fileNames);
        }
"
202,19418633,44,"        @Override
        String getJavaScript(int appletID, JmolInstance instance) {
            String jsString = ""<table id=\""AnimContrl\"" class=\""AnimContrlCSS\"">"";
            jsString += ""<tbody><tr><td>"" + GT.escapeHTML(GT._(""Animation"")) + ""</td></tr><tr><td><table><tbody>"";
            jsString += ""<tr><td><button title=\"""" + GT.escapeHTML(GT._(""First Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame rewind\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""firstButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Previous Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame previous\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""prevButton.png\"" ></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Play"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame play\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""playButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Next Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame next\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""nextButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Pause"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame pause\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""pauseButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Last Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame last\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""lastButton.png\""></button></td>"";
            jsString += ""</tr></tbody></table><table><tbody><tr><td>"" + GT.escapeHTML(GT._(""Mode:"")) + ""</td>"";
            jsString += ""<td id=\""jmol_loop_"" + appletID + ""\""><button title=\"""" + GT.escapeHTML(GT._(""Loop"")) + ""\"" onclick=\""jmol_animationmode(\'loop\',"" + appletID + "");\"">"";
            jsString += ""<img src = \""playLoopButton.png\"" ></button></td>"";
            jsString += ""<td id=\""jmol_palindrome_"" + appletID + ""\""><button title=\"""" + GT.escapeHTML(GT._(""Palindrome"")) + ""\"" onclick=\""jmol_animationmode(\'palindrome\', "" + appletID + "");\"">"";
            jsString += ""<img src = \""playPalindromeButton.png\"" ></button></td>"";
            jsString += ""<td id=\""jmol_playOnce_"" + appletID + ""\"" style=\""background:blue;\""><button title=\"""" + GT.escapeHTML(GT._(""Play Once"")) + ""\"" style=\""font-size:0px\"" onclick=\""jmol_animationmode(\'playOnce\', "" + appletID + "");\"">"";
            jsString += ""<img src = \""playOnceButton.png\"" ></button></td></tr></tbody></table></td></tr></tbody></table>"";
            return (jsString);
        }
"
203,19692114,44,"    protected int slideWindow(StringBuffer s) {
        StringBuffer r = new StringBuffer(s);
        r.reverse();
        int max_count = 0;
        int max_i = 0;
        int max_j = 0;
        for (int i = 0; i < s.length(); i++) {
            int counter = 0;
            for (int j = i; j < r.length(); j++) {
                if (s.charAt(j) == Statics.getAcidComp(r.charAt(j))) {
                    counter++;
                } else {
                    if (counter > max_count) {
                        max_count = counter;
                        max_i = j - counter;
                        max_j = j;
                    }
                    counter = 0;
                }
            }
        }
        if (max_count > 9999) {
            System.out.println(s);
            for (int i = 0; i < r.length(); i++) {
                System.out.print(Statics.getAcidComp(r.charAt(i)));
            }
            System.out.print(""\n"");
            if ((max_i + max_j) == s.length()) {
                System.out.println(""Is Palindrome"");
            }
            System.out.println(""Max Count: "" + max_count);
            System.out.println(""Start: "" + max_i);
            System.out.println(""End: "" + max_j);
        }
        return max_count;
    }
"
204,19910710,44,"    public static void main(String[] args) {
        Integer max = null;
        for (int x = 999; x > 0; x--) {
            for (int y = 999; y > 0; y--) {
                int possiblePalindrome = x * y;
                if (PalindromeChecker.test("""" + possiblePalindrome)) {
                    if (max == null) {
                        max = possiblePalindrome;
                    }
                    if (possiblePalindrome > max) {
                        max = possiblePalindrome;
                    }
                }
            }
        }
        System.out.println(max);
    }
"
205,20449037,44,"    private void setupLabels() {
        labels = new Hashtable<String, String>();
        labels.put(""macros"", GT._(""&Macros""));
        labels.put(""file"", GT._(""&File""));
        labels.put(""newwin"", GT._(""&New""));
        labels.put(""open"", GT._(""&Open""));
        labels.put(""openTip"", GT._(""Open a file.""));
        labels.put(""openurl"", GT._(""Open &URL""));
        labels.put(""openpdb"", GT._(""&Get PDB""));
        labels.put(""openmol"", GT._(""Get &MOL""));
        labels.put(""reloadScript"", GT._(""&Reload""));
        labels.put(""openJSpecViewScript"", ""JSpecView"");
        labels.put(""editor"", GT._(""Scrip&t Editor...""));
        labels.put(""console"", GT._(""Conso&le...""));
        labels.put(""jconsole"", GT._(""Jmol Java &Console""));
        labels.put(""atomsetchooser"", GT._(""AtomSet&Chooser...""));
        labels.put(""saveas"", GT._(""&Save As...""));
        labels.put(""exportMenu"", GT._(""&Export""));
        labels.put(""export"", GT._(""Export &Image...""));
        labels.put(""exportTip"", GT._(""Save current view as an image.""));
        labels.put(""toweb"", GT._(""Export to &Web Page...""));
        labels.put(""towebTip"", GT._(""Export one or more views to a web page.""));
        labels.put(""povray"", GT._(""Render in POV-&Ray...""));
        labels.put(""povrayTip"", GT._(""Render in POV-Ray""));
        labels.put(""write"", GT._(""Write &State...""));
        labels.put(""writeTip"", GT._(""Save current view as a Jmol state script.""));
        labels.put(""print"", GT._(""&Print...""));
        labels.put(""printTip"", GT._(""Print view.""));
        labels.put(""close"", GT._(""&Close""));
        labels.put(""exit"", GT._(""E&xit""));
        labels.put(""recentFiles"", GT._(""Recent &Files...""));
        labels.put(""edit"", GT._(""&Edit""));
        labels.put(""selectall"", GT._(""Select &All""));
        labels.put(""deselectall"", GT._(""Deselect All""));
        labels.put(""copyImage"", GT._(""Copy &Image""));
        labels.put(""copyScript"", GT._(""Copy Script""));
        labels.put(""prefs"", GT._(""Pr&eferences...""));
        labels.put(""pasteClipboard"", GT._(""&Paste""));
        labels.put(""editSelectAllScript"", GT._(""Select &All""));
        labels.put(""selectMenu"", GT._(""&Select""));
        labels.put(""selectMenuText"", GT._(""&Select""));
        labels.put(""selectAllScript"", GT._(""&All""));
        labels.put(""selectNoneScript"", GT._(""&None""));
        labels.put(""selectHydrogenScript"", GT._(""Hydrogen""));
        labels.put(""selectCarbonScript"", GT._(""Carbon""));
        labels.put(""selectNitrogenScript"", GT._(""Nitrogen""));
        labels.put(""selectOxygenScript"", GT._(""Oxygen""));
        labels.put(""selectPhosphorusScript"", GT._(""Phosphorus""));
        labels.put(""selectSulfurScript"", GT._(""Sulfur""));
        labels.put(""selectAminoScript"", GT._(""Amino""));
        labels.put(""selectNucleicScript"", GT._(""Nucleic""));
        labels.put(""selectWaterScript"", GT._(""Water""));
        labels.put(""selectHeteroScript"", GT._(""Hetero""));
        labels.put(""display"", GT._(""&Display""));
        labels.put(""atomMenu"", GT._(""&Atom""));
        labels.put(""atomNoneScript"", GT._(""&None""));
        labels.put(""atom15Script"", GT._(""{0}% van der Waals"", ""15""));
        labels.put(""atom20Script"", GT._(""{0}% van der Waals"", ""20""));
        labels.put(""atom25Script"", GT._(""{0}% van der Waals"", ""25""));
        labels.put(""atom100Script"", GT._(""{0}% van der Waals"", ""100""));
        labels.put(""bondMenu"", GT._(""&Bond""));
        labels.put(""bondNoneScript"", GT._(""&None""));
        labels.put(""bondWireframeScript"", GT._(""&Wireframe""));
        labels.put(""bond100Script"", GT._(""{0} "", ""0.10""));
        labels.put(""bond150Script"", GT._(""{0} "", ""0.15""));
        labels.put(""bond200Script"", GT._(""{0} "", ""0.20""));
        labels.put(""labelMenu"", GT._(""&Label""));
        labels.put(""labelNoneScript"", GT._(""&None""));
        labels.put(""labelSymbolScript"", GT._(""&Symbol""));
        labels.put(""labelNameScript"", GT._(""&Name""));
        labels.put(""labelNumberScript"", GT._(""&Number""));
        labels.put(""labelCenteredScript"", GT._(""&Centered""));
        labels.put(""labelUpperRightScript"", GT._(""&Upper right""));
        labels.put(""vectorMenu"", GT._(""&Vector""));
        labels.put(""vectorOffScript"", GT._(""&None""));
        labels.put(""vectorOnScript"", GT._(""&On""));
        labels.put(""vector3Script"", GT._(""{0} pixels"", ""3""));
        labels.put(""vector005Script"", GT._(""{0} "", ""0.05""));
        labels.put(""vector01Script"", GT._(""{0} "", ""0.1""));
        labels.put(""vectorScale02Script"", GT._(""Scale {0}"", ""0.2""));
        labels.put(""vectorScale05Script"", GT._(""Scale {0}"", ""0.5""));
        labels.put(""vectorScale1Script"", GT._(""Scale {0}"", ""1""));
        labels.put(""vectorScale2Script"", GT._(""Scale {0}"", ""2""));
        labels.put(""vectorScale5Script"", GT._(""Scale {0}"", ""5""));
        labels.put(""zoomMenu"", GT._(""&Zoom""));
        labels.put(""zoom100Script"", GT._(""{0}%"", ""100""));
        labels.put(""zoom150Script"", GT._(""{0}%"", ""150""));
        labels.put(""zoom200Script"", GT._(""{0}%"", ""200""));
        labels.put(""zoom400Script"", GT._(""{0}%"", ""400""));
        labels.put(""zoom800Script"", GT._(""{0}%"", ""800""));
        labels.put(""perspectiveCheck"", GT._(""&Perspective Depth""));
        labels.put(""axesCheck"", GT._(""A&xes""));
        labels.put(""boundboxCheck"", GT._(""B&ounding Box""));
        labels.put(""hydrogensCheck"", GT._(""&Hydrogens""));
        labels.put(""vectorsCheck"", GT._(""V&ectors""));
        labels.put(""measurementsCheck"", GT._(""&Measurements""));
        labels.put(""resize"", GT._(""Resi&ze""));
        labels.put(""view"", GT._(""&View""));
        labels.put(""front"", GT._(""&Front""));
        labels.put(""top"", GT._(""&Top""));
        labels.put(""bottom"", GT._(""&Bottom""));
        labels.put(""right"", GT._(""&Right""));
        labels.put(""left"", GT._(""&Left""));
        labels.put(""transform"", GT._(""Tr&ansform...""));
        labels.put(""definecenter"", GT._(""Define &Center""));
        labels.put(""tools"", GT._(""&Tools""));
        labels.put(""gauss"", GT._(""&Gaussian...""));
        labels.put(""viewMeasurementTable"", GT._(""&Measurements"") + ""..."");
        labels.put(""distanceUnitsMenu"", GT._(""Distance &Units""));
        labels.put(""distanceNanometersScript"", GT._(""&Nanometers 1E-9""));
        labels.put(""distanceAngstromsScript"", GT._(""&Angstroms 1E-10""));
        labels.put(""distancePicometersScript"", GT._(""&Picometers 1E-12""));
        labels.put(""animateMenu"", GT._(""&Animate...""));
        labels.put(""vibrateMenu"", GT._(""&Vibrate...""));
        labels.put(""graph"", GT._(""&Graph...""));
        labels.put(""chemicalShifts"", GT._(""Calculate chemical &shifts...""));
        labels.put(""crystprop"", GT._(""&Crystal Properties""));
        labels.put(""animateOnceScript"", GT._(""&Once""));
        labels.put(""animateLoopScript"", GT._(""&Loop""));
        labels.put(""animatePalindromeScript"", GT._(""P&alindrome""));
        labels.put(""animateStopScript"", GT._(""&Stop animation""));
        labels.put(""animateRewindScript"", GT._(""&Rewind to first frame""));
        labels.put(""animateRewindScriptTip"", GT._(""Rewind to first frame""));
        labels.put(""animateNextScript"", GT._(""Go to &next frame""));
        labels.put(""animateNextScriptTip"", GT._(""Go to next frame""));
        labels.put(""animatePrevScript"", GT._(""Go to &previous frame""));
        labels.put(""animatePrevScriptTip"", GT._(""Go to previous frame""));
        labels.put(""animateAllScript"", GT._(""All &frames""));
        labels.put(""animateAllScriptTip"", GT._(""All frames""));
        labels.put(""animateLastScript"", GT._(""Go to &last frame""));
        labels.put(""animateLastScriptTip"", GT._(""Go to last frame""));
        labels.put(""vibrateStartScript"", GT._(""Start &vibration""));
        labels.put(""vibrateStopScript"", GT._(""&Stop vibration""));
        labels.put(""vibrateRewindScript"", GT._(""&First frequency""));
        labels.put(""vibrateNextScript"", GT._(""&Next frequency""));
        labels.put(""vibratePrevScript"", GT._(""&Previous frequency""));
        labels.put(""surfaceTool"", GT._(""SurfaceTool...""));
        labels.put(""surfaceToolTip"", GT._(""Control Display of Surfaces""));
        labels.put(""help"", GT._(""&Help""));
        labels.put(""about"", GT._(""About Jmol""));
        labels.put(""uguide"", GT._(""User Guide""));
        labels.put(""whatsnew"", GT._(""What's New""));
        labels.put(""Prefs.showHydrogens"", GT._(""Hydrogens""));
        labels.put(""Prefs.showMeasurements"", GT._(""Measurements""));
        labels.put(""Prefs.perspectiveDepth"", GT._(""Perspective Depth""));
        labels.put(""Prefs.showAxes"", GT._(""Axes""));
        labels.put(""Prefs.showBoundingBox"", GT._(""Bounding Box""));
        labels.put(""Prefs.axesOrientationRasmol"", GT._(""RasMol/Chime compatible axes orientation/rotations""));
        labels.put(""Prefs.openFilePreview"", GT._(""File Preview (requires restarting Jmol)""));
        labels.put(""Prefs.clearHistory"", GT._(""Clear history (requires restarting Jmol)""));
        labels.put(""Prefs.isLabelAtomColor"", GT._(""Use Atom Color""));
        labels.put(""Prefs.isBondAtomColor"", GT._(""Use Atom Color""));
        labels.put(""rotateScriptTip"", GT._(""Rotate molecule.""));
        labels.put(""pickScriptTip"", GT._(""Select a set of atoms using SHIFT-LEFT-DRAG.""));
        labels.put(""pickMeasureScriptTip"", GT._(""Click atoms to measure distances""));
        labels.put(""pickCenterScriptTip"", GT._(""Click an atom to center on it""));
        labels.put(""homeTip"", GT._(""Return molecule to home position.""));
        labels.put(""modelkitScriptTip"", GT._(""Open the model kit.""));
        labels.put(""JavaConsole.clear"", GT._(""Clear""));
    }
"
206,20789654,44,"    public static void main(String[] args) {
        long maxProduct = 0;
        String result = null;
        for (int i = 999; i > 99; i--) {
            for (int j = 999; j > 99; j--) {
                long product = i * j;
                boolean isPalindrome = PalindromeUtil.checkPalindrome(product);
                if (isPalindrome) {
                    if (product > maxProduct) {
                        maxProduct = product;
                        result = ""Numbers are: "" + i + "", "" + j + "" with product: "" + product;
                    }
                }
            }
        }
        System.out.println(result);
    }
"
207,21619743,44,"    public static void main(String[] args) {
        long sum = 0;
        for (int number = 1; number < 1000000; number++) {
            if (PalindromeUtil.checkPalindrome(number)) {
                String binary = Integer.toString(number, 2);
                if (PalindromeUtil.checkPalindrome(binary)) {
                    System.out.println(number + ""\t"" + binary);
                    sum += number;
                }
            }
        }
        System.out.println(""Sum of all numbers: "" + sum);
    }
"
208,21665284,44,"    public boolean isPalindrome(String s) {
        return new StringBuilder(s).reverse().toString().equals(s);
    }
"
209,22174814,44,"    boolean setAnimationRelative(int direction) {
        int frameStep = this.frameStep * direction * currentDirection;
        int modelIndexNext = currentModelIndex + frameStep;
        boolean isDone = (modelIndexNext > firstModelIndex && modelIndexNext > lastModelIndex || modelIndexNext < firstModelIndex && modelIndexNext < lastModelIndex);
        if (isDone) {
            switch(animationReplayMode) {
                case ONCE:
                    return false;
                case LOOP:
                    modelIndexNext = (animationDirection == currentDirection ? firstModelIndex : lastModelIndex);
                    break;
                case PALINDROME:
                    currentDirection = -currentDirection;
                    modelIndexNext -= 2 * frameStep;
            }
        }
        int nModels = viewer.getModelCount();
        if (modelIndexNext < 0 || modelIndexNext >= nModels) return false;
        setCurrentModelIndex(modelIndexNext);
        return true;
    }
"
210,22820417,44,"    public void testPalindrome() {
        assertFalse(Loop.isPalindrome(""abcdef""));
        assertFalse(Loop.isPalindrome(""abccda""));
        assertFalse(Loop.isPalindrome(""abccda""));
        assertFalse(Loop.isPalindrome(""abcxba""));
        assertTrue(Loop.isPalindrome(""a""));
        assertTrue(Loop.isPalindrome(""aa""));
        assertFalse(Loop.isPalindrome(""ab""));
        assertTrue(Loop.isPalindrome(""""));
        assertTrue(Loop.isPalindrome(""aaa""));
        assertTrue(Loop.isPalindrome(""aba""));
        assertFalse(Loop.isPalindrome(""abbba""));
        assertFalse(Loop.isPalindrome(""abba""));
        assertFalse(Loop.isPalindrome(""abbas""));
    }
"
211,23355902,44,"    public static boolean checkPalindrome(long number) {
        String num = String.valueOf(number);
        return checkPalindrome(num);
    }
"
212,23355905,44,"    public static boolean checkPalindrome(BigInteger currentSum) {
        if (currentSum == null) {
            return false;
        }
        return checkPalindrome(currentSum.toString());
    }
"
1766,23677142,7,"	public static void BubbleSortShort2(short[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					short temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
"
9814,22409057,7,"    private void sortWhats(String[] labels, int[] whats, String simplifyString) {
        int n = whats.length;
        boolean swapped;
        do {
            swapped = false;
            for (int i = 0; i < n - 1; i++) {
                int i0_pos = simplifyString.indexOf(labels[whats[i]]);
                int i1_pos = simplifyString.indexOf(labels[whats[i + 1]]);
                if (i0_pos > i1_pos) {
                    int temp = whats[i];
                    whats[i] = whats[i + 1];
                    whats[i + 1] = temp;
                    swapped = true;
                }
            }
        } while (swapped);
    }
"
6903,22026286,7,"    public static void main(String args[]) {
        int i, j, l;
        short NUMNUMBERS = 100;
        short numbers[] = new short[NUMNUMBERS];
        printIntro();
        int time = (int) System.currentTimeMillis();
        for (i = 0; i < NUMNUMBERS; i++) {
            numbers[i] = (short) (NUMNUMBERS - 1 - i);
        }
        for (i = 0; i < NUMNUMBERS; i++) {
            for (j = 0; j < NUMNUMBERS - i - 1; j++) {
                if (numbers[j] > numbers[j + 1]) {
                    short temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
            if (WANT_PROGRESS) {
                printProgress();
            }
        }
        time = (int) System.currentTimeMillis() - time;
        System.out.print(time);
        System.out.print(""End\n"");
    }
"
5775,23089693,7,"    public int NthLowestSkill(int n) {
        int[] skillIds = new int[] { 0, 1, 2, 3 };
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 3 - j; i++) {
                if (Skills()[skillIds[i]] > Skills()[skillIds[i + 1]]) {
                    int temp = skillIds[i];
                    skillIds[i] = skillIds[i + 1];
                    skillIds[i + 1] = temp;
                }
            }
        }
        return skillIds[n - 1];
    }
"
6148,6622146,7,"    public Object[] bubblesort(Object[] tosort) {
        Boolean sorting;
        int upperlimit = tosort.length - 1;
        do {
            sorting = false;
            for (int s0 = 0; s0 < upperlimit; s0++) {
                if (tosort[s0].toString().compareTo(tosort[s0 + 1].toString()) < 0) {
                } else if (tosort[s0].toString().compareTo(tosort[s0 + 1].toString()) == 0) {
                    Object[] tosortnew = new Object[tosort.length - 1];
                    for (int tmp = 0; tmp < s0; tmp++) {
                        tosortnew[tmp] = tosort[tmp];
                    }
                    for (int tmp = s0; tmp < tosortnew.length; tmp++) {
                        tosortnew[tmp] = tosort[tmp + 1];
                    }
                    tosort = tosortnew;
                    upperlimit = upperlimit - 1;
                    s0 = s0 - 1;
                } else if (tosort[s0].toString().compareTo(tosort[s0 + 1].toString()) > 0) {
                    String swap = (String) tosort[s0];
                    tosort[s0] = tosort[s0 + 1];
                    tosort[s0 + 1] = swap;
                    sorting = true;
                }
            }
            upperlimit = upperlimit - 1;
        } while (sorting);
        return tosort;
    }
"
247,23677134,7,"	public static void BubbleSortInt2(int[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					int temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
"
3994,21100204,7,"    public void greatestIncrease(int maxIterations) {
        double[] increase = new double[numModels];
        int[] id = new int[numModels];
        Model md = new Model();
        double oldPerf = 1;
        for (int i = 0; i < numModels; i++) {
            md.addModel(models[i], false);
            increase[i] = oldPerf - md.getLoss();
            id[i] = i;
            oldPerf = md.getLoss();
        }
        for (int i = 0; i < numModels; i++) {
            for (int j = 0; j < numModels - 1 - i; j++) {
                if (increase[j] < increase[j + 1]) {
                    double increasetemp = increase[j];
                    int temp = id[j];
                    increase[j] = increase[j + 1];
                    id[j] = id[j + 1];
                    increase[j + 1] = increasetemp;
                    id[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < maxIterations; i++) {
            addToEnsemble(models[id[i]]);
            if (report) ensemble.report(models[id[i]].getName(), allSets);
            updateBestModel();
        }
    }
"
839,23677137,7,"	public static void BubbleSortDouble1(double[] num) {
		boolean flag = true; // set flag to true to begin first pass
		double temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
"
10502,17630907,7,"    public static int[] sortDescending(int input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] < input[j + 1]) {
                    int mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
"
1399,23677141,7,"	public static void BubbleSortShort1(short[] num) {
		boolean flag = true; // set flag to true to begin first pass
		short temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
"
1617,23677143,7,"	public static void BubbleSortByte1(byte[] num) {
		boolean flag = true; // set flag to true to begin first pass
		byte temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
"
2009,17630906,7,"    public static int[] sortAscending(float input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] > input[j + 1]) {
                    float mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
"
993,23677136,7,"	public static void BubbleSortFloat2(float[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					float temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
"
4024,22486940,7,"    public void sortingByBubble(int[] array) {
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
"
12302,21273055,7,"    public RobotList<Resource> sort_incr_Resource(RobotList<Resource> list, String field) {
        int length = list.size();
        Index_value[] resource_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals(""energy"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).energy);
            }
        } else if (field.equals(""ammostash"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).ammostash);
            }
        } else if (field.equals(""speed"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).speed);
            }
        } else if (field.equals(""health"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (resource_dist[i].value > resource_dist[i + 1].value) {
                    Index_value a = resource_dist[i];
                    resource_dist[i] = resource_dist[i + 1];
                    resource_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Resource> new_resource_list = new RobotList<Resource>(Resource.class);
        for (int i = 0; i < length; i++) {
            new_resource_list.addLast(list.get(resource_dist[i].index));
        }
        return new_resource_list;
    }
"
538,23677144,7,"	public static void BubbleSortByte2(byte[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					byte temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
"
2144,22088424,7,"    public static void main(String[] args) {
        int[] mas = { 5, 10, 20, -30, 55, -60, 9, -40, -20 };
        int next;
        for (int a = 0; a < mas.length; a++) {
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    next = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = next;
                }
            }
        }
        for (int i = 0; i < mas.length; i++) System.out.print("" "" + mas[i]);
    }
"
385,23677145,7,"	public static <T extends Comparable<T>> void BubbleSortComparable1(T[] num) {
		int j;
		boolean flag = true; // set flag to true to begin first pass
		T temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (j = 0; j < num.length - 1; j++) {
				if (num[j].compareTo(num[j + 1]) > 0) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
"
1208,23677138,7,"	public static void BubbleSortDouble2(double[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					double temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
"
4147,13243880,7,"    public int[] bubbleSort(int[] data) {
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data.length - i - 1; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = temp;
                }
            }
        }
        return data;
    }
"
11388,22326008,7,"    @Override
    public void sortArray(int[] array) {
        boolean sorted = false;
        while (sorted == false) {
            sorted = true;
            for (int i = 0; i <= array.length - 2; i++) {
                if (array[i] > array[i + 1]) {
                    int temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                    sorted = false;
                }
            }
        }
    }
"
2020,21273057,7,"    public RobotList<Percentage> sort_incr_Percentage(RobotList<Percentage> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i).percent);
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value > distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Percentage> sol = new RobotList<Percentage>(Percentage.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Percentage(distri[i].value));
        }
        return sol;
    }
"
11258,20660203,7,"    public static void main(String args[]) {
        int temp;
        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };
        for (int j = 0; j < (a1.length * a1.length); j++) {
            for (int i = 0; i < a1.length - 1; i++) {
                if (a1[i] > a1[i + 1]) {
                    temp = a1[i];
                    a1[i] = a1[i + 1];
                    a1[i + 1] = temp;
                }
            }
        }
        for (int i = 0; i < a1.length; i++) {
            System.out.print("" "" + a1[i]);
        }
    }
"
747,23677146,7,"	public static <T extends Comparable<T>> void BubbleSortComparable2(T[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j].compareTo(num[j + 1]) > 0)
				{
					T temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
"
218,23677135,7,"	public static void BubbleSortFloat1(float[] num) {
		boolean flag = true; // set flag to true to begin first pass
		float temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
"
4190,21273054,7,"    public RobotList<Enemy> sort_decr_Enemy(RobotList<Enemy> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals(""health"")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value < enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Enemy> new_enemy_list = new RobotList<Enemy>(Enemy.class);
        for (int i = 0; i < length; i++) {
            new_enemy_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_enemy_list;
    }
"
1470,23677140,7,"	public static void BubbleSortLong2(long[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					long temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
"
3187,22135738,7,"    protected void sort(double[] a) throws Exception {
        for (int i = a.length - 1; i >= 0; i--) {
            boolean swapped = false;
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    double d = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = d;
                    swapped = true;
                }
            }
            if (!swapped) return;
        }
    }
"
47,23677133,7,"	public static void BubbleSortInt1(int[] num) {
		boolean flag = true; // set flag to true to begin first pass
		int temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
"
332,19119522,13,"    private void generateShuffleOrder() {
        if (mShuffleOrder == null || mShuffleOrder.length != mAllImages.getCount()) {
            mShuffleOrder = new int[mAllImages.getCount()];
            for (int i = 0, n = mShuffleOrder.length; i < n; i++) {
                mShuffleOrder[i] = i;
            }
        }
        for (int i = mShuffleOrder.length - 1; i >= 0; i--) {
            int r = mRandom.nextInt(i + 1);
            if (r != i) {
                int tmp = mShuffleOrder[r];
                mShuffleOrder[r] = mShuffleOrder[i];
                mShuffleOrder[i] = tmp;
            }
        }
    }
"
80,23677157,13,"	public static <T> void shuffle3(T[] a) {
		//Standard Fisher-Yates/Knuth Shuffle for Object array
		int length = a.length;
				
		Random random = new Random();
		random.nextInt();
				
		for(int i = 0; i < length; i++) {
			//Chose index to swap with from i <= j < length
			int j = i + random.nextInt(length-i);
			
			//Swap
			T tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
		}
	}
"
2456,20328639,13,"    public static final void shuffle(boolean[] list) {
        for (int i = list.length - 1; i >= 0; i--) {
            int j = rand.nextInt(i + 1);
            if (i == j) {
                continue;
            }
            boolean tmp = list[i];
            list[i] = list[j];
            list[j] = tmp;
        }
    }
"
1269,22961758,13,"    public void touchSomeFiles(int percentage, int mode) {
        try {
            File[] files = dir.listFiles(mff);
            Random rnd = new Random();
            for (int i = files.length - 1; i >= 0; i--) {
                int j = rnd.nextInt(i + 1);
                File swap = files[i];
                files[i] = files[j];
                files[j] = swap;
            }
            int howfar = files.length * percentage / 100;
            if (mode == TOUCH_MODE_RECREATE || mode == TOUCH_MODE_COPY_TWICE) {
                for (int i = 0; i < howfar; i++) {
                    File f = files[i];
                    if (mode == TOUCH_MODE_COPY_TWICE) {
                        File bf = new File(f.getParent(), ""recreate--"" + f.getName());
                        recreateFile(f, bf);
                    } else {
                        recreateFile(f, f);
                    }
                }
                if (mode == TOUCH_MODE_COPY_TWICE) {
                    try {
                        Thread.sleep(15000);
                    } catch (InterruptedException ex) {
                        ex.printStackTrace();
                    }
                    for (int i = 0; i < howfar; i++) {
                        File f = files[i];
                        File bf = new File(f.getParent(), ""recreate--"" + f.getName());
                        recreateFile(bf, f);
                    }
                }
            } else if (mode == TOUCH_MODE_ACCESS || mode == TOUCH_MODE_MODIFY) {
                for (int i = 0; i < howfar; i++) {
                    RandomAccessFile raf = new RandomAccessFile(files[i], mode == TOUCH_MODE_MODIFY ? ""rw"" : ""r"");
                    if (raf.length() > 0) {
                        int pos = rnd.nextInt(Math.max(0, (int) raf.length()));
                        raf.seek(pos);
                        byte byte1 = raf.readByte();
                        if (mode == TOUCH_MODE_MODIFY) {
                            raf.seek(pos);
                            raf.write(byte1);
                        }
                    }
                    raf.close();
                    files[i].setLastModified(LAST_MODIFIED_DATE);
                }
            } else {
                throw new IllegalArgumentException();
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
"
221,22648484,13,"    public ChoiceGenerator randomize() {
        for (int i = values.size() - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            UIAction tmp = values.get(i);
            values.set(i, values.get(j));
            values.set(j, tmp);
        }
        return this;
    }
"
175,23677156,13,"	public static void shuffle2(int[] a) {
		//Alternate Fisher-Yates/Knuth Shuffle
		Random random = new Random();
		random.nextInt();
		
		for(int i = a.length-1; i >= 1; i--) {
			//Choose index to swap from 0 <= j <= i
			int j = random.nextInt(i+1);
			
			//Swap
			int tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
		}
	}
"
812,17621068,13,"    public static synchronized <T> void shuffle(T[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            T temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
"
32,23677155,13,"	public static void shuffle1(int[] a) {
		//Standard Fisher-Yates/Knuth Shuffle
		int length = a.length;
		
		Random random = new Random();
		random.nextInt();
		
		for(int i = 0; i < length; i++) {
			//Chose index to swap with from i <= j < length
			int j = i + random.nextInt(length-i);
			
			//Swap
			int tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
		}
	}
"
1939,19654782,13,"    public static void shuffle(long[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            long swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
"
52,23677226,44,"	public static boolean isPalindrome(String original) {
		//A not very efficient example
		String reverse = """";
		int length = original.length();
		for (int i = length - 1; i >= 0; i--)
			reverse = reverse + original.charAt(i);

		if (original.equals(reverse))
			return true;
		else
			return false;
	}
"
2510,16152856,44,"    private static final boolean isPalindrome(final String s) {
        String opposite = """";
        for (int i = s.length() - 1; i >= 0; i--) opposite = opposite + s.charAt(i);
        return s.equals(opposite);
    }
"
2595,4128381,44,"    public boolean isPalindrome(String s) {
        return new StringBuilder(s).reverse().toString().equals(s);
    }
"
2533,9755674,44,"    private boolean isPalindrome(String w) {
        for (int i = 0; i < w.length() / 2; i++) {
            if (w.charAt(i) != w.charAt(w.length() - 1 - i)) {
                return false;
            }
        }
        return true;
    }
"
1910,22060129,44,"    public static boolean isPalindrome(String string) {
        int limit = string.length() / 2;
        if (limit == 0) {
            return true;
        }
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) {
            if (string.charAt(forward) != string.charAt(backward)) {
                return false;
            }
        }
        return true;
    }
"
1980,177742,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1957,147992,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
1075,4758170,44,"    public static boolean test(String possiblePalindrome) {
        int endOfFirstHalf;
        int startOfSecondHalf;
        if (possiblePalindrome.length() % 2 == 0) {
            endOfFirstHalf = possiblePalindrome.length() / 2;
            startOfSecondHalf = endOfFirstHalf + 1;
        } else {
            endOfFirstHalf = possiblePalindrome.length() / 2;
            startOfSecondHalf = endOfFirstHalf + 2;
        }
        String first = possiblePalindrome.substring(0, endOfFirstHalf);
        String second = possiblePalindrome.substring(startOfSecondHalf - 1);
        return first.equals(reverse(second));
    }
"
2042,935808,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
410,695350,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
443,820538,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
2870,469340,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
942,725500,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
"
